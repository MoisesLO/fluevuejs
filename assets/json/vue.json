[
  {
    "title": "instalacion",
    "contenido":  "<h1>Instalación</h1>\n<h3>Nota de compatibilidad</h3>\n<p>Vue no es compatible con IE8 y versiones anteriores, ya que utiliza las características de\n    ECMAScript 5 que son incompatibles en IE8. Sin embargo, admite todos los navegadores compatibles\n    con ECMAScript 5.</p>\n\n<h3>Notas de lanzamiento</h3>\n<p>Última versión estable: 2.5.16</p>\n<p>Las notas de lanzamiento detalladas para cada versión están disponibles en GitHub.</p>\n\n<h2>Vue Devtools</h2>\n<p>Cuando use Vue, le recomendamos que también instale Vue Devtools en su navegador, lo que le permite inspeccionar y depurar sus aplicaciones de Vue de una manera más amigable.</p>\n\n<h2>Inclusión Directa con script</h2>\n<p>Simplemente descargue e incluya la etiqueta script con la ruta correcta. Vue será registrado como una variable global.</p>\n<p>No utilice la versión minificada (de producción) durante el desarrollo. Usted perderá todas las advertencias interesantes para los errores más comunes!</p>\n<p><b>Versión de Desarrollo</b> Mensajes de error completos y modo de depuración</p>\n<p><b>Versión de Producción</b> Sin mensajes de error, 30.90KB min+gzip</p>\n\n<h3>CDN</h3>\n<p>Es recomendable vincular a un número específico de versión que pueda actualizar manualmente:</p>\n<pre><code> <span >&lt;<span >script</span> <span >src</span>=<span >\"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\"</span>&gt;</span><span >&lt;/<span >script</span>&gt;</span></code></pre>\n<p>Para producción, recomendamos vincular a un número de versión específico y compilar para evitar roturas inesperadas de versiones más nuevas:</p>\n<pre><code><span>&lt;<span>script</span> <span>src</span>=<span>\"https://cdn.jsdelivr.net/npm/vue@2.6.14\"</span>&gt;</span><span>&lt;/<span>script</span>&gt;</span></code></pre>\n<p>Si está utilizando módulos ES nativos, también hay una compilación compatible con módulos ES:</p>\n<pre><code><span>&lt;<span>script</span> <span>type</span>=<span>\"module\"</span>&gt;</span><span class=\"javascript\">\n  <span>import</span> Vue <span>from</span> <span>'https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.esm.browser.js'</span>\n</span><span>&lt;/<span>script</span>&gt;</span></code></pre>\n<p>Puede buscar el código fuente del paquete NPM en cdn.jsdelivr.net/npm/vue .</p>\n<p>Vue también está disponible en unpkg y cdnjs (cdnjs tarda algún tiempo en sincronizarse, por lo que es posible que la última versión aún no esté disponible).</p>\n<p>Asegúrese de leer sobre las diferentes versiones de Vue y use la versión de producción\nen su sitio publicado, reemplazando vue.jscon vue.min.js. Esta es una compilación más pequeña optimizada para la velocidad en lugar de la experiencia de desarrollo.</p>\n\n<h2>NPM</h2>\n<p>NPM es el método de instalación recomendado al crear aplicaciones a gran escala con Vue. Se combina muy bien con paquetes de módulos como Webpack o Browserify . Vue también proporciona herramientas complementarias para la creación de componentes de un solo archivo .</p>\n<pre><code><span># latest stable</span>\n$ npm install vue</code></pre>\n\n<h2>CLI</h2>\n<p>Vue proporciona una CLI oficial para implementar rápidamente aplicaciones ambiciosas de una sola página. Proporciona configuraciones de compilación con baterías para un flujo de trabajo frontend moderno. Solo se necesitan unos minutos para poner en funcionamiento las compilaciones listas para producción, recarga en caliente y almacenamiento de pelusa. Consulte los documentos de la CLI de Vue para obtener más detalles.</p>\n<p>La CLI asume un conocimiento previo de Node.js y las herramientas de compilación asociadas. Si es nuevo en Vue o en las herramientas de compilación de front-end, le recomendamos encarecidamente que lea la guía sin ninguna herramienta de compilación antes de usar la CLI.</p>"
  },
  {
    "title": "Introducción",
    "contenido":  "<h1>Introducción</h1>\n<h2>¿Qué es Vue.js?</h2>\n<p>Vue es un <b>marco progresivo</b> para construir interfaces de usuario. A diferencia de otros marcos monolíticos, Vue está diseñado desde cero para ser adoptable de forma incremental. La biblioteca principal se centra solo en la capa de vista y es fácil de recoger e integrar con otras bibliotecas o proyectos existentes. Por otro lado, Vue también es perfectamente capaz de impulsar aplicaciones sofisticadas de una sola página cuando se usa en combinación con <b>herramientas modernas y bibliotecas de soporte</b> .</p>\n\n<h2>Empezando</h2>\n<p><b>Instalación</b></p>\n<blockquote>La guía oficial asume un conocimiento de nivel intermedio de HTML, CSS y JavaScript. Si es totalmente nuevo en el desarrollo de frontend, puede que no sea la mejor idea saltar directamente a un marco como primer paso: ¡aprenda los conceptos básicos y luego regrese! La experiencia previa con otros marcos ayuda, pero no es necesaria.</blockquote>\n<p>La forma más fácil de probar Vue.js es usando el <b>ejemplo de Hello World</b> . Siéntase libre de abrirlo en otra pestaña y seguirlo mientras revisamos algunos ejemplos básicos. O <b>puede crear un index.htmlarchivo</b> e incluir Vue con:</p>\n<pre><code><span>&lt;!-- development version, includes helpful console warnings --&gt;</span>\n<span>&lt;<span>script</span> <span>src</span>=<span>\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"</span>&gt;</span><span>&lt;/<span>script</span>&gt;</span></code></pre>\n<p>o:</p>\n<pre><code><span>&lt;!-- production version, optimized for size and speed --&gt;</span>\n<span>&lt;<span>script</span> <span>src</span>=<span>\"https://cdn.jsdelivr.net/npm/vue@2\"</span>&gt;</span><span>&lt;/<span>script</span>&gt;</span></code></pre>\n<p>La página de <b>instalación</b> proporciona más opciones para instalar Vue. Nota: Nosotros no recomendamos que los principiantes comienzan con <code>vue-cli</code>, especialmente si usted todavía no está familiarizado con las herramientas de construcción basadas en Node.js.</p>\n<p>En el núcleo de Vue.js hay un sistema que nos permite renderizar datos de forma declarativa al DOM utilizando una sintaxis de plantilla sencilla:</p>\n\n<pre><code><span>&lt;<span>div</span> <span>id</span>=<span>\"app\"</span>&gt;</span><font></font>\n  {{ message }}<font></font>\n<span>&lt;/<span>div</span>&gt;</span></code></pre>\n<br><br>\n<pre><code><span>var</span> app = <span>new</span> Vue({\n  <span>el</span>: <span>'#app'</span>,\n  <span>data</span>: {\n    <span>message</span>: <span>'Hello Vue!'</span><font></font>\n  }<font></font>\n})</code></pre>\n\n<p>¡Ya hemos creado nuestra primera aplicación Vue! Esto se parece bastante a renderizar una plantilla de cadena, pero Vue ha hecho mucho trabajo bajo el capó. Los datos y el DOM ahora están vinculados y ahora todo es <b>reactivo</b> . ¿Como sabemos? Abra la consola JavaScript de su navegador (ahora mismo, en esta página) y establezca <code>app.messageun</code> valor diferente. Debería ver el ejemplo renderizado anterior actualizado en consecuencia.</p>\n<p>Tenga en cuenta que ya no tenemos que interactuar con el HTML directamente. Una aplicación Vue se adjunta a un solo elemento DOM ( <code>#app</code> en nuestro caso) y luego lo controla por completo. El HTML es nuestro punto de entrada, pero todo lo demás sucede dentro de la instancia de Vue recién creada.</p>\n<p>Además de la interpolación de texto, también podemos vincular atributos de elementos como este:</p>\n<pre><code><span>&lt;<span>div</span> <span>id</span>=<span>\"app-2\"</span>&gt;</span>\n  <span>&lt;<span>span</span> <span>v-bind:title</span>=<span>\"message\"</span>&gt;</span><font></font>\n    Hover your mouse over me for a few seconds<font></font>\n    to see my dynamically bound title!<font></font>\n  <span>&lt;/<span>span</span>&gt;</span>\n<span>&lt;/<span>div</span>&gt;</span></code></pre>\n<br>\n<pre><code><span>var</span> app2 = <span>new</span> Vue({\n  <span>el</span>: <span>'#app-2'</span>,\n  <span>data</span>: {\n    <span>message</span>: <span>'You loaded this page on '</span> + <span>new</span> <span>Date</span>().toLocaleString()<font></font>\n  }<font></font>\n})</code></pre>\n\n<p>Aquí nos encontramos con algo nuevo. El <code>v-bin</code> datributo que está viendo se llama <b>directiva</b> . Las directivas tienen el prefijo <code>v-</code> para indicar que son atributos especiales proporcionados por Vue y, como puede haber adivinado, aplican un comportamiento reactivo especial al DOM renderizado. Aquí, básicamente está diciendo \"mantenga el <b>title</b> atributo de este elemento actualizado con la <b>message</b> propiedad en la instancia de Vue\".</p>\n<p>Si vuelve a abrir su consola JavaScript e ingresa <code>app2.message = 'some new message'</code>, verá una vez más que el HTML enlazado, en este caso el <b>title</b> atributo, se ha actualizado.</p>\n<p>También es fácil alternar la presencia de un elemento:</p>\n<pre><code><span>&lt;<span>div</span> <span>id</span>=<span>\"app-3\"</span>&gt;</span>\n  <span>&lt;<span>span</span> <span>v-if</span>=<span>\"seen\"</span>&gt;</span>Now you see me<span>&lt;/<span>span</span>&gt;</span>\n<span>&lt;/<span>div</span>&gt;</span></code></pre>\n<br>\n<pre><code><span>var</span> app3 = <span>new</span> Vue({\n  <span>el</span>: <span>'#app-3'</span>,\n  <span>data</span>: {\n    <span>seen</span>: <span class=\"hljs-literal\">true</span><font></font>\n  }<font></font>\n})</code></pre>\n<br>\n<p>Adelante, entra <code>app3.seen = false</code> en la consola. Debería ver desaparecer el mensaje.</p>\n<p>Este ejemplo demuestra que podemos vincular datos no solo a texto y atributos, sino también a la <b>estructura</b> del DOM. Además, Vue también proporciona un potente sistema de <b>efectos de transición</b> que puede aplicar automáticamente efectos de transición cuando Vue inserta / actualiza / elimina elementos.</p>\n<p>Hay bastantes otras directivas, cada una con su propia funcionalidad especial. Por ejemplo, la <code>v-for</code> directiva se puede utilizar para mostrar una lista de elementos utilizando los datos de una matriz:</p>\n<pre><code><span>&lt;<span>div</span> <span>id</span>=<span>\"app-4\"</span>&gt;</span>\n  <span>&lt;<span>ol</span>&gt;</span>\n    <span>&lt;<span>li</span> <span>v-for</span>=<span>\"todo in todos\"</span>&gt;</span><font></font>\n      {{ todo.text }}<font></font>\n    <span>&lt;/<span>li</span>&gt;</span>\n  <span>&lt;/<span>ol</span>&gt;</span>\n<span>&lt;/<span>div</span>&gt;</span></code></pre>\n<br>\n<pre><code><span>var</span> app4 = <span>new</span> Vue({\n  <span>el</span>: <span>'#app-4'</span>,\n  <span>data</span>: {\n    <span>todos</span>: [<font></font>\n      { <span>text</span>: <span>'Learn JavaScript'</span> },<font></font>\n      { <span>text</span>: <span>'Learn Vue'</span> },<font></font>\n      { <span>text</span>: <span>'Build something awesome'</span> }<font></font>\n    ]<font></font>\n  }<font></font>\n})</code></pre>\n<p>En la consola, ingrese <code>app4.todos.push({ text: 'New item' })</code>. Debería ver un nuevo elemento adjunto a la lista.</p>\n\n<h2>Manejo de la entrada del usuario</h2>\n<p>Para permitir que los usuarios interactúen con su aplicación, podemos usar la <code>v-on</code> directiva para adjuntar detectores de eventos que invocan métodos en nuestras instancias de Vue:</p>\n<pre><code><span>&lt;<span>div</span> <span>id</span>=<span>\"app-5\"</span>&gt;</span>\n  <span>&lt;<span>p</span>&gt;</span>{{ message }}<span>&lt;/<span>p</span>&gt;</span>\n  <span>&lt;<span>button</span> <span>v-on:click</span>=<span>\"reverseMessage\"</span>&gt;</span>Reverse Message<span>&lt;/<span>button</span>&gt;</span>\n<span>&lt;/<span>div</span>&gt;</span></code></pre>\n<br>\n<pre><code><span>var</span> app5 = <span>new</span> Vue({\n  <span>el</span>: <span>'#app-5'</span>,\n  <span>data</span>: {\n    <span>message</span>: <span>'Hello Vue.js!'</span><font></font>\n  },<font></font>\n  <span>methods</span>: {\n    <span>reverseMessage</span>: <span class=\"hljs-function\"><span>function</span> (<span class=\"hljs-params\"></span>) </span>{\n      <span>this</span>.message = <span>this</span>.message.split(<span>''</span>).reverse().join(<span>''</span>)<font></font>\n    }<font></font>\n  }<font></font>\n})</code></pre>\n<p>Tenga en cuenta que en este método actualizamos el estado de nuestra aplicación sin tocar el DOM: todas las manipulaciones del DOM son manejadas por Vue y el código que escribe se centra en la lógica subyacente.</p>\n<p>Vue también proporciona la v-modeldirectiva que hace que el enlace bidireccional entre la entrada del formulario y el estado de la aplicación sea muy sencillo:</p>\n<pre><code><span>&lt;<span>div</span> <span>id</span>=<span>\"app-6\"</span>&gt;</span>\n  <span>&lt;<span>p</span>&gt;</span>{{ message }}<span>&lt;/<span>p</span>&gt;</span>\n  <span>&lt;<span>input</span> <span>v-model</span>=<span>\"message\"</span>&gt;</span>\n<span>&lt;/<span>div</span>&gt;</span></code></pre>\n<br>\n<pre><code><span>var</span> app6 = <span>new</span> Vue({\n  <span>el</span>: <span>'#app-6'</span>,\n  <span>data</span>: {\n    <span>message</span>: <span>'Hello Vue!'</span><font></font>\n  }<font></font>\n})</code></pre>\n\n<h2>Componer con componentes</h2>\n<p>El sistema de componentes es otro concepto importante en Vue, porque es una abstracción que nos permite construir aplicaciones a gran escala compuestas por componentes pequeños, autónomos y, a menudo, reutilizables. Si lo pensamos bien, casi cualquier tipo de interfaz de aplicación se puede abstraer en un árbol de componentes:</p>\n<p>En Vue, un componente es esencialmente una instancia de Vue con opciones predefinidas. Registrar un componente en Vue es sencillo:</p>\n<pre><code><span>// Define a new component called todo-item</span>\nVue.component(<span>'todo-item'</span>, {\n  <span>template</span>: <span>'&lt;li&gt;This is a todo&lt;/li&gt;'</span><font></font>\n})<font></font>\n<font></font>\n<span>var</span> app = <span>new</span> Vue(...)</code></pre>\n<p>Ahora puede componerlo en la plantilla de otro componente:</p>\n<p><pre><code><span>&lt;<span>ol</span>&gt;</span>\n  <span>&lt;!-- Create an instance of the todo-item component --&gt;</span>\n  <span>&lt;<span>todo-item</span>&gt;</span><span>&lt;/<span>todo-item</span>&gt;</span>\n<span>&lt;/<span>ol</span>&gt;</span></code></pre></p>\n<p>Pero esto generaría el mismo texto para cada tarea, lo cual no es muy interesante. Deberíamos poder pasar datos del ámbito principal a los componentes secundarios. Modifiquemos la definición del componente para que acepte un <b>accesorio</b> :</p>\n<pre><code>Vue.component(<span>'todo-item'</span>, {\n  <span>// The todo-item component now accepts a</span>\n  <span>// \"prop\", which is like a custom attribute.</span>\n  <span>// This prop is called todo.</span>\n  <span>props</span>: [<span>'todo'</span>],\n  <span>template</span>: <span>'&lt;li&gt;{{ todo.text }}&lt;/li&gt;'</span>\n})</code></pre>\n<p>Ahora podemos pasar la tarea a cada componente repetido usando <code>v-bind</code>:</p>\n<pre><code><span>&lt;<span>div</span> <span>id</span>=<span>\"app-7\"</span>&gt;</span>\n  <span>&lt;<span>ol</span>&gt;</span>\n    <span>&lt;!--\n      Now we provide each todo-item with the todo object\n      it's representing, so that its content can be dynamic.\n      We also need to provide each component with a \"key\",\n      which will be explained later.\n    --&gt;</span>\n    <span>&lt;<span>todo-item</span>\n      <span>v-for</span>=<span>\"item in groceryList\"</span>\n      <span>v-bind:todo</span>=<span>\"item\"</span>\n      <span>v-bind:key</span>=<span>\"item.id\"</span>\n    &gt;</span><span>&lt;/<span>todo-item</span>&gt;</span>\n  <span>&lt;/<span>ol</span>&gt;</span>\n<span>&lt;/<span>div</span>&gt;</span></code></pre>\n<br>\n<pre><code>Vue.component(<span>'todo-item'</span>, {\n  <span>props</span>: [<span>'todo'</span>],\n  <span>template</span>: <span>'&lt;li&gt;{{ todo.text }}&lt;/li&gt;'</span><font></font>\n})<font></font>\n<font></font>\n<span>var</span> app7 = <span>new</span> Vue({\n  <span>el</span>: <span>'#app-7'</span>,\n  <span>data</span>: {\n    <span>groceryList</span>: [<font></font>\n      { <span>id</span>: <span class=\"hljs-number\">0</span>, <span>text</span>: <span>'Vegetables'</span> },<font></font>\n      { <span>id</span>: <span class=\"hljs-number\">1</span>, <span>text</span>: <span>'Cheese'</span> },<font></font>\n      { <span>id</span>: <span class=\"hljs-number\">2</span>, <span>text</span>: <span>'Whatever else humans are supposed to eat'</span> }<font></font>\n    ]<font></font>\n  }<font></font>\n})</code></pre>\n<p>Este es un ejemplo artificial, pero hemos logrado separar nuestra aplicación en dos unidades más pequeñas, y el hijo está razonablemente bien desacoplado del padre a través de la interfaz de accesorios. Ahora podemos mejorar aún más nuestro <code>todo-item</code> componente con una plantilla y una lógica más complejas sin afectar la aplicación principal.</p>\n<p>En una aplicación grande, es necesario dividir toda la aplicación en componentes para que el desarrollo sea manejable. Hablaremos mucho más sobre los componentes más adelante en la guía , pero aquí hay un ejemplo (imaginario) de cómo se vería la plantilla de una aplicación con componentes:</p>\n<pre><code><span>&lt;<span>div</span> <span>id</span>=<span>\"app\"</span>&gt;</span>\n  <span>&lt;<span>app-nav</span>&gt;</span><span>&lt;/<span>app-nav</span>&gt;</span>\n  <span>&lt;<span>app-view</span>&gt;</span>\n    <span>&lt;<span>app-sidebar</span>&gt;</span><span>&lt;/<span>app-sidebar</span>&gt;</span>\n    <span>&lt;<span>app-content</span>&gt;</span><span>&lt;/<span>app-content</span>&gt;</span>\n  <span>&lt;/<span>app-view</span>&gt;</span>\n<span>&lt;/<span>div</span>&gt;</span></code></pre>\n<h3>Relación con elementos personalizados</h3>\n<p>Es posible que haya notado que los componentes de Vue son muy similares a los <b>elementos personalizados</b> , que forman parte de la <b>especificación de componentes web</b> . Esto se debe a que la sintaxis del componente de Vue se modela libremente según la especificación. Por ejemplo, los componentes de Vue implementan la <b>API Slot</b> y el <code>is</code> atributo especial. Sin embargo, existen algunas diferencias clave:</p>\n<ul>\n  <li>La especificación de componentes web se ha finalizado, pero no se implementa de forma nativa en todos los navegadores. Safari 10.1+, Chrome 54+ y Firefox 63+ admiten componentes web de forma nativa. En comparación, los componentes de Vue no requieren polyfills y funcionan de manera consistente en todos los navegadores compatibles (IE9 y superior). Cuando sea necesario, los componentes de Vue también se pueden envolver dentro de un elemento personalizado nativo.</li>\n  <li>Los componentes de Vue brindan características importantes que no están disponibles en elementos personalizados simples, en particular el flujo de datos de componentes cruzados, la comunicación de eventos personalizados e integraciones de herramientas de construcción.</li>\n</ul>\n<p>Aunque Vue no usa elementos personalizados internamente, tiene una <b>gran interoperabilidad</b> cuando se trata de consumir o distribuir como elementos personalizados. Vue CLI también admite la creación de componentes de Vue que se registran como elementos personalizados nativos.</p>"
  },
  {
    "title": "La instancia Vue",
    "contenido":  "<h1>La instancia Vue</h1>\n<h2>Creando una instancia de Vue</h2>\n<p>Cada aplicación de Vue se comienza creando una nueva <strong>Instancia de Vue</strong> con la\n    función <code>Vue</code>:</p>\n<pre><code><span>var</span> vm = <span>new</span> Vue({\n  <span>// options</span>\n})</code></pre>\n\n<p>Aunque no estrictamente asociado con el patrón MVVM, el diseño de Vue fue en parte inspirado por\n    él.<br>Como\n    una convención, solemos usar la variable <code>vm</code> (abreviación de ViewModel) para\n    hacer referencia a nuestra instancia de Vue.</p>\n<p>Cuando usted crea una instancia de Vue, le pasa un <strong>objeto options</strong>. La mayor\n    parte de esta guía describe cómo usted puede usar estas opciones para crear el\n    comportamiento deseado.<br>Como referencia, usted puede visitar también la lista completa de\n    opciones en la documentación de la API.</p>\n<p>Una aplicación Vue está conformada por una <strong>instancia Vue raíz</strong> creada con\n    <code>new Vue</code>, opcionalmente organizada dentro de un árbol de componentes reusables\n    anidados. Por ejemplo, el árbol de una aplicación TO-DO podría verse así:</p>\n<pre><code>Root Instance\n└─ TodoList\n   ├─ TodoItem\n   │  ├─ TodoButtonDelete\n   │  └─ TodoButtonEdit\n   └─ TodoListFooter\n      ├─ TodosButtonClear\n      └─ TodoListStatistics</code></pre>\n\n<p>Hablaremos sobre el sistema de componentes en detalle después.\n    Por ahora, solo es necesario saber que todos los componentes de Vue son también instancias\n    de Vue, por lo tanto aceptan el mismo objeto options (excepto para unas pocas específicas\n    opciones de raíz).</p>\n<h2>Datos y Métodos</h2>\n<p>Cuando una instancia Vue es creada, agrega todas las propiedades encontradas en su objeto\n    <code>data</code> al <strong>sistema de reactividad</strong> de Vue. Cuando los valores de\n    estas propiedades cambian, la vista “reaccionará”, actualizándose para coincidir con los\n    nuevos valores.</p>\n<pre><code><span>// Our data object</span>\n<span>var</span> data = { <span>a</span>: <span>1</span> }\n\n<span>// The object is added to a Vue instance</span>\n<span>var</span> vm = <span>new</span> Vue({\n  <span>data</span>: data\n})\n\n<span>// Getting the property on the instance</span>\n<span>// returns the one from the original data</span>\nvm.a == data.a <span>// =&gt; true</span>\n\n<span>// Setting the property on the instance</span>\n<span>// also affects the original data</span>\nvm.a = <span>2</span>\ndata.a <span>// =&gt; 2</span>\n\n<span>// ... and vice-versa</span>\ndata.a = <span>3</span>\nvm.a <span>// =&gt; 3</span></code></pre>\n\n<p>Cuando estos datos cambian, la vista volverá a renderizarse. Es preciso señalar que las\n    propiedades en <code>data</code> solo son <strong>reactivas</strong> si ya existían cuando\n    se creó la instancia. Eso significa que si usted agrega una nueva propiedad, como:</p>\n<pre><code>vm.b = <span>'hi'</span></code></pre>\n<p>Entonces los cambios de <code>b</code> no producirán ninguna actualización en la vista. Si\n    sabe que necesitará una propiedad más adelante, pero comienza vacía o inexistente,\n    necesitará setear un valor inicial. Por ejemplo:</p>\n<pre><code>data: {\n  <span>newTodoText</span>: <span>''</span>,\n  <span>visitCount</span>: <span>0</span>,\n  <span>hideCompletedTodos</span>: <span>false</span>,\n  <span>todos</span>: [],\n  <span>error</span>: <span>null</span>\n}</code></pre>\n<p>La unica excepción a esto es el uso de <code>Object.freeze()</code>, lo que evita que se\n    modifiquen las propiedades existentes, lo que también significa que el sistema de\n    reactividad no puede rastrear cambios.</p>\n<pre><code><span>var</span> obj = {\n  <span>foo</span>: <span>'bar'</span>\n}\n\n<span>Object</span>.freeze(obj)\n\n<span>new</span> Vue({\n  <span>el</span>: <span>'#app'</span>,\n  <span>data</span>: obj\n})</code></pre>\n<br>\n<pre><code><span>&lt;<span>div</span> <span>id</span>=<span>\"app\"</span>&gt;</span>\n  <span>&lt;<span>p</span>&gt;</span>{{ foo }}<span>&lt;/<span>p</span>&gt;</span>\n  <span>&lt;!-- this will no longer update `foo`! --&gt;</span>\n  <span>&lt;<span>button</span> <span>v-on:click</span>=<span>\"foo = 'baz'\"</span>&gt;</span>Change it<span>&lt;/<span>button</span>&gt;</span>\n<span>&lt;/<span>div</span>&gt;</span></code></pre>\n\n<p>Además de las propiedades de datos, las instancias de Vue exponen una serie de métodos y\n    propiedades de instancia útiles. Estos tienen el prefijo <code>$</code> para diferenciarlos\n    de las propiedades definidas por el usuario. Por ejemplo:</p>\n<pre><code><span>var</span> data = { <span>a</span>: <span>1</span> }\n<span>var</span> vm = <span>new</span> Vue({\n  <span>el</span>: <span>'#example'</span>,\n  <span>data</span>: data\n})\n\nvm.$data === data <span>// =&gt; true</span>\nvm.$el === <span>document</span>.getElementById(<span>'example'</span>) <span>// =&gt; true</span>\n\n<span>// $watch is an instance method</span>\nvm.$watch(<span>'a'</span>, <span><span>function</span> (<span>newValue, oldValue</span>) </span>{\n  <span>// This callback will be called when `vm.a` changes</span>\n})</code></pre>\n<p>En el futuro, puede consultar la documentación de la\n    API para una lista completa de propiedades y métodos de instancia.</p>\n<h2>Hooks del Ciclo de vida\n    de la Instancia</h2>\n<p>Cada instancia de Vue pasa a través de una serie de pasos de inicialización cuando es creada\n    - por ejemplo, se necesita configurar la observación de datos, compilar la plantilla, montar\n    la instancia en el DOM y actualizar el DOM cuando cambian los datos. En el camino, también\n    se ejecutan funciones llamadas <strong>hooks del ciclo de vida</strong>, lo que brinda a los\n    usuarios la oportunidad de agregar su propio código en etapas específicas.</p>\n<p>Por ejemplo, el hook <code>created</code> puede ser utilizado\n    para ejecutar código después que una instancia es creada:</p>\n<pre><code><span>new</span> Vue({\n  <span>data</span>: {\n    <span>a</span>: <span>1</span>\n  },\n  <span>created</span>: <span><span>function</span> (<span></span>) </span>{\n    <span>// `this` points to the vm instance</span>\n    <span>console</span>.log(<span>'a is: '</span> + <span>this</span>.a)\n  }\n})\n<span>// =&gt; \"a is: 1\"</span></code></pre>\n<p>También hay otros hooks que se llamarán en diferentes etapas del ciclo de vida de la\n    instancia, como <code>mounted</code>, <code>updated</code>, y <code>destroyed</code>. Todos los\n    hooks del ciclo de\n    vida se llaman en el contexto <code>this</code> apuntando a la instancia de Vue que lo\n    invoca.</p>\n<p>No usar arrow functions en una propiedad de opciones o\n    respuesta, como <code>created: () =&gt; console.log(this.a)</code> or <code>vm.$watch('a',\n        newValue =&gt; this.myMethod())</code>. Dado que las arrow functions están vinculadas al\n    contexto padre, <code>this</code> no será la instancia de Vue como lo esperaría, lo que\n    suele producir errores, como ‘Uncaught TypeError: Cannot read property of\n    undefined<code>o</code>Uncaught TypeError: this.myMethod is not a function`.</p>\n\n<h2>Diagrama\n    del Ciclo de vida</h2>\n<p>La imagen de abajo es un diagrama para el ciclo de vida de una instancia. No es necesario que\n    entienda como funciona todo en este momento, pero a medida que aprenda y construya más, será\n    una referencia útil.</p>\n<img src=\"asset:assets/img/lifecycle.png\" alt=\"\">"
  },
  {
    "title": "Sintaxis de Template",
    "contenido":  "<div style=\"font-size: 100%\"><h1>Sintaxis de Template</h1>\n\n<p>Vue.js utiliza una sintaxis de template basada en HTML que le permite vincular de forma declarativa el DOM renderizado a los datos de la instancia de Vue subyacente. Todas las templates de Vue.js son HTML válidas que pueden analizarse mediante navegadores compatibles con especificaciones y analizadores de HTML.</p>\n<p>Bajo el capó, Vue compila las templates en funciones de renderizado del DOM virtual. Combinado con el sistema de reactividad, Vue puede averiguar de manera inteligente el número mínimo de componentes para volver a renderizar y aplicar la cantidad mínima de manipulacion del DOM cuando el estado de la aplicacion cambia.</p>\n<p>Si está familiarizado con los conceptos de DOM virtual y prefiere la potencia bruta de JavaScript, también puede <span class=\"link\">escribir directamente funciones de procesamiento</span> en lugar de plantillas, con soporte opcional de JSX.</p>\n<h2>Interpolaciones</h2><h3>Texto</h3><p>La forma más básica de enlace de datos es la interpolación de texto usando la sintaxis de <em>mustaches</em> (llaves doble):</p>\n<pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Message: {{ msg }}<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br></pre>\n<p>La etiqueta del <em>mustache</em> se reemplazará con el valor de la propiedad <code class=\"naranja\">msg</code> en el objeto de datos correspondiente. También se actualizará cada vez que cambie la propiedad <code class=\"naranja\">msg</code> del objeto de datos.</p>\n<p>También puede realizar interpolaciones únicas que no se actualizan en el cambio de datos usando la <span class=\"link\">directiva v-once</span>, pero tenga en cuenta que esto también afectará a cualquier otro enlace en el mismo nodo:</p>\n<pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-once</span>&gt;</span>Esto nunca cambiara: {{ msg }}<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br></pre>\n<h3>HTML Puro</h3><p>Los <em>mustaches</em> (llaves doble) interpretan los datos como texto plano, no HTML. Para generar HTML real, deberá utilizar la directiva <code class=\"naranja\">v-html</code>:</p>\n<pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Using mustaches: {{ rawHtml }}<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Using v-html directive: <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-html</span>=<span class=\"string\">\"rawHtml\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre>\n\n<p>El contenido del <code class=\"naranja\">span</code> se reemplazará con el valor de la propiedad <code class=\"naranja\">rawHtml</code>, interpretado como HTML simple: se ignoran los enlaces de datos. Tenga en cuenta que no puede utilizar <code class=\"naranja\">v-html</code> para componer plantillas parciales, porque Vue no es un motor de plantillas basado en cadenas. En cambio, se prefieren los componentes como la unidad fundamental para la reutilización y la composición de la interfaz de usuario.</p>\n<p class=\"tip\">La ejecución dinámica de HTML arbitrario en su sitio web puede ser muy peligrosa porque puede conducir fácilmente a <span class=\"link\">vulnerabilidades de XSS</span>. Utilice solo la interpolación HTML en contenido de confianza y <strong>nunca</strong> en contenido proporcionado por usuario.</p>\n\n<h3>Atributos</h3><p>Los <em>mustaches</em> (llaves doble) no se pueden utilizar dentro de los atributos HTML. En su lugar, use una <span class=\"link\">directiva v-bind</span>:</p>\n<pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:id</span>=<span class=\"string\">\"dynamicId\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre>\n<p>En el caso de los atributos booleanos, donde su mera existencia implica <code class=\"naranja\">true</code>, <code class=\"naranja\">v-bind</code> funciona de manera un poco diferente. En este ejemplo:</p>\n<pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-bind:disabled</span>=<span class=\"string\">\"isButtonDisabled\"</span>&gt;</span>Button<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre>\n<p>Si <code class=\"naranja\">isButtonDisabled</code> tiene el valor de <code class=\"naranja\">null</code>, <code class=\"naranja\">undefined</code> o <code class=\"naranja\">false</code>, el atributo <code class=\"naranja\">disabled</code> ni siquiera se incluirá en el elemento <code class=\"naranja\">&lt;button&gt;</code> representado.</p>\n<h3>Usando Expresiones JavaScript</h3><p>Hasta ahora solo hemos estado vinculando a simples claves de propiedad en nuestras template. Pero Vue.js realmente admite el poder completo de las expresiones de JavaScript dentro de todos los enlaces de datos:</p>\n<pre><span class=\"line\">{{ number + 1 }}</span><br><span class=\"line\"></span><br><span class=\"line\">{{ ok ? 'YES' : 'NO' }}</span><br><span class=\"line\"></span><br><span class=\"line\">{{ message.split('').reverse().join('') }}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:id</span>=<span class=\"string\">\"'list-' + id\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre>\n<p>Estas expresiones se evaluarán como JavaScript en el ámbito de datos de la instancia de Vue del propietario. Una restricción es que cada enlace solo puede contener <strong>una expresión</strong>, por lo que lo siguiente <strong>NO</strong> funcionará:</p>\n<pre><span class=\"line\"><span class=\"comment\">&lt;!-- esto es una declaración, no una expresión --&gt;</span></span><br><span class=\"line\">{{ var a = 1 }}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- El control de flujo tampoco funcionará, use expresiones ternarias --&gt;</span></span><br><span class=\"line\">{{ if (ok) { return message } }}</span><br></pre>\n<p class=\"tip\">Las expresiones de template están en un espacio aislado y solo tienen acceso a una lista blanca de elementos globales como <code class=\"naranja\">Matemáticas</code> y <code class=\"naranja\">Fecha</code>. No debe intentar acceder a globales definidos por el usuario en expresiones de template.</p>\n\n<h2>Directivas</h2><p>Las directivas son atributos especiales con el prefijo <code class=\"naranja\">v-</code>. Se espera que los valores de atributo de la directiva sean <strong>una única expresión de JavaScript</strong> (con la excepción de <code class=\"naranja\">v-for</code>, que se tratará más adelante). El trabajo de una directiva es aplicar reactivamente efectos secundarios al DOM cuando cambia el valor de su expresión. Repasemos el ejemplo que vimos en la introducción:</p>\n<pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"seen\"</span>&gt;</span>Now you see me<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre>\n<p>Aquí, la directiva <code class=\"naranja\">v-if</code> insertaría/eliminaría el elemento </p><p> basándose en la veracidad del valor de la expresión <code class=\"naranja\">seen</code>.</p>\n<h3>Argumentos</h3><p>Algunas directivas pueden tomar un “argumento”, denotado por dos puntos después del nombre de la directiva. Por ejemplo, la directiva <code class=\"naranja\">v-bind</code> se usa para actualizar de forma reactiva un atributo HTML:</p>\n<pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-bind:href</span>=<span class=\"string\">\"url\"</span>&gt;</span> ... <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre>\n<p>Aquí href es el argumento, que le dice a la directiva <code class=\"naranja\">v-bind</code> que vincule el atributo <code class=\"naranja\">href</code> del elemento al valor de la expresión <code class=\"naranja\">url</code>.</p>\n<p>Otro ejemplo es la directiva <code class=\"naranja\">v-on</code>, que escucha los eventos DOM:</p>\n<pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"doSomething\"</span>&gt;</span> ... <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre>\n<p>Aquí el argumento es el nombre del evento a escuchar. Hablaremos sobre el manejo de eventos con más detalle también.</p>\n<h3>Modificadores</h3><p>Los modificadores son sufijos especiales indicados por un punto, que indican que una directiva debe estar vinculada de alguna manera especial. Por ejemplo, el modificador <code class=\"naranja\">.prevent</code> le dice a la directiva <code class=\"naranja\">v-on</code> que llame a <code class=\"naranja\">event.preventDefault()</code> en el evento activado:</p>\n<pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">v-on:submit.prevent</span>=<span class=\"string\">\"onSubmit\"</span>&gt;</span> ... <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre>\n<p>Más adelante veremos otros ejemplos de modificadores, <span class=\"link\">para <code class=\"naranja\">v-on</code></span> y <span class=\"link\">para <code class=\"naranja\">v-model</code></span>, cuando exploremos esas características.</p>\n<h2>Modo abreviado</h2><p>El prefijo <code class=\"naranja\">v-</code> sirve como una señal visual para identificar atributos específicos de Vue en sus templates. Esto es útil cuando está utilizando Vue.js para aplicar un comportamiento dinámico a algún marcado existente, pero puede sentirse detallado para algunas directivas de uso frecuente. Al mismo tiempo, la necesidad del prefijo <code class=\"naranja\">v-</code> es menos importante cuando se está construyendo un <span class=\"link\">SPA</span> donde Vue.js administra cada template. Por lo tanto, Vue.js proporciona abreviaturas especiales para dos de las directivas más utilizadas, <code class=\"naranja\">v-bind</code> y <code class=\"naranja\">v-on</code>:</p>\n<h3><code class=\"naranja\">v-bind</code> Abreviado</h3><pre><span class=\"line\"><span class=\"comment\">&lt;!-- full syntax --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-bind:href</span>=<span class=\"string\">\"url\"</span>&gt;</span> ... <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- abreviado --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">:href</span>=<span class=\"string\">\"url\"</span>&gt;</span> ... <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre>\n<h3><code class=\"naranja\">v-on</code> Abreviado</h3><pre><span class=\"line\"><span class=\"comment\">&lt;!-- full syntax --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"doSomething\"</span>&gt;</span> ... <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- abreviado --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"doSomething\"</span>&gt;</span> ... <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre>\n<p>Pueden parecer un poco diferentes del HTML normal, pero <code class=\"naranja\">:</code> y <code class=\"naranja\">@</code> son caracteres válidos para los nombres de atributos y todos los navegadores compatibles con Vue.js pueden analizarlo correctamente. Además, no aparecen en el marcado final renderizado. La sintaxis abreviada es totalmente opcional, pero es probable que la aprecie cuando sepa más sobre su uso más adelante.</p>\n</div>"
  },
  {
    "title": "Propiedades Computadas y Observadores",
    "contenido":  "<h1>Propiedades Computadas y Observadores</h1>\n\n<h2><span class=\"link\">Propiedades Computadas</span></h2>\n<p>Las expresiones en el <em>template</em> son muy convenientes, pero están diseñadas para operaciones simples. Poner demasiada lógica en sus <em>templates</em> puede hacerlos grandes, complejos y difíciles de mantener. Por ejemplo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example\"</span>&gt;</span>\n  {{ message.split('').reverse().join('') }}\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>En este punto, el <em>template</em> ya no es simple y declarativo. Debe mirarlo por un segundo antes de darse cuenta de que muestra <code>message</code> al revés. El problema se agrava cuando desea incluir el mensaje invertido en su <em>template</em> más de una vez.</p>\n<p>Es por eso que para cualquier lógica compleja, deberia usar una <strong>propiedad computada</strong>.</p>\n<h3><span class=\"link\">Ejemplo Básico</span></h3>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Mensaje original: \"{{ message }}\"<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Mensaje invertido computado: \"{{ reversedMessage }}\"<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#example'</span>,\n  data: {\n    message: <span class=\"string\">'Hola'</span>\n  },\n  computed: {\n    <span class=\"comment\">// un getter computado</span>\n    reversedMessage: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n      <span class=\"comment\">// `this` apunta a la instancia vm</span>\n      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.message.split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)\n    }\n  }\n})</span></pre>\n\n\n<p>Aquí hemos declarado una propiedad computada <code>reversedMessage</code>. La función que\nproporcionemos se utilizará como la función getter para la propiedad <code>vm.reversedMessage</code>:</p>\n<pre><span class=\"built_in\">console</span>.log(vm.reversedMessage) <span class=\"comment\">// =&gt; 'aloH'</span>\nvm.message = <span class=\"string\">'Adios'</span>\n<span class=\"built_in\">console</span>.log(vm.reversedMessage) <span class=\"comment\">// =&gt; 'soidA'</span></span></pre>\n<p>Puede abrir la consola y jugar con el ejemplo vm usted mismo. El valor de <code>vm.reversedMessage</code> siempre depende del valor de <code>vm.message</code>.</p>\n<p>Puede enlazar datos a propiedades computadas en el <em>template</em> al igual que una propiedad normal. Vue es consciente de que <code>vm.reversedMessage</code> depende de <code>vm.message</code>, por lo cual actualizará todos los enlaces que dependan de <code>vm.reversedMessage</code> cuando <code>vm.message</code> cambie. Y lo mejor de todo es que hemos creado esta relación de dependencia de manera declarativa: la función computada getter no tiene efectos secundarios, lo que facilita la prueba y la comprensión.</p>\n<h3><span class=\"link\">Caching computado vs Métodos</span></h3>\n<p>Es posible que haya notado que podemos lograr el mismo resultado al invocar un método en la expresión:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Mensaje Invertido: \"{{ reverseMessage() }}\"<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></pre>\n<pre><span class=\"comment\">// en componente</span>\nmethods: {\n  reverseMessage: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.message.split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)\n  }\n}</span></pre>\n<p>En lugar de una propiedad computada, podemos definir la misma función como un método en su lugar. Para el resultado final, los dos enfoques son exactamente los mismos. Sin embargo, la diferencia es que las <strong>propiedades computadas se almacenan en caché según sus dependencias.</strong> Una propiedad computada solo se volverá a evaluar cuando alguna de sus dependencias haya cambiado. Esto significa que mientras <code>message</code> no haya cambiado, el acceso múltiple a la propiedad computada de <code>reverseMessage</code> regresará inmediatamente el resultado previamente calculado sin tener que ejecutar la función de nuevo.</p>\n<p>Esto también significa que la siguiente propiedad computada nunca se actualizará, porque <code>Date.now()</code> no es una dependencia reactiva:</p>\n<pre>computed: {\n  now: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n    <span class=\"keyword\">return</span> <span class=\"built_in\">Date</span>.now()\n  }\n}</span></pre>\n<p>En comparación, una invocación de método <strong>siempre</strong> ejecutará la función cada vez que ocurre una re-renderizacion.</p>\n<p>¿Por qué necesitamos caché? Imagina que tenemos una costosa propiedad computada <strong>A</strong>, que requiere hacer un bucle a través de una gran matriz y hace muchos cálculos. Entonces podemos tener otras propiedades computadas que a su vez dependen de <strong>A</strong>. Sin caché, estaríamos ejecutando el captador de <strong>A</strong> muchas veces más de lo necesario. En los casos en que no desee el almacenamiento en caché, utilice un método en su lugar.</p>\n<h3><span class=\"link\">Propiedad Computada vs Watched</span></h3>\n<p>Vue proporciona una forma más genérica de observar y reaccionar a los cambios de datos en una instancia de Vue: <strong>propiedad watch</strong>. Cuando tiene algunos datos que necesitan cambiarse en función de otros datos, es tentador utilizar <code>watch</code> en exceso, especialmente si proviene de tener experiencia en AngularJS. Sin embargo, a menudo es una mejor idea usar una propiedad computada en lugar de una imperativa llamada a <code>watch</code> . Considera este ejemplo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"demo\"</span>&gt;</span>{{ fullName }}<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#demo'</span>,\n  data: {\n    firstName: <span class=\"string\">'Foo'</span>,\n    lastName: <span class=\"string\">'Bar'</span>,\n    fullName: <span class=\"string\">'Foo Bar'</span>\n  },\n  watch: {\n    firstName: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">val</span>) </span>{\n      <span class=\"keyword\">this</span>.fullName = val + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.lastName\n    },\n    lastName: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">val</span>) </span>{\n      <span class=\"keyword\">this</span>.fullName = <span class=\"keyword\">this</span>.firstName + <span class=\"string\">' '</span> + val\n    }\n  }\n})</span></pre>\n<p>El código anterior es imperativo y repetitivo. Compáralo con una versión de propiedad computada:</p>\n<pre><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#demo'</span>,\n  data: {\n    firstName: <span class=\"string\">'Foo'</span>,\n    lastName: <span class=\"string\">'Bar'</span>\n  },\n  computed: {\n    fullName: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstName + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.lastName\n    }\n  }\n})</span></pre>\n<p>Mucho mejor, ¿no?</p>\n<h3><span class=\"link\">Setter Computado</span></h3>\n<p>Las propiedades computadas son, de forma predeterminada solo get, pero también puede proporcionar un set cuando lo necesite:</p>\n<pre><span class=\"comment\">// ...</span>\ncomputed: {\n  fullName: {\n    <span class=\"comment\">// getter</span>\n    get: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstName + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.lastName\n    },\n    <span class=\"comment\">// setter</span>\n    set: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">newValue</span>) </span>{\n      <span class=\"keyword\">var</span> names = newValue.split(<span class=\"string\">' '</span>)\n      <span class=\"keyword\">this</span>.firstName = names[<span class=\"number\">0</span>]\n      <span class=\"keyword\">this</span>.lastName = names[names.length - <span class=\"number\">1</span>]\n    }\n  }\n}\n<span class=\"comment\">// ...</span></span></pre>\n<p>Ahora, cuando ejecute <code>vm.fullName = 'John Doe'</code>, se invocará el definidor y <code>vm.firstName</code> y <code>vm.lastName</code> se actualizarán en consecuencia.</p>\n<h2><span class=\"link\">Watchers</span></h2>\n<p>Si bien las propiedades computadas son más apropiadas en la mayoría de los casos, hay ocasiones en que es necesario un observador personalizado. Es por eso que Vue proporciona una forma más genérica de reaccionar a los cambios de datos a través de la opción <code>watch</code>. Esto es más útil cuando desea realizar operaciones asíncronas o costosas en respuesta al cambio de datos.</p>\n<p>por ejemplo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"watch-example\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>\n    Haz una pregunta de sí/no:\n    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"question\"</span>&gt;</span>\n  <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>{{ answer }}<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre>\nvar watchExampleVM = new Vue({\n  el: '#watch-example',\n  data: {\n    question: '',\n    answer: 'No puedo darte una respuesta hasta que hagas una pregunta!!'\n  },\n  watch: {\n    question: function (newQuestion, oldQuestion) {\n      this.answer = 'Esperando que deje de escribir......'\n      this.debouncedGetAnswer()\n    }\n  },\n  created: function () {\n    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)\n  },\n  methods: {\n    getAnswer:  function () {\n      if (this.question.indexOf('?') === -1) {\n        this.answer = 'Las preguntas suelen contener un signo de interrogación. ;-)'\n        return\n      }\n      this.answer = 'Pensando...'\n      var vm = this\n      axios.get('https://yesno.wtf/api')\n        .then(function (response) {\n          vm.answer = _.capitalize(response.data.answer)\n        })\n        .catch(function (error) {\n          vm.answer = '¡Error! No se pudo alcanzar la API. ' + error\n        })\n    }\n  }\n})\n</pre>\n  \n<p>En este caso, el uso de la opción <code>watch</code> nos permite realizar una operación asíncrona (acceder a una API), limita la frecuencia con la que realizamos esa operación y establece estados intermedios hasta que obtengamos una respuesta final. Nada de eso sería posible con una propiedad computada.</p>\n<p>Además de la opción <code>watch</code>, también puede usar el imperativo <span class=\"link\">vm.$Watch API</span>.</p>"
  },
  {
    "title": "Enlace Clases y Estilos",
    "contenido":  "<h1>Enlace Clases y Estilos</h1>\n<p>Una necesidad común de data binding es manipular la lista de clases de un elemento y sus estilos en línea. Como ambos son atributos, podemos usar <code>v-bind</code> para manejarlos: solo necesitamos crear una cadena de texto con nuestras expresiones. Sin embargo, concatenar cadenas de texto puede llegar a ser incómodo y propenso a errores. Por esta razón, Vue proporciona mejoras cuando se utiliza <code>v-bind</code> con<code>class</code> y <code>style</code>. Además de las cadenas de texto, las expresiones también pueden evaluar objetos o matrices.</p>\n<h2>Enlace de clases HTML</h2><h3>Sintaxis de Objeto</h3><p>Podemos pasar un objeto a <code>v-bind:class</code> para la asignación dinámica de clases:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"{ active: isActive }\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>La sintaxis de arriba tiene como resultado la clase <code>active</code> según el valor booleano(<span class=\"link\">https://developer.mozilla.org/en-US/docs/Glossary/Truthy</span>) de la propiedad <code>isActive</code>.</p>\n<p>Puede hacer multiple asignación de clases al tener más campos en el objeto. Además, la directiva <code>v-bind:class</code> también puede ser utilizada con el atributo <code>class</code>. De modo que con la siguiente plantilla:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"static\"</span></span>\n<span class=\"tag\">     <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"{ active: isActive, 'text-danger': hasError }\"</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Y el siguiente objeto <code>data</code>:</p>\n<pre>data: {\n  isActive: <span class=\"literal\">true</span>,\n  hasError: <span class=\"literal\">false</span>\n}</span></pre>\n<p>Se renderizará:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"static active\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Cuando <code>isActive</code> o <code>hasError</code> cambien, la lista de clases se actualizará consecuentemente. Por ejemplo, si <code>hasError</code> se convierte en <code>true</code>, la lista de clases se convertirá en <code>\"static active text-danger\"</code>.</p>\n<p>El objeto no tiene por qué estar en la misma línea:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"classObject\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre>data: {\n  classObject: {\n    active: <span class=\"literal\">true</span>,\n    <span class=\"string\">'text-danger'</span>: <span class=\"literal\">false</span>\n  }\n}</span></pre>\n<p>Esto renderizará el mismo resultado. También podemos enlazar una <span class=\"link\">propiedad computada</span> que retorna un objeto. Esto es un patrón común y poderoso:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"classObject\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre>data: {\n  isActive: <span class=\"literal\">true</span>,\n  error: <span class=\"literal\">null</span>\n},\ncomputed: {\n  classObject: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n    <span class=\"keyword\">return</span> {\n      active: <span class=\"keyword\">this</span>.isActive &amp;&amp; !<span class=\"keyword\">this</span>.error,\n      <span class=\"string\">'text-danger'</span>: <span class=\"keyword\">this</span>.error &amp;&amp; <span class=\"keyword\">this</span>.error.type === <span class=\"string\">'fatal'</span>\n    }\n  }\n}</span></pre>\n<h3>Sintaxis de Array</h3><p>Pasamos un array a <code>v-bind:class</code> para aplicar una lista de clases:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"[activeClass, errorClass]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre>data: {\n  activeClass: <span class=\"string\">'active'</span>,\n  errorClass: <span class=\"string\">'text-danger'</span>\n}</span></pre>\n<p>Que renderizará:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"active text-danger\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Si le gustaría activar una clase en la lista de manera condicional, usted puede hacerlo con una expresión ternaria:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"[isActive ? activeClass : '', errorClass]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Esto siempre aplicará <code>errorClass</code>, pero solo aplicará <code>activeClass</code> cuando <code>isActive</code> sea verdadero.</p>\n<p>Sin embargo, esto puede ser un poco verborrágico si usted tiene multiple clases condicionales. Por eso también es posible utilizar la sintaxis de objeto dentro de la sintaxis de colección:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"[{ active: isActive }, errorClass]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<h3>Con Componentes</h3><blockquote>\n<p>Esta sección asume que usted tiene conocimientos sobre <span class=\"link\">Componentes de Vue</span>. Siéntase libre de saltársela y volver más tarde.</p>\n</blockquote>\n<p>Cuando usa el atributo <code>class</code> en un componente personalizado, estas clases se agregarán al elemento raíz del componente. Las clases existentes en este elemento no serán sobreescritas.</p>\n<p>Por ejemplo, si declara este componente:</p>\n<pre>Vue.component(<span class=\"string\">'my-component'</span>, {\n  template: <span class=\"string\">'&lt;p class=\"foo bar\"&gt;Hi&lt;/p&gt;'</span>\n})</span></pre>\n<p>Y agrega algunas clases al usarlo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">class</span>=<span class=\"string\">\"baz boo\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span></pre>\n<p>El HTML renderizado será:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"foo bar baz boo\"</span>&gt;</span>Hi<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></pre>\n<p>Lo mismo aplica para el enlace de clases:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"{ active: isActive }\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span></pre>\n<p>Cuando <code>isActive</code> es verdadero, el HTML renderizado será:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"foo bar active\"</span>&gt;</span>Hi<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></pre>\n<h2>Enlace de estilos en línea</h2><h3>Sintaxis de Objeto</h3><p>La sintaxis de objeto para <code>v-bind:style</code> es muy sencilla - es similar a CSS, excepto que es un objeto JavaScript. Puede usar tanto camelCase como kebab-case (use comillas con kebab-case) para los nombres de propiedades CSS:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:style</span>=<span class=\"string\">\"{ color: activeColor, fontSize: fontSize + 'px' }\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre>data: {\n  activeColor: <span class=\"string\">'red'</span>,\n  fontSize: <span class=\"number\">30</span>\n}</span></pre>\n<p>A menudo es una buena idea enlazar directamente un objeto de estilo para que la plantilla sea más limpia:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:style</span>=<span class=\"string\">\"styleObject\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre>data: {\n  styleObject: {\n    color: <span class=\"string\">'red'</span>,\n    fontSize: <span class=\"string\">'13px'</span>\n  }\n}</span></pre>\n<p>Nuevamente, la sintaxis de objeto es a menudo usada en conjunción con propiedades computadas que retornan objetos.</p>\n<h3>Sintaxis de Array</h3><p>La sintaxis de array <code>v-bind:style</code> permite aplicar múltiples objetos de estilo al mismo elemento:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:style</span>=<span class=\"string\">\"[baseStyles, overridingStyles]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<h3>Auto-prefijado</h3><p>Cuando utilice una propiedad CSS que requiera <span class=\"link\">prefijos de proveedores</span> en <code>v-bind:style</code>, como por ejemplo <code>transform</code>, Vue detectará automaticamente y agregará los prefijos correspondientes a los estilos aplicados.</p>\n<h3>Valores múltiples</h3><blockquote>\n<p>2.3.0+</p>\n</blockquote>\n<p>Desde la versión 2.3.0+ usted puede proveer un array de valores múltiples (de prefijos) a una propiedad de estilo, por ejemplo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:style</span>=<span class=\"string\">\"{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Esto solo renderizará el ultimo valor en el array que el navegador soporte. En este ejemplo, se renderizará <code>display: flex</code> para los navegadores que soportan la versión sin prefijo de flexbox.</p>"
  },
  {
    "title": "Renderización Condicional",
    "contenido":  "<h1>Renderización Condicional</h1>\n<h2><code>v-if</code></h2><p>En los <em>string templates</em>, como por ejemplo, Handlebars, escribiríamos un bloque condicional como este:</p>\n<pre><span class=\"comment\">&lt;!-- template de Handlebars --&gt;</span>\n{{#if ok}}\n  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Sí<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span>\n{{/if}}</span></pre>\n<p>En Vue, usamos la directiva <code>v-if</code> para lograr lo mismo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"ok\"</span>&gt;</span>Sí<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></pre>\n<p>También es posible agregar un “bloque <em>else</em>“ con <code>v-else</code>:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"ok\"</span>&gt;</span>Sí<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">v-else</span>&gt;</span>No<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></pre>\n<h3>\" data-scroll=\"\">Grupos Condicionales con <code>v-if</code> en <code>&lt;template&gt;</code></h3><p>Debido a que <code>v-if</code> es una directiva, debe adjuntarse a un solo elemento. Pero, ¿y si queremos cambiar más de un elemento? En este caso, podemos usar <code>v-if</code> en un elemento<code>&lt;template&gt;</code>, que sirve como un envoltorio invisible. El resultado final procesado no incluirá el elemento <code>&lt;template&gt;</code>.</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"ok\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Título<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Párrafo 1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Párrafo 2<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span></pre>\n<h3><code>v-else</code></h3><p>Puede usar la directiva <code>v-else</code> para indicar un “bloque <em>else</em>“ para <code>v-if</code>:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"Math.random() &gt; 0.5\"</span>&gt;</span>\n  Ahora me ves\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else</span>&gt;</span>\n  Ahora no\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Un elemento <code>v-else</code> debe seguir inmediatamente a un elemento <code>v-if</code> o <code>v-else-if</code>, de lo contrario, no será reconocido.</p>\n<h3><code>v-else-if</code></h3><blockquote>\n<p>Nuevo en 2.1.0+</p>\n</blockquote>\n<p>El <code>v-else-if</code>, como su nombre lo indica, sirve como “bloque <em>else if</em>“ para <code>v-if</code>. También puede ser encadenado varias veces:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"type === 'A'\"</span>&gt;</span>\n  A\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else-if</span>=<span class=\"string\">\"type === 'B'\"</span>&gt;</span>\n  B\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else-if</span>=<span class=\"string\">\"type === 'C'\"</span>&gt;</span>\n  C\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else</span>&gt;</span>\n  Si no es A, B o C\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Similar a <code>v-else</code>, un elemento<code>v-else-if</code> debe seguir inmediatamente a un elemento <code>v-if</code> o <code>v-else-if</code>.</p>\n<h3>Controlando Elementos Reutilizables con <code>key</code></h3><p>Vue intenta representar los elementos de la manera más eficiente posible, a menudo reutilizándolos en lugar de renderizarlos desde cero. Más allá de ayudar a hacer Vue muy rápido, esto puede tener algunas ventajas útiles. Por ejemplo, si permite a los usuarios alternar entre varios tipos de inicio de sesión:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"loginType === 'username'\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>Nombre de Usuario<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Ingrese su nombre de usuario\"</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-else</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>Email<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Ingrese su email\"</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span></pre>\n<p>Luego, cambiando el <code>loginType</code> en el código anterior no borrará lo que el usuario ya ha ingresado. Dado que ambos <em>templates</em> utilizan los mismos elementos, el <code>&lt;input&gt;</code> no se reemplaza, solo su <code>placeholder</code>.</p>\n<p>Sin embargo, esto no siempre es deseable, por lo que Vue le ofrece una manera de decir: “Estos dos elementos están completamente separados, no los reutilice”. Agregue un atributo <code>key</code> con valores únicos:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"loginType === 'username'\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>Nombre de Usuario<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Ingrese su nombre de usuario\"</span> <span class=\"attr\">key</span>=<span class=\"string\">\"username-input\"</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-else</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>Email<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Ingrese su nombre de usuario\"</span> <span class=\"attr\">key</span>=<span class=\"string\">\"email-input\"</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span></pre>\n<p>Ahora estas entradas se procesarán desde cero cada vez que presione alternar. Ver por ti mismo:</p>\n<p>Observe que los elementos <code>&lt;label&gt;</code> son todavía reutilizables, porque no tienen atributos <code>key</code>.</p>\n<h2><code>v-show</code></h2><p>Otra opción para mostrar un elemento condicionalmente es la directiva <code>v-show</code>. La utlización es basicamente la mismo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">v-show</span>=<span class=\"string\">\"ok\"</span>&gt;</span>Hola!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></pre>\n<p>La diferencia es que un elemento con <code>v-show</code> siempre se renderizará y permanecerá en el DOM; <code>v-show</code> simplemente alterna la propiedad CSS <code>display</code> del elemento.</p>\n<p class=\"tip\">Observe que el uso de <code>v-show</code> no es compatible con elementos <code>&lt;template&gt;</code>, ni tampoco funciona con <code>v-else</code>.</p>\n<h2><code>v-if</code> vs <code>v-show</code></h2><p><code>v-if</code> es una renderización condicional “real” ya que garantiza que los eventos y componentes secundarios dentro del bloque condicional sean debidamente destruidos y recreados durante la alternancia.</p>\n<p><code>v-if</code> también es <strong>lazy</strong>: si la condición es falsa en la representación inicial, no se hará nada. El bloque condicional no se procesará hasta que la condición se convierta en true por primera vez.</p>\n<p>En comparación, <code>v-show</code> es mucho más simple: el elemento siempre se representa independientemente de la condición inicial, con alternancia basada en CSS.</p>\n<p>En general, <code>v-if</code> tiene costos de alternancia más altos, mientras que<code>v-show</code> tiene costos de renderización iniciales más altos. Por lo tanto, prefiera <code>v-show</code> si necesita cambiar algo muy a menudo, y prefiera<code>v-if</code> si es poco probable que la condición cambie en el tiempo de ejecución.</p>\n<h2><code>v-if</code> con <code>v-for</code></h2><p class=\"tip\">Usando <code>v-if</code> y <code>v-for</code> juntos <strong>no es recomendado</strong>. Vea la <span class=\"link\">guía de estilo</span> para mayor información.</p>\n<p>Cuando es utilizado junto con <code>v-for</code>, este tiene una prioridad más alta que <code>v-if</code>. Consulte la <span class=\"link\"> guía de renderización de listas </span> para obtener más información.</p>"
  },
  {
    "title": "Renderizado de lista",
    "contenido":  "<h1>Renderizado de lista</h1>\n<h2>Mapeando una matriz a elementos con <code>v-for</code></h2><p>Podemos usar la directiva <code>v-for</code> para representar una lista de elementos basada en una matriz. La directiva <code>v-for</code> requiere una sintaxis especial en forma de <code>item in items</code>, donde los <code>items</code> son la matriz de datos de origen y el <code>item</code> es un <strong>alias</strong> para el elemento de matriz que se está iterando:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-1\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span>&gt;</span>\n    {{ item.mensaje }}\n  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></pre>\n<pre><span class=\"keyword\">var</span> example1 = <span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#example-1'</span>,\n  data: {\n    items: [\n      { <span class=\"attr\">mensaje</span>: <span class=\"string\">'Foo'</span> },\n      { <span class=\"attr\">mensaje</span>: <span class=\"string\">'Bar'</span> }\n    ]\n  }\n})</span></pre>\n<p>Dentro de los bloques <code>v-for</code> tenemos acceso completo a las propiedades del ámbito principal. <code>v-for</code> también admite un segundo argumento opcional para el índice del elemento actual.</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-2\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(item, index) in items\"</span>&gt;</span>\n    {{ MensajePadre }} - {{ index }} - {{ item.mensaje }}\n  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></pre>\n<pre><span class=\"keyword\">var</span> example2 = <span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#example-2'</span>,\n  data: {\n    mensajePadre: <span class=\"string\">'Padre'</span>,\n    items: [\n      { <span class=\"attr\">mensaje</span>: <span class=\"string\">'Foo'</span> },\n      { <span class=\"attr\">mensaje</span>: <span class=\"string\">'Bar'</span> }\n    ]\n  }\n})</span></pre>\n<p>También puede usar <code>of</code> como delimitador en lugar de <code>in</code>, de modo que esté más cerca de la sintaxis de JavaScript para los iteradores:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item of items\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<h2><code>v-for</code> con un Objeto</h2><p>También puede usar <code>v-for</code> para iterar a través de las propiedades de un objeto.</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">\"v-for-object\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"demo\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"value in object\"</span>&gt;</span>\n    {{ value }}\n  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></pre>\n<pre><span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#v-for-object'</span>,\n  data: {\n    object: {\n      primerNombre: <span class=\"string\">'John'</span>,\n      apellido: <span class=\"string\">'Doe'</span>,\n      edad: <span class=\"number\">30</span>\n    }\n  }\n})</span></pre>\n<p>También puede proporcionar un segundo argumento para la clave:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(value, key) in object\"</span>&gt;</span>\n  {{ key }}: {{ value }}\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Y otro para el índice:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(value, key, index) in object\"</span>&gt;</span>\n  {{ index }}. {{ key }}: {{ value }}\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p class=\"tip\">Al iterar sobre un objeto, el orden se basa en el orden de enumeración de claves de <code>Object.keys()</code>, que no se garantiza que sea consistente en todas las implementaciones del motor de JavaScript.</p>\n<h2><code>key</code></h2><p>Cuando Vue está actualizando una lista de elementos representados con <code>v-for</code>, por defecto utiliza una estrategia de “parche in situ”. Si el orden de los elementos de datos ha cambiado, en lugar de mover los elementos DOM para que coincidan con el orden de los elementos, Vue aplicará parches a cada elemento en el lugar y se asegurará de que refleje lo que se debe representar en ese índice en particular. Esto es similar al comportamiento de <code>track-by=\"$index\"</code> en Vue 1.x.</p>\n<p>Este modo predeterminado es eficiente, pero solo es adecuado <strong>cuando la salida de renderizado de su lista no se basa en el estado del componente secundario o el estado temporal de DOM (por ejemplo, valores de entrada de formulario)</strong>.</p>\n<p>Para proporcionar a Vue una sugerencia para que pueda rastrear la identidad de cada nodo y, por lo tanto, reutilizar y reordenar los elementos existentes, debe proporcionar un atributo <code>key</code> único para cada elemento. Un valor ideal para <code>key</code> sería el ID único de cada elemento. Este atributo especial es un equivalente aproximado a <code>track-by</code> en 1.x, pero funciona como un atributo, por lo que necesita usar <code>v-bind</code> para enlazarlo con valores dinámicos (usando el modo abreviado aquí):</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">:key</span>=<span class=\"string\">\"item.id\"</span>&gt;</span>\n  <span class=\"comment\">&lt;!-- content --&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Se recomienda proporcionar una <code>key</code> con <code>v-for</code> siempre que sea posible, a menos que el contenido DOM iterado sea simple, o esté confiando intencionalmente en el comportamiento predeterminado para obtener ganancias en el rendimiento.</p>\n<p>Como Vue es un mecanismo genérico para identificar nodos, la <code>key</code> también tiene otros usos que no están específicamente vinculados a <code>v-for</code>, como veremos más adelante en la guía.</p>\n<h2>Detección de cambios en el Array</h2><h3>Métodos de Mutación</h3><p>Vue envuelve los métodos de mutación de una matriz observada para que también activen las actualizaciones de vista. Los métodos envueltos son:</p>\n<ul>\n  <li><code>push()</code></li>\n  <li><code>pop()</code></li>\n  <li><code>shift()</code></li>\n  <li><code>unshift()</code></li>\n  <li><code>splice()</code></li>\n  <li><code>sort()</code></li>\n  <li><code>reverse()</code></li>\n</ul>\n<p>Puede abrir la consola y probar con la matriz de <code>items</code> de los ejemplos anteriores llamando a sus métodos de mutación. Por ejemplo: <code>example1.items.push ({mensaje: 'Baz'})</code>.</p>\n<h3>Mutando un Array</h3><p>Los métodos de mutación, como sugiere su nombre, mutan la matriz original a la que se llama. En comparación, también hay métodos no mutantes, p. Ej. <code>filter()</code>, <code>concat()</code> y <code>slice()</code>, que no mutan la matriz original pero <strong>siempre devuelven una nueva matriz</strong>. Cuando trabaje con métodos no mutantes, puede reemplazar la matriz anterior por la nueva:</p>\n<pre>example1.items = example1.items.filter(<span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">item</span>) </span>{\n  <span class=\"keyword\">return</span> item.mensaje.match(<span class=\"regexp\">/Foo/</span>)\n})</span></pre>\n<p>Podría pensar que esto hará que Vue elimine el DOM existente y vuelva a renderizar la lista completa; afortunadamente, ese no es el caso. Vue implementa algunas heurísticas inteligentes para maximizar la reutilización de elementos DOM, por lo tanto, reemplazar una matriz con otra matriz que contenga objetos superpuestos es una operación muy eficiente.</p>\n<h3>Advertencias</h3><p>Debido a las limitaciones en JavaScript, Vue <strong>no puede</strong> detectar los siguientes cambios en una matriz:</p>\n<ol>\n  <li><p>Cuando configura directamente un elemento con el índice, por ejemplo, <code>vm.items[indexOfItem] = newValue</code></p>\n  </li>\n  <li><p>Cuando modifica la longitud de la matriz, por ejemplo, <code>vm.items.length = newLength</code></p>\n  </li>\n</ol>\n<p>Por ejemplo:</p>\n<pre><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue({\n  data: {\n    items: [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]\n  }\n})\nvm.items[<span class=\"number\">1</span>] = <span class=\"string\">'x'</span> <span class=\"comment\">// NO es reactivo</span>\nvm.items.length = <span class=\"number\">2</span> <span class=\"comment\">//  NO es reactivo</span></span></pre>\n<p>Para superar la advertencia 1, ambos de los siguientes lograrán lo mismo que <code>vm.items[indexOfItem] = newValue</code>, pero también activarán actualizaciones de estado en el sistema de reactividad:</p>\n<pre><span class=\"comment\">// Vue.set</span>\nVue.set(vm.items, indexOfItem, newValue)</span></pre>\n<pre><span class=\"comment\">// Array.prototype.splice</span>\nvm.items.splice(indexOfItem, <span class=\"number\">1</span>, newValue)</span></pre>\n<p>También puede usar el método de instancia <span class=\"link\"><code>vm.$Set</code></span>, que es un alias para el <code>Vue.set</code> global:</p>\n<pre>vm.$set(vm.items, indexOfItem, newValue)</span></pre>\n<p>Para tratar con la advertencia 2, puede usar <code>splice</code>:</p>\n<pre>vm.items.splice(newLength)</span></pre>\n<h2>Advertencias con la Detección de Cambios en Objetos</h2><p>Una vez más, debido a las limitaciones del JavaScript moderno, <strong>Vue no puede detectar la adición o eliminación de propiedades</strong>. Por ejemplo:</p>\n<pre><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue({\n  data: {\n    a: <span class=\"number\">1</span>\n  }\n})\n<span class=\"comment\">// `vm.a` ahora es reactivo</span>\n\nvm.b = <span class=\"number\">2</span>\n<span class=\"comment\">// `vm.b` NO es reactivo</span>\n/</span></pre>\n<p>Vue no permite agregar dinámicamente nuevas propiedades reactivas a nivel de raíz a una instancia ya creada. Sin embargo, es posible agregar propiedades reactivas a un objeto anidado usando el método <code>Vue.set (objeto, clave, valor)</code>. Por ejemplo, dado:</p>\n<pre><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue({\n  data: {\n    userProfile: {\n      name: <span class=\"string\">'Anika'</span>\n    }\n  }\n})</span></pre>\n<p>Podría agregar una nueva propiedad de <code>edad</code> al objeto de <code>userProfile</code> anidado con:</p>\n<pre>Vue.set(vm.userProfile, <span class=\"string\">'edad'</span>, <span class=\"number\">27</span>)</span></pre>\n<p>También puede usar el método de instancia vm. <code>$Set</code>, que es un alias para el <code>Vue.set</code> global:</p>\n<pre>vm.$set(vm.userProfile, <span class=\"string\">'edad'</span>, <span class=\"number\">27</span>)</span></pre>\n<p>En ocasiones, es posible que desee asignar varias propiedades nuevas a un objeto existente, por ejemplo, utilizando <code>Object.assign()</code> o <code>_.extend()</code>. En tales casos, debe crear un objeto nuevo con propiedades de ambos objetos. Así que en lugar de:</p>\n<pre><span class=\"built_in\">Object</span>.assign(vm.userProfile, {\n  edad: <span class=\"number\">27</span>,\n  favoriteColor: <span class=\"string\">'Vue Green'</span>\n})</span></pre>\n<p>Puedria agregar nuevas propiedades reactivas con:</p>\n<pre>vm.userProfile = <span class=\"built_in\">Object</span>.assign({}, vm.userProfile, {\n  edad: <span class=\"number\">27</span>,\n  favoriteColor: <span class=\"string\">'Vue Green'</span>\n})</span></pre>\n<h2>Mostrando Resultados Filtrados/Ordenados</h2><p>A veces, queremos mostrar una versión filtrada u ordenada de una matriz sin mutar o restablecer los datos originales. En este caso, puede crear una propiedad computada que devuelva la matriz filtrada u ordenada.</p>\n<p>Por ejemplo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"n in numerosImpares\"</span>&gt;</span>{{ n }}<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></pre>\n<pre>data: {\n  numeros: [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> ]\n},\ncomputed: {\n  numerosImpares: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.numeros.filter(<span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">numero</span>) </span>{\n      <span class=\"keyword\">return</span> numero % <span class=\"number\">2</span> === <span class=\"number\">0</span>\n    })\n  }\n}</span></pre>\n<p>En situaciones donde las propiedades computadas no son factibles (por ejemplo, dentro de los bucles <code>v-for</code> anidados), puede usar un método:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"n in even(numeros)\"</span>&gt;</span>{{ n }}<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></pre>\n<pre>data: {\n  numeros: [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> ]\n},\nmethods: {\n  even: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">numeros</span>) </span>{\n    <span class=\"keyword\">return</span> numeros.filter(<span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">numero</span>) </span>{\n      <span class=\"keyword\">return</span> numero % <span class=\"number\">2</span> === <span class=\"number\">0</span>\n    })\n  }\n}</span></pre>\n<h2><code>v-for</code> con un Rango</h2><p><code>v-for</code> también puede tomar un entero. En este caso repetirá la plantilla muchas veces.</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"n in 10\"</span>&gt;</span>{{ n }}<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<h2>\" data-scroll=\"\"><code>v-for</code> en un <code>&lt;template&gt;</code></h2><p>De forma similar a la plantilla <code>v-if</code>, también puede usar una etiqueta <code>&lt;template&gt;</code> con <code>v-for</code> para renderizar un bloque de varios elementos. Por ejemplo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>{{ item.msg }}<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">class</span>=<span class=\"string\">\"divider\"</span> <span class=\"attr\">role</span>=<span class=\"string\">\"presentation\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>\n  <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></pre>\n<h2><code>v-for</code> con <code>v-if</code></h2><p class=\"tip\">Tenga en cuenta que <strong>no se recomienda</strong> usar <code>v-if</code> y <code>v-for</code> juntos. Consulte la <span class=\"link\">guía de estilo</span> para más detalles.</p>\n<p>Cuando existen en el mismo nodo, <code>v-for</code> tiene una prioridad más alta que <code>v-if</code>. Eso significa que el <code>v-if</code> se ejecutará en cada iteración del bucle por separado. Esto puede ser útil cuando desea representar nodos solo para <em>algunos</em> elementos, como a continuación:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"todo in todos\"</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"!todo.isComplete\"</span>&gt;</span>\n  {{ todo }}\n<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></pre>\n<p>Lo anterior hace que los todos que no estén completos, se rendericen.</p>\n<p>Si, por el contrario, su intención es omitir condicionalmente la ejecución del bucle, puede colocar el <code>v-if</code> en un elemento de envoltura (o <span class=\"link\"><code>&lt;template&gt;</code></span>). Por ejemplo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"todos.length\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"todo in todos\"</span>&gt;</span>\n    {{ todo }}\n  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-else</span>&gt;</span>No quedan todos!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></pre>\n<h2><code>v-for</code> con un Componente</h2><blockquote>\n<p>Esta sección asume el conocimiento de <span class=\"link\">Componentes</span>. Siéntase libre de saltearlo y volver más tarde.</p>\n</blockquote>\n<p>Puede usar <code>v-for</code> directamente en un componente personalizado, como cualquier elemento normal:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">:key</span>=<span class=\"string\">\"item.id\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span></pre>\n<blockquote>\n  <p>En 2.2.0+, cuando se usa <code>v-for</code> con un componente, ahora se requiere una <span class=\"link\"><code>key</code></span>.</p>\n</blockquote>\n<p>Sin embargo, esto no pasará automáticamente ningún dato al componente, porque los componentes tienen sus propios ámbitos aislados. Para pasar los datos iterados al componente, también debemos usar props:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">my-component</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-for</span>=<span class=\"string\">\"(item, index) in items\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:item</span>=<span class=\"string\">\"item\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:index</span>=<span class=\"string\">\"index\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"item.id\"</span></span>\n<span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span></pre>\n<p>La razón para no inyectar automáticamente el <code>item</code> en el componente es porque hace que el componente esté estrechamente acoplado a cómo funciona <code>v-for</code>. Ser explícito acerca de dónde provienen sus datos hace que el componente sea reutilizable en otras situaciones.</p>\n<p>Aquí hay un ejemplo completo de una lista de tareas simple:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"todo-list-example\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">v-on:submit.prevent</span>=<span class=\"string\">\"addNewTodo\"</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"new-todo\"</span>&gt;</span>Agregar tarea<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">input</span></span>\n<span class=\"tag\">      <span class=\"attr\">v-model</span>=<span class=\"string\">\"newTodoText\"</span></span>\n<span class=\"tag\">      <span class=\"attr\">id</span>=<span class=\"string\">\"new-todo\"</span></span>\n<span class=\"tag\">      <span class=\"attr\">placeholder</span>=<span class=\"string\">\"E.g. Feed the cat\"</span></span>\n<span class=\"tag\">    &gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span>Agregar<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span>\n  <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">li</span></span>\n<span class=\"tag\">      <span class=\"attr\">is</span>=<span class=\"string\">\"todo-item\"</span></span>\n<span class=\"tag\">      <span class=\"attr\">v-for</span>=<span class=\"string\">\"(todo, index) in todos\"</span></span>\n<span class=\"tag\">      <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"todo.id\"</span></span>\n<span class=\"tag\">      <span class=\"attr\">v-bind:title</span>=<span class=\"string\">\"todo.title\"</span></span>\n<span class=\"tag\">      <span class=\"attr\">v-on:remove</span>=<span class=\"string\">\"todos.splice(index, 1)\"</span></span>\n<span class=\"tag\">    &gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>\n  <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p class=\"tip\">Note el atributo <code>is = \"todo-item\"</code>. Esto es necesario en las plantillas DOM, porque solo un elemento <code>&lt;li&gt;</code> es válido dentro de un <code>&lt;ul&gt;</code>. Hace lo mismo que <code>&lt;todo-item&gt;</code>, pero funciona alrededor de un error potencial de análisis del navegador. Ver las <span class=\"link\">advertencias de análisis de plantillas DOM</span> aprender más.</p>\n<pre>.component(<span class=\"string\">'todo-item'</span>, {\n  template: <span class=\"string\">'\\</span>\n<span class=\"string\">    &lt;li&gt;\\</span>\n<span class=\"string\">      {{ title }}\\</span>\n<span class=\"string\">      &lt;button -on:click=\"$emit(\\'remove\\')\"&gt;Remove&lt;/button&gt;\\</span>\n<span class=\"string\">    &lt;/li&gt;\\</span>\n<span class=\"string\">  '</span>,\n  props: [<span class=\"string\">'title'</span>]\n})\n\n<span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#todo-list-example'</span>,\n  data: {\n    newTodoText: <span class=\"string\">''</span>,\n    todos: [\n      {\n        id: <span class=\"number\">1</span>,\n        title: <span class=\"string\">'Do the dishes'</span>\n      },\n      {\n        id: <span class=\"number\">2</span>,\n        title: <span class=\"string\">'Take out the trash'</span>\n      },\n      {\n        id: <span class=\"number\">3</span>,\n        title: <span class=\"string\">'Mow the lawn'</span>\n      }\n    ],\n    nextTodoId: <span class=\"number\">4</span>\n  },\n  methods: {\n    addNewTodo: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n      <span class=\"keyword\">this</span>.todos.push({\n        id: <span class=\"keyword\">this</span>.nextTodoId++,\n        title: <span class=\"keyword\">this</span>.newTodoText\n      })\n      <span class=\"keyword\">this</span>.newTodoText = <span class=\"string\">''</span>\n    }\n  }\n})</span></pre>"
  },
  {
    "title": "Manejo de eventos",
    "contenido":  "<h1>Manejo de eventos</h1>\n<h2>Escuchar eventos</h2><p>Podemos usar la directiva <code>v-on</code> para escuchar eventos DOM y ejecutar algunos JavaScript cuando se activan.</p>\n<p>Por ejemplo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-1\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"counter += 1\"</span>&gt;</span>Add 1<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Se ha hecho clic en el botón de arriba {{ counter }} veces.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre><span class=\"keyword\">var</span> example1 = <span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#example-1'</span>,\n  data: {\n    counter: <span class=\"number\">0</span>\n  }\n})</span></pre>\n<h2>Métodos Manejadores de eventos</h2><p>Sin embargo, la lógica para muchos controladores de eventos será más compleja, por lo que no es posible mantener su JavaScript en el valor del atributo <code>v-on</code>. Es por eso que <code>v-on</code> también puede aceptar el nombre de un método al que te gustaría llamar.</p>\n<p>Por ejemplo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-2\"</span>&gt;</span>\n  <span class=\"comment\">&lt;!-- `saludar` es el nombre de un método definido a continuación --&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"saludar\"</span>&gt;</span>Saludar<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre><span class=\"keyword\">var</span> example2 = <span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#example-2'</span>,\n  data: {\n    name: <span class=\"string\">'Vue.js'</span>\n  },\n  <span class=\"comment\">// definir métodos bajo el objeto `methods`</span>\n  methods: {\n    saludar: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">event</span>) </span>{\n      <span class=\"comment\">// `this` dentro de los métodos apunta a la instancia de Vue</span>\n      alert(<span class=\"string\">'Hola '</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">'!'</span>)\n      <span class=\"comment\">// `evento` es el evento DOM nativo</span>\n      <span class=\"keyword\">if</span> (event) {\n        alert(event.target.tagName)\n      }\n    }\n  }\n})\n\n<span class=\"comment\">// también puedes invocar métodos en JavaScript.</span>\nexample2.greet() <span class=\"comment\">// =&gt; 'Hello Vue.js!'</span></span></pre>\n<h2>Métodos Manejadores en línea</h2><p>En lugar de enlazar directamente con un nombre de método, también podemos usar métodos en una declaración de JavaScript en línea:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-3\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"di('hola')\"</span>&gt;</span>Di hola<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"di('que')\"</span>&gt;</span>Di que<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre><span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#example-3'</span>,\n  methods: {\n    di: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">mensaje</span>) </span>{\n      alert(mensaje)\n    }\n  }\n})</span></pre>\n<p>A veces también necesitamos acceder al evento DOM original en un controlador de instrucciones en línea. Puedes pasarlo a un método usando la variable especial <code>$event</code>:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"Alertar('El Form no se puede enviar aun.', $event)\"</span>&gt;</span>\n  Enviar\n<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></pre>\n<pre><span class=\"comment\">// ...</span>\nmethods: {\n  Alertar: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">message, event</span>) </span>{\n    <span class=\"comment\">// ahora tenemos acceso al evento nativo.</span>\n    <span class=\"keyword\">if</span> (event) event.preventDefault()\n    alert(message)\n  }\n}</span></pre>\n<h2>Modificadores de eventos</h2><p>Es una necesidad muy común llamar a <code>event.preventDefault()</code> o <code>event.stopPropagation()</code> dentro de los controladores de eventos. Aunque podemos hacer esto fácilmente dentro de los métodos, sería mejor si los métodos fueran puramente sobre lógica de datos en lugar de tener que lidiar con los detalles del evento DOM.</p>\n<p>Para solucionar este problema, Vue proporciona <strong>modificadores de eventos</strong> para <code>v-on</code>. Recuerde que los modificadores son directivas postfijos marcados por un punto.</p>\n<ul>\n<li><code>.stop</code></li>\n<li><code>.prevent</code></li>\n<li><code>.capture</code></li>\n<li><code>.self</code></li>\n<li><code>.once</code></li>\n<li><code>.passive</code></li>\n</ul>\n<pre><span class=\"comment\">&lt;!-- Se detendrá la propagación del evento click. --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on:click.stop</span>=<span class=\"string\">\"hazEsto\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- El evento de enviar ya no volverá a cargar la página. --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">v-on:submit.prevent</span>=<span class=\"string\">\"onSubmit\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- Los modificadores pueden encadenarse --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on:click.stop.prevent</span>=<span class=\"string\">\"hazEsto\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- solo el modificador --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">v-on:submit.prevent</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- utilizar el modo de captura al agregar el detector de eventos --&gt;</span>\n<span class=\"comment\">&lt;!-- es decir, un evento dirigido a un elemento interno se maneja aquí antes de ser manejado por ese elemento --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-on:click.capture</span>=<span class=\"string\">\"hazEsto\"</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- solo activa el controlador si event.target es el elemento en sí --&gt;</span>\n<span class=\"comment\">&lt;!-- es decir, no de un elemento hijo --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-on:click.self</span>=<span class=\"string\">\"hazEso\"</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p class=\"tip\">El orden es importante cuando se usan modificadores porque el código relevante se genera en el mismo orden. Por lo tanto, el uso de <code>v-on: click.prevent.self</code> evitará <strong>todos los clics</strong> mientras que <code>v-on: click.self.prevent</code> solo evitará clics en el elemento en sí.</p>\n\n<blockquote>\n<p>Nuevo en 2.1.4+</p>\n</blockquote>\n<pre><span class=\"comment\">&lt;!-- El evento de clic se activará como máximo una vez. --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on:click.once</span>=<span class=\"string\">\"hazEsto\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></pre>\n<p>A diferencia de los otros modificadores, que son exclusivos de los eventos DOM nativos, el modificador <code>.once</code> también se puede usar en <span class=\"link\">eventos personalizados</span>. Si aún no ha leído sobre componentes, no se preocupe de esto por ahora.</p>\n<blockquote>\n<p>Nuevo in 2.3.0+</p>\n</blockquote>\n<p>Vue también ofrece el modificador <code>.passive</code>, correspondiente a <span class=\"link\">la opción <code>pasiva</code> de <code>addEventListener</code></span>.</p>\n<pre><span class=\"comment\">&lt;!-- El comportamiento predeterminado del evento scroll (scrolling) sucederá --&gt;</span>\n<span class=\"comment\">&lt;!-- inmediatamente, en lugar de esperar a que se complete `onScroll`  --&gt;</span>\n<span class=\"comment\">&lt;!-- en caso de que contenga `event.preventDefault ()`                --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-on:scroll.passive</span>=<span class=\"string\">\"onScroll\"</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>El modificador <code>.passive</code> es especialmente útil para mejorar el rendimiento en dispositivos móviles.</p>\n<p class=\"tip\">No use <code>.passive</code> y <code>.prevent</code> juntos, ya que <code>.prevent</code> se ignorará y su navegador probablemente le mostrará una advertencia. Recuerde, <code>.passive</code> comunica al navegador que no desea evitar el comportamiento predeterminado del evento.</p>\n\n<h2>Modificadores de Teclas</h2><p>Cuando escuchamos eventos de teclado, a menudo necesitamos verificar códigos de teclas comunes. Vue también permite agregar modificadores clave para <code>v-on</code> cuando se escuchan eventos de teclado:</p>\n<pre><span class=\"comment\">&lt;!-- solo llame a `vm.submit ()` cuando el `keyCode` es 13 --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-on:keyup.13</span>=<span class=\"string\">\"submit\"</span>&gt;</span></span></pre>\n<p>Recordar todos los <code>keyCodes</code> es un dolor de cabeza, por lo que Vue proporciona alias para las teclas más utilizadas:</p>\n<pre><span class=\"comment\">&lt;!-- lo mismo que arriba --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-on:keyup.enter</span>=<span class=\"string\">\"submit\"</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- También funciona como abreviacion. --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">input</span> @<span class=\"attr\">keyup.enter</span>=<span class=\"string\">\"submit\"</span>&gt;</span></span></pre>\n<p>Aqui esta la lista completa de alias:</p>\n<ul>\n<li><code>.enter</code></li>\n<li><code>.tab</code></li>\n<li><code>.delete</code> (captura ambas teclas “Delete” y “Backspace”)</li>\n<li><code>.esc</code></li>\n<li><code>.space</code></li>\n<li><code>.up</code></li>\n<li><code>.down</code></li>\n<li><code>.left</code></li>\n<li><code>.right</code></li>\n</ul>\n<p>También puede <span class=\"link\">definir alias modificadores de tecla personalizados</span> a través del objeto global <code>config.keyCodes</code>:</p>\n<pre><span class=\"comment\">// habilita `v-on:keyup.f1`</span>\nVue.config.keyCodes.f1 = <span class=\"number\">112</span></span></pre>\n<h3>Modificadores automáticos de teclas</h3><blockquote>\n<p>Nuevo in 2.5.0+</p>\n</blockquote>\n<p>También puede usar directamente cualquier nombre de tecla válido expuesto a través de <span class=\"link\"><code>KeyboardEvent.key</code></span> como modificadores convirtiéndolos a kebab-case:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">input</span> @<span class=\"attr\">keyup.page-down</span>=<span class=\"string\">\"onPageDown\"</span>&gt;</span></span></pre>\n<p>En el ejemplo anterior, solo se llamará al controlador si <code>$event.key === 'PageDown'</code></p>\n<p class=\"tip\">Algunas teclas (<code>.esc</code> y todas las teclas de flecha) tienen valores <code>key</code> incoherentes en IE9; se deben preferir sus alias integrados si necesita compatibilidad con IE9.</p>\n\n<h2>Modificador de Teclas del Sistema</h2><blockquote>\n<p>Nuevo en 2.1.0+</p>\n</blockquote>\n<p>Puede usar los siguientes modificadores para activar eventos listeners de raton o teclado solo cuando se presiona la tecla modificadora correspondiente:</p>\n<ul>\n<li><code>.ctrl</code></li>\n<li><code>.alt</code></li>\n<li><code>.shift</code></li>\n<li><code>.meta</code></li>\n</ul>\n<blockquote>\n<p>Nota: En los teclados de Macintosh, meta es la tecla de comando (⌘). En los teclados de Windows, meta es la tecla de Windows (). En los teclados de Sun Microsystems, el meta está marcado como un diamante sólido (◆). En ciertos teclados, específicamente los teclados y sucesores de máquinas MIT y Lisp, como el teclado Knight, el teclado space-cadet, el meta está etiquetado como “META”. En los teclados de Symbolics, el meta está etiquetado como “META” o “Meta”.</p>\n</blockquote>\n<p>Por ejemplo:</p>\n<pre><span class=\"comment\">&lt;!-- Alt + C --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">input</span> @<span class=\"attr\">keyup.alt.67</span>=<span class=\"string\">\"clear\"</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- Ctrl + Click --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">div</span> @<span class=\"attr\">click.ctrl</span>=<span class=\"string\">\"doSomething\"</span>&gt;</span>Do something<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p class=\"tip\">Tenga en cuenta que las teclas modificadoras son diferentes de las teclas normales y cuando se usan con eventos <code>keyup</code>, deben presionarse cuando se emite el evento. En otras palabras, <code>keyup.ctrl</code> solo se activará si sueltas una tecla mientras mantienes presionada la tecla <code>Ctrl</code>. No se activará si suelta la tecla <code>ctrl</code> solo. Si desea tal comportamiento, use el <code>código de tecla</code> para <code>ctrl</code> en su lugar: <code>keyup.17</code>.</p>\n\n<h3>Modificador <code>.exact</code></h3><blockquote>\n<p>Nuevo en 2.5.0+</p>\n</blockquote>\n<p>El modificador <code>.exact</code> permite el control de la combinación exacta de modificadores del sistema necesarios para desencadenar un evento.</p>\n<pre><span class=\"comment\">&lt;!-- esto se disparará incluso si se presiona Alt o Shift --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click.ctrl</span>=<span class=\"string\">\"onClick\"</span>&gt;</span>A<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- esto solo se activará cuando se presione Ctrl y no se presionen otras teclas --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click.ctrl.exact</span>=<span class=\"string\">\"onCtrlClick\"</span>&gt;</span>A<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- esto solo se activará cuando no se presionen modificadores del sistema --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click.exact</span>=<span class=\"string\">\"onClick\"</span>&gt;</span>A<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></pre>\n<h3>Modificador de Boton del Raton</h3><blockquote>\n<p>Nuevo en 2.2.0+</p>\n</blockquote>\n<ul>\n<li><code>.left</code></li>\n<li><code>.right</code></li>\n<li><code>.middle</code></li>\n</ul>\n<p>Estos modificadores restringen el controlador a eventos activados por un botón específico del raton.</p>\n<h2>¿Por qué Listeners en HTML?</h2><p>Es posible que le preocupe que todo este enfoque de escucha de eventos viole las viejas buenas reglas sobre la “separation of concerns” (“separación de preocupaciones”). Tenga la tranquilidad de que todas las funciones y expresiones del controlador de Vue están estrictamente vinculadas a ViewModel que esta manejando la vista actual, no causará ninguna dificultad de mantenimiento. De hecho, hay varios beneficios en el uso de <code>v-on</code>:</p>\n<ol>\n<li><p>Es más fácil ubicar las implementaciones de la función de controlador dentro de su código JS al ojear la plantilla HTML.</p>\n</li>\n<li><p>Una vez que no tenga que adjuntar manualmente eventos listeners en JS, su código de ViewModel puede ser de lógica pura y libre de DOM. Esto hace que sea más fácil de probar.</p>\n</li>\n<li><p>Cuando se destruye un ViewModel, todos los eventos listeners se eliminan automáticamente. No tiene que preocuparse por limpiarlo usted mismo.</p>\n</li>\n</ol>"
  },
  {
    "title": "Binding en Formularios",
    "contenido":  "<h1>Binding en Formularios</h1>\n<h2>Uso básico</h2><p>Puede usar la directiva <code>v-model</code> para crear <em>bindings</em> de datos bidireccionales (<em>two-way binding</em>) en elementos <em>input</em>, <em>textarea</em> y <em>select</em> de un formulario. La directiva busca automáticamente la manera correcta de actualizar el elemento según el tipo de entrada. Aunque un poco mágico, <code>v-model</code> es esencialmente <em>syntax sugar</em> para actualización de datos a través de eventos de entradas del usuario, además de mostrar un cuidado especial para algunos casos de borde.</p>\n<p class=\"tip\"><code>v-model</code> ignorará el <code>value</code> inicial, los atributos <code>checked</code> o <code>selected</code> que se encuentran en cualquier elemento de formulario. Siempre tratará los datos de la instancia de Vue como la fuente confiable. Debe declarar el valor inicial del lado de JavaScript, dentro de la opción <code>data</code> de su componente.</p>\n<p class=\"tip\" id=\"vmodel-ime-tip\">Para los idiomas que requieren un <span class=\"link\">IME</span> (chino, japonés, coreano, etc.), notará que el <code>v-model</code> no se actualiza durante la composición del IME. Si también desea atender estas actualizaciones, use un evento <code>input</code> en su lugar.</p>\n<h3>Input</h3><pre><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"message\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"edíteme\"</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>El mensaje es: {{ message }}<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></pre>\n<h3>Textarea</h3><pre><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>El mensaje multilínea es:<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">style</span>=<span class=\"string\">\"white-space: pre-line;\"</span>&gt;</span>{{ message }}<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"message\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"agregar múltiples líneas\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></span></pre>\n<p class=\"tip\">La interpolación en textareas no funciona (<code>&lt;textarea&gt;{{text}}&lt;/textarea&gt;</code>). En su lugar use <code>v-model</code>.</p>\n<h3>Checkbox</h3><p><em>Checkbox</em> simples con valor booleano:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"checked\"</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"checkbox\"</span>&gt;</span>{{ checked }}<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span></pre>\n<p>Múltiples checkboxes vinculados al mismo Array:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">'example-3'</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"jack\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Jack\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"checkedNames\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"jack\"</span>&gt;</span>Jack<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"john\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"John\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"checkedNames\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"john\"</span>&gt;</span>John<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mike\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Mike\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"checkedNames\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"mike\"</span>&gt;</span>Mike<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Checked names: {{ checkedNames }}<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre><span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#example-3'</span>,\n  data: {\n    checkedNames: []\n  }\n})</span></pre>\n<h3>Select</h3><p>Selección de un solo elemento:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"selected\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">disabled</span> <span class=\"attr\">value</span>=<span class=\"string\">\"\"</span>&gt;</span>Seleccione un elemento<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>A<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>B<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>C<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Seleccionado: {{ selected }}<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></pre>\n<pre><span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'...'</span>,\n  data: {\n    selected: <span class=\"string\">''</span>\n  }\n})</span></pre>\n<p>Opciones dinámicas renderizadas con <code>v-for</code>:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"selected\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"option in options\"</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"option.value\"</span>&gt;</span>\n    {{ option.text }}\n  <span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Seleccionado: {{ selected }}<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></pre>\n<pre><span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'...'</span>,\n  data: {\n    selected: <span class=\"string\">'A'</span>,\n    options: [\n      { <span class=\"attr\">text</span>: <span class=\"string\">'Uno'</span>, <span class=\"attr\">value</span>: <span class=\"string\">'A'</span> },\n      { <span class=\"attr\">text</span>: <span class=\"string\">'Dos'</span>, <span class=\"attr\">value</span>: <span class=\"string\">'B'</span> },\n      { <span class=\"attr\">text</span>: <span class=\"string\">'Tres'</span>, <span class=\"attr\">value</span>: <span class=\"string\">'C'</span> }\n    ]\n  }\n})</span></pre>\n<h2>Vinculando a Valores</h2><p>Para <em>radio</em>, <em>checkbox</em> y <em>option</em> de <em>select</em>, los valores de vinculación del <code>v-model</code> suelen ser cadenas estáticas (o booleanos para <em>checkbox</em>):</p>\n<pre><span class=\"comment\">&lt;!-- `picked` es una cadena \"a\" cuando está chequeado --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"picked\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"a\"</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- `toggle` es verdadero o falso --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"toggle\"</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- `selected` es una cadena \"abc\" cuando se selecciona la primera opción --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"selected\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"abc\"</span>&gt;</span>ABC<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span></pre>\n<p>Pero a veces es posible que queramos vincular el valor a una propiedad dinámica en la instancia de Vue. Podemos usar <code>v-bind</code> para lograr eso. Además, el uso de <code>v-bind</code> nos permite vincular el valor de entrada a valores no cadena.</p>\n<h3>Checkbox</h3><pre><span class=\"tag\">&lt;<span class=\"name\">input</span></span>\n<span class=\"tag\">  <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-model</span>=<span class=\"string\">\"toggle\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">true-value</span>=<span class=\"string\">\"yes\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">false-value</span>=<span class=\"string\">\"no\"</span></span>\n<span class=\"tag\">&gt;</span></span></pre>\n<pre><span class=\"comment\">// cuando está marcado:</span>\nvm.toggle === <span class=\"string\">'yes'</span>\n<span class=\"comment\">// cuando está desmarcado:</span>\nvm.toggle === <span class=\"string\">'no'</span></span></pre>\n<p class=\"tip\">Los atributos de <code>true-value</code> y de <code>false-value</code> no afectan la entrada del atributo <code>value</code>, ya que los navegadores no incluyen casillas sin marcar en los envíos de formularios. Para garantizar que uno de los dos valores se envie en un formulario (por ejemplo, “yes” o “no”), use entradas de radio en su lugar.\n</p>\n<h3>Radio</h3><pre><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"pick\"</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"a\"</span>&gt;</span></span></pre>\n<pre><span class=\"comment\">// cuando está marcado:</span>\nvm.pick === vm.a</span></pre>\n<h3>Select</h3><pre><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"selected\"</span>&gt;</span>\n  <span class=\"comment\">&lt;!--  objeto literal en línea --&gt;</span> --&gt;\n  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"{ number: 123 }\"</span>&gt;</span>123<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span></pre>\n<pre><span class=\"comment\">// cuando está seleccionado:</span>\n<span class=\"keyword\">typeof</span> vm.selected <span class=\"comment\">// =&gt; 'object'</span>\nvm.selected.number <span class=\"comment\">// =&gt; 123</span></span></pre>\n<h2>Modificadores</h2><h3><code>.lazy</code></h3><p>De forma predeterminada, <code>v-model</code> sincroniza el <code>input</code> con los datos después de cada evento de tipo <code>input</code> (con la excepción de la composición IME <span class=\"link\">descrito anteriormente</span>). En lugar de esto, puede agregar el modificador <code>lazy</code> para realizar la sincronización después del evento <code>change</code>:</p>\n<pre><span class=\"comment\">&lt;!-- sincronizado después de \"change\" en lugar de \"input\" --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model.lazy</span>=<span class=\"string\">\"msg\"</span> &gt;</span></span></pre>\n<h3><code>.number</code></h3><p>Si desea que las entradas del usuario se escriban automáticamente como un número, puede agregar el modificador <code>number</code> al <code>v-model</code> del elemento:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model.number</span>=<span class=\"string\">\"age\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"number\"</span>&gt;</span></span></pre>\n<p>Esto suele ser útil, porque incluso con <code>type=\"number\"</code>, el valor retornado por el elemento HTML siempre es una cadena de texto. Si el valor no se puede analizar con <code>parseFloat()</code>, se retorna el valor original.</p>\n<h3><code>.trim</code></h3><p>Si desea que las entradas del usuario se recorten automáticamente, puede agregar el modificador <code>trim</code> al <code>v-model</code> de su elemento:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model.trim</span>=<span class=\"string\">\"msg\"</span>&gt;</span></span></pre>\n<h2><code>v-model</code> con Componentes</h2><blockquote>\n<p>Si aún no está familiarizado con los componentes de Vue, puede omitir esto por ahora.</p>\n</blockquote>\n<p>Los tipos de <em>input</em> nativos de HTML no siempre satisfarán sus necesidades. Afortunadamente, los componentes de Vue le permiten crear <em>input</em> reutilizables con un comportamiento completamente personalizado. Estos componentes también funcionan con <code>v-model</code>! Para aprender más, lea acerca de <span class=\"link\">inputs personalizados</span> en la guía de componentes.</p>"
  },
  {
    "title": "Conceptos Básicos de Componentes",
    "contenido":  "<h1>Conceptos Básicos de Componentes</h1>\n<h2>Ejemplo base</h2><p>Aquí un ejemplo de un componente Vue:</p>\n<pre><span class=\"comment\">// Definir un nuevo componente llamado button-counter</span>\nVue.component(<span class=\"string\">'button-counter'</span>, {\n  data: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n    <span class=\"keyword\">return</span> {\n      count: <span class=\"number\">0</span>\n    }\n  },\n  template: <span class=\"string\">'&lt;button v-on:click=\"count++\"&gt;Me ha pulsado {{ count }} veces.&lt;/button&gt;'</span>\n})</span></pre>\n<p>Los componentes son instancias reutilizables de Vue con un nombre: en este caso, <code>&lt;button-counter&gt;</code>. Podemos usar este componente como un elemento personalizado dentro de una instancia de Vue raíz creada con <code>new Vue</code>:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"components-demo\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">button-counter</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button-counter</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre><span class=\"keyword\">new</span> Vue({ <span class=\"attr\">el</span>: <span class=\"string\">'#components-demo'</span> })</span></pre>\n<p>Tenga en cuenta que al hacer clic en los botones, cada uno mantiene su propio <code>count</code> por separado. Esto se debe a que cada vez que utiliza un componente, se crea una nueva <strong>instancia</strong> del mismo.</p>\n<h3><code>data</code> Debe ser una función</h3><p>Cuando definimos el componente <code>&lt;button-counter&gt;</code>, es posible que haya notado que <code>data</code> no devuelve directamente un objeto, como este:</p>\n<pre>data: {\n  count: <span class=\"number\">0</span>\n}</span></pre>\n<p>En lugar de eso, <strong>la opción <code>data</code> de un componente debe ser una función</strong>, de modo que cada instancia pueda mantener una copia independiente del objeto de datos devuelto:</p>\n<pre>data: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n  <span class=\"keyword\">return</span> {\n    count: <span class=\"number\">0</span>\n  }\n}</span></pre>\n<p>Si Vue no tuviera esta regla, hacer clic en un botón afectaría los datos de <em>todas las demás instancias</em>, como a continuación:</p>\n<h2>Organización de Componentes</h2><p>Es común que una aplicación se organice en un árbol de componentes anidados:</p>\n<p><img src=\"/images/components.png\" alt=\"Component Tree\"></p>\n<p>Por ejemplo, puede tener componentes para un encabezado, una barra lateral y un área de contenido, cada uno de los cuales generalmente contiene otros componentes para enlaces de navegación, publicaciones de blog, etc.</p>\n<p>Para usar estos componentes en <em>templates</em>, deben registrarse para que Vue los conozca. Existen dos tipos de registro de componentes: <strong>global</strong> y <strong>local</strong>. Hasta ahora, solo hemos registrado componentes globalmente, usando <code>Vue.component</code>:</p>\n<pre>Vue.component(<span class=\"string\">'my-component-name'</span>, {\n  <span class=\"comment\">// ... opciones ...</span>\n})</span></pre>\n<p>Los componentes registrados globalmente se pueden usar en el <em>template</em> de cualquier instancia de Vue raíz (<code>new Vue</code>) creada posteriormente, e incluso dentro de todos los subcomponentes del árbol de componentes de esa instancia de Vue.</p>\n<p>Eso es todo lo que necesita saber sobre el registro por ahora, pero una vez que haya terminado de leer esta página y se sienta cómodo con su contenido, le recomendamos volver más tarde para leer la guía completa de <span class=\"link\">Registro de Componentes</span>.</p>\n<h2>Pasando datos a componentes secundarios con Props</h2><p>Anteriormente, mencionamos la creación de un componente para publicaciones de blog. El problema es que ese componente no será útil a menos que puedas pasarle datos, como el título y el contenido de la publicación específica que queremos mostrar. Ahí es donde entran las <strong>props</strong>.</p>\n<p>Las <strong>props</strong> son atributos personalizados que usted puede registrar en un componente. Cuando se pasa un valor a un atributo <strong>prop</strong>, se convierte en una propiedad en esa instancia de componente. Para pasar un título a nuestro componente de publicación de blog, podemos incluirlo en la lista de <strong>props</strong> que este componente acepta, usando la opción <code>props</code>:</p>\n<pre>Vue.component(<span class=\"string\">'blog-post'</span>, {\n  props: [<span class=\"string\">'title'</span>],\n  template: <span class=\"string\">'&lt;h3&gt;{{ title }}&lt;/h3&gt;'</span>\n})</span></pre>\n<p>Un componente puede tener tantas props como se desee, y se puede pasar cualquier valor a cualquier prop de forma predeterminada. En el <em>template</em> anterior, verá que podemos acceder a este valor en la instancia del componente, al igual que con <code>data</code>.</p>\n<p>Una vez que se registra un prop, puede pasarle datos como un atributo personalizado, de la siguiente manera:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">blog-post</span> <span class=\"attr\">title</span>=<span class=\"string\">\"Mi viaje con Vue\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">blog-post</span> <span class=\"attr\">title</span>=<span class=\"string\">\"Blogging con Vue\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">blog-post</span> <span class=\"attr\">title</span>=<span class=\"string\">\"Por qué Vue es tan divertido?\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span></span></pre>\n<p>En una aplicación típica, sin embargo, es probable que tenga un <em>array</em> de <em>post</em> en <code>data</code>:</p>\n<pre><span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#blog-post-demo'</span>,\n  data: {\n    posts: [\n      { <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Mi viaje con Vue'</span> },\n      { <span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Blogging con Vue'</span> },\n      { <span class=\"attr\">id</span>: <span class=\"number\">3</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Por qué Vue es tan divertido?'</span> }\n    ]\n  }\n})</span></pre>\n<p>Entonces querrá renderizar un componente para cada uno:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">blog-post</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-for</span>=<span class=\"string\">\"post in posts\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"post.id\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:title</span>=<span class=\"string\">\"post.title\"</span></span>\n<span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span></span></pre>\n<p>Arriba, verá que podemos usar <code>v-bind</code> para pasar <em>propiedades</em> dinámicamente. Esto es especialmente útil cuando no se conoce el contenido exacto que se va a renderizar con anticipación, como cuando <span class=\"link\">se obtienen posts de una API</span>.</p>\n<p>Esto es todo lo que necesita saber sobre <em>propiedades</em> por ahora, pero una vez que haya terminado de leer esta página y se sienta cómodo con su contenido, le recomendamos volver más tarde para leer la guía completa de <span class=\"link\">Propiedades</span>.</p>\n<h2>Un elemento de una sola raíz</h2><p>Al crear un componente <code>&lt;blog-post&gt;</code>, su <em>plantilla</em> eventualmente no contendrá más que solo el título:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>{{ title }}<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span></pre>\n<p>Como mínimo, querrá incluir el contenido del post:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>{{ title }}<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-html</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Sin embargo, si intenta esto en su plantilla, Vue mostrará un error, explicando que <strong>cada componente debe tener un solo elemento raíz</strong>. Puede corregir este error envolviendo la <em>plantilla</em> en un elemento principal de la siguiente manera:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"blog-post\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>{{ title }}<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-html</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>A medida que nuestro componente crezca, es probable que no solo necesitemos el título y el contenido de una publicación, sino también la fecha de publicación, los comentarios y más. Definir una <em>propiedad</em> para cada pieza de información relacionada podría volverse muy molesto:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">blog-post</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-for</span>=<span class=\"string\">\"post in posts\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"post.id\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:title</span>=<span class=\"string\">\"post.title\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:content</span>=<span class=\"string\">\"post.content\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:publishedAt</span>=<span class=\"string\">\"post.publishedAt\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:comments</span>=<span class=\"string\">\"post.comments\"</span></span>\n<span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span></span></pre>\n<p>Por lo tanto, este podría ser un buen momento para refactorizar el componente <code>&lt;blog-post&gt;</code> para que acepte una única <code>propiedad</code> post:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">blog-post</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-for</span>=<span class=\"string\">\"post in posts\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"post.id\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:post</span>=<span class=\"string\">\"post\"</span></span>\n<span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span></span></pre>\n<pre>Vue.component(<span class=\"string\">'blog-post'</span>, {\n  props: [<span class=\"string\">'post'</span>],\n  template: <span class=\"string\">`</span>\n<span class=\"string\">    &lt;div class=\"blog-post\"&gt;</span>\n<span class=\"string\">      &lt;h3&gt;{{ post.title }}&lt;/h3&gt;</span>\n<span class=\"string\">      &lt;div v-html=\"post.content\"&gt;&lt;/div&gt;</span>\n<span class=\"string\">    &lt;/div&gt;</span>\n<span class=\"string\">  `</span>\n})</span></pre>\n<p></p><p class=\"tip\">El ejemplo anterior y algunos que veremos más adelante, utilizan <span class=\"link\"><em>Plantillas de cadena de texto</em></span> de JavaScript para hacer que las <em>plantillas</em> multilínea sean más legibles. Internet Explorer (IE) no las admite, por lo tanto, si debe ser compatible con IE y no está transpilando (por ejemplo, con Babel o TypeScript), usa <span class=\"link\">escapes de nueva línea</span> en su lugar</p>.<p></p>\n<p>Ahora, cada vez que se agreguen nuevas propiedadaes al objeto <code>post</code>, estarán automáticamente disponible dentro de <code>&lt;blog-post&gt;</code>.</p>\n<h2>Enviando mensajes a componentes padre con eventos</h2><p>A medida que desarrollamos nuestro componente <code>&lt;blog-post&gt;</code>, es posible que algunas funciones requieran la comunicación hacia el componente padre. Por ejemplo, podemos decidir incluir una función de accesibilidad para ampliar el texto de las publicaciones del blog, dejando el resto de la página en su tamaño por defecto:</p>\n<p>En el padre, podemos admitir esta función agregando una propiedad <code>postFontSize</code> en <code>data</code>:</p>\n<pre><span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#blog-posts-events-demo'</span>,\n  data: {\n    posts: [<span class=\"comment\">/* ... */</span>],\n    postFontSize: <span class=\"number\">1</span>\n  }\n})</span></pre>\n<p>Esta propiedad puede ser usada en la <em>plantilla</em> para controlar el tamaño de la fuente de todas las publicaciones del blog:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"blog-posts-events-demo\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">:style</span>=<span class=\"string\">\"{ fontSize: postFontSize + 'em' }\"</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">blog-post</span></span>\n<span class=\"tag\">      <span class=\"attr\">v-for</span>=<span class=\"string\">\"post in posts\"</span></span>\n<span class=\"tag\">      <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"post.id\"</span></span>\n<span class=\"tag\">      <span class=\"attr\">v-bind:post</span>=<span class=\"string\">\"post\"</span></span>\n<span class=\"tag\">    &gt;</span><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span>\n  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Ahora agreguemos un botón para ampliar el texto justo antes del contenido de cada publicación:</p>\n<pre>Vue.component(<span class=\"string\">'blog-post'</span>, {\n  props: [<span class=\"string\">'post'</span>],\n  template: <span class=\"string\">`</span>\n<span class=\"string\">    &lt;div class=\"blog-post\"&gt;</span>\n<span class=\"string\">      &lt;h3&gt;{{ post.title }}&lt;/h3&gt;</span>\n<span class=\"string\">      &lt;button&gt;</span>\n<span class=\"string\">        Agrandar texto</span>\n<span class=\"string\">      &lt;/button&gt;</span>\n<span class=\"string\">      &lt;div v-html=\"post.content\"&gt;&lt;/div&gt;</span>\n<span class=\"string\">    &lt;/div&gt;</span>\n<span class=\"string\">  `</span>\n})</span></pre>\n<p>El problema es que este botón no hace nada:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span>\n  Agrandar texto\n<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></pre>\n<p>Cuando hacemos clic en el botón, debemos comunicar al componente padre que debe agrandar el texto de todas las publicaciones. Afortunadamente, las instancias de Vue proporcionan un sistema de eventos personalizados para resolver este problema. Para emitir un evento a los padres, podemos llamar al método <span class=\"link\"><strong><code>$emit</code></strong></span>, pasando el nombre del evento:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"$emit('enlarge-text')\"</span>&gt;</span>\n  Agrandar texto\n<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></pre>\n<p>Luego, en nuestro blog post, podemos escuchar este evento con <code>v-on</code>, tal como lo haríamos con un evento DOM nativo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">blog-post</span></span>\n<span class=\"tag\">  <span class=\"attr\">...</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-on:enlarge-text</span>=<span class=\"string\">\"postFontSize += 0.1\"</span></span>\n<span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span></span></pre>\n<h3>Emitiendo un valor con un Evento</h3><p>A veces es útil emitir un valor específico con un evento. Por ejemplo, podemos querer que el componente <code>&lt;blog-post&gt;</code> se encargue de cuánto agrandar el texto. En esos casos, podemos usar el segundo parámetro de <code>$emit</code> para proporcionar este valor:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"$emit('enlarge-text', 0.1)\"</span>&gt;</span>\n  Agrandar texto\n<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></pre>\n<p>Luego, cuando escuchamos el evento en el componente padre, podemos acceder al valor del evento emitido con <code>$event</code>:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">blog-post</span></span>\n<span class=\"tag\">  <span class=\"attr\">...</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-on:enlarge-text</span>=<span class=\"string\">\"postFontSize += $event\"</span></span>\n<span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span></span></pre>\n<p>O, si el controlador de eventos es un método:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">blog-post</span></span>\n<span class=\"tag\">  <span class=\"attr\">...</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-on:enlarge-text</span>=<span class=\"string\">\"onEnlargeText\"</span></span>\n<span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span></span></pre>\n<p>Entonces el valor se pasará como el primer parámetro de ese método:</p>\n<pre>methods: {\n  onEnlargeText: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">enlargeAmount</span>) </span>{\n    <span class=\"keyword\">this</span>.postFontSize += enlargeAmount\n  }\n}</span></pre>\n<h3>Usando <code>v-model</code> en Componentes</h3><p>Los eventos personalizados también se pueden usar para crear <em>inputs</em> personalizados qu</h3> </h3>e funcionan con <code>v-model</code>. Recuerde que:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"searchText\"</span>&gt;</span></span></pre>\n<p>hace lo mismo que:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">input</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"searchText\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-on:input</span>=<span class=\"string\">\"searchText = $event.target.value\"</span></span>\n<span class=\"tag\">&gt;</span></span></pre>\n<p>Cuando se usa en un componente, <code>v-model</code> en su lugar hace esto:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">custom-input</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"searchText\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-on:input</span>=<span class=\"string\">\"searchText = $event\"</span></span>\n<span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">custom-input</span>&gt;</span></span></pre>\n<p>Para que esto realmente funcione, el <code>&lt;input&gt;</code> dentro del componente debe:</p>\n<ul>\n<li>Enlazar el atributo <code>value</code> a una propiedad <code>value</code></li>\n<li>En el <code>input</code>, emitir su propio evento <code>input</code> personalizado con el nuevo valor</li>\n</ul>\n<p>Aquí está en acción:</p>\n<pre>Vue.component(<span class=\"string\">'custom-input'</span>, {\n  props: [<span class=\"string\">'value'</span>],\n  template: <span class=\"string\">`</span>\n<span class=\"string\">    &lt;input</span>\n<span class=\"string\">      v-bind:value=\"value\"</span>\n<span class=\"string\">      v-on:input=\"$emit('input', $event.target.value)\"</span>\n<span class=\"string\">    &gt;</span>\n<span class=\"string\">  `</span>\n})</span></pre>\n<p>Ahora <code>v-model</code> debería funcionar perfectamente con este componente:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">custom-input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"searchText\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">custom-input</span>&gt;</span></span></pre>\n<p>Por ahora, eso es todo lo que necesita saber sobre los eventos de componentes personalizados, pero una vez que haya terminado de leer esta página y se sienta cómodo con su contenido, le recomendamos volver más tarde para leer la guía completa sobre <span class=\"link\">Eventos Personalizados</span>.</p>\n<h2>Distribución de contenido con Slots</h2><p>Al igual que con los elementos HTML, a menudo es útil poder pasar contenido a un componente, como este:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">alert-box</span>&gt;</span>\n  Algo ha ocurrido mal.\n<span class=\"tag\">&lt;/<span class=\"name\">alert-box</span>&gt;</span></span></pre>\n<p>Afortunadamente, esta tarea se hace muy simple con el elemento personalizado <code>&lt;slot&gt;</code> de Vue:</p>\n<pre>Vue.component(<span class=\"string\">'alert-box'</span>, {\n  template: <span class=\"string\">`</span>\n<span class=\"string\">    &lt;div class=\"demo-alert-box\"&gt;</span>\n<span class=\"string\">      &lt;strong&gt;Error!&lt;/strong&gt;</span>\n<span class=\"string\">      &lt;slot&gt;&lt;/slot&gt;</span>\n<span class=\"string\">    &lt;/div&gt;</span>\n<span class=\"string\">  `</span>\n})</span></pre>\n<p>Como verá más arriba, solo agregamos la ranura a la que queremos que el contenido vaya – y eso es todo. Hemos terminado!</p>\n<p>Eso es todo lo que necesita saber acerca de slots por ahora, pero una vez que haya terminado de leer esta página y se sienta cómodo con su contenido, le recomendamos que regrese más tarde para leer la guía completa de <span class=\"link\">Slots</span>.</p>\n<h2>Componentes dinámicos</h2><p>A veces, es útil cambiar dinámicamente entre componentes, como en una interfaz con pestañas:</p>\n<p>Lo anterior es posible gracias al elemento <code>&lt;component&gt;</code> de Vue con el atributo especial <code>is</code>:</p>\n<pre><span class=\"comment\">&lt;!-- El componente cambia cuando currentTabComponent cambia --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">v-bind:is</span>=<span class=\"string\">\"currentTabComponent\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></span></pre>\n<p>En el ejemplo anterior, <code>currentTabComponent</code> puede contener:</p>\n<ul>\n<li>el nombre de un componente registrado, o</li>\n<li>un objeto de opciones de un componente</li>\n</ul>\n<p>Vea <span class=\"link\">este fiddle</span> para experimentar con el código completo, o <span class=\"link\">esta versión</span> para un ejemplo de enlace o <em>binding</em> al objeto de opciones de un componente, en lugar de su nombre registrado.</p>\n<p>Eso es todo lo que necesita saber sobre los componentes dinámicos por ahora, pero una vez que haya terminado de leer esta página y se sienta cómodo con su contenido, le recomendamos volver más tarde para leer la guía completa sobre <span class=\"link\">Componentes Dinámicos y Asíncronos</span>.</p>\n<h2>Casos especiales de análisis de plantillas DOM.</h2><p>Algunos elementos HTML, como <code>&lt;ul&gt;</code>, <code>&lt;ol&gt;</code>, <code>&lt;table&gt;</code> y <code>&lt;select&gt;</code> tienen restricciones sobre qué elementos pueden aparecer dentro de ellos, y algunos elementos como <code>&lt;li&gt;</code>, <code>&lt;tr&gt;</code> y <code>&lt;option&gt;</code> solo pueden aparecer dentro de ciertos otros elementos.</p>\n<p>Esto conducirá a problemas cuando se utilizan componentes con elementos que tienen tales restricciones. Por ejemplo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">blog-post-row</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">blog-post-row</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span></pre>\n<p>El componente personalizado <code>&lt;blog-post-row&gt;</code> se colocará como contenido no válido, lo que provocará errores en el resultado final. Afortunadamente, el atributo especial <code>is</code> ofrece una solución alternativa:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">tr</span> <span class=\"attr\">is</span>=<span class=\"string\">\"blog-post-row\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span></pre>\n<p>Debe tenerse en cuenta que <strong>esta limitación no se aplica si está utilizando plantillas de cadenas de texto de una de las siguientes fuentes</strong>:</p>\n<ul>\n<li><em>Plantillas de cadenas de texto</em> (ej: <code>template: '...'</code>)</li>\n<li><span class=\"link\">Componentes de un solo archivo</span> (<code>.vue</code>)</li>\n<li><span class=\"link\"><code>&lt;script type=\"text/x-template\"&gt;</code></span></li>\n</ul>\n<p>Eso es todo lo que necesita saber sobre los casos especiales de análisis de plantillas DOM por ahora, y en realidad, el final de los aspectos <em>esenciales</em> de Vue. ¡Felicidades! Todavía hay más que aprender, pero primero, recomendamos tomar un descanso para practicar con Vue usted mismo y construir algo divertido.</p>\n<p>Una vez que se sienta cómodo con el conocimiento que acaba de digerir, le recomendamos que regrese para leer la guía completa de <span class=\"link\">Componentes Dinámicos y Asíncronos</span>, así como las otras páginas en la sección <em>Componentes en Profundidad</em> de la barra lateral.</p>"
  }
]