[
  {
    "title": "instalacion",
    "contenido":  "<h1>Instalación</h1>\n<h3>Nota de compatibilidad</h3>\n<p>Vue no es compatible con IE8 y versiones anteriores, ya que utiliza las características de\n    ECMAScript 5 que son incompatibles en IE8. Sin embargo, admite todos los navegadores compatibles\n    con ECMAScript 5.</p>\n\n<h3>Notas de lanzamiento</h3>\n<p>Última versión estable: 2.5.16</p>\n<p>Las notas de lanzamiento detalladas para cada versión están disponibles en GitHub.</p>\n\n<h2>Vue Devtools</h2>\n<p>Cuando use Vue, le recomendamos que también instale Vue Devtools en su navegador, lo que le permite inspeccionar y depurar sus aplicaciones de Vue de una manera más amigable.</p>\n\n<h2>Inclusión Directa con script</h2>\n<p>Simplemente descargue e incluya la etiqueta script con la ruta correcta. Vue será registrado como una variable global.</p>\n<p>No utilice la versión minificada (de producción) durante el desarrollo. Usted perderá todas las advertencias interesantes para los errores más comunes!</p>\n<p><b>Versión de Desarrollo</b> Mensajes de error completos y modo de depuración</p>\n<p><b>Versión de Producción</b> Sin mensajes de error, 30.90KB min+gzip</p>\n\n<h3>CDN</h3>\n<p>Es recomendable vincular a un número específico de versión que pueda actualizar manualmente:</p>\n<pre><code> <span >&lt;<span >script</span> <span >src</span>=<span >\"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\"</span>&gt;</span><span >&lt;/<span >script</span>&gt;</span></code></pre>\n<p>Para producción, recomendamos vincular a un número de versión específico y compilar para evitar roturas inesperadas de versiones más nuevas:</p>\n<pre><code><span>&lt;<span>script</span> <span>src</span>=<span>\"https://cdn.jsdelivr.net/npm/vue@2.6.14\"</span>&gt;</span><span>&lt;/<span>script</span>&gt;</span></code></pre>\n<p>Si está utilizando módulos ES nativos, también hay una compilación compatible con módulos ES:</p>\n<pre><code><span>&lt;<span>script</span> <span>type</span>=<span>\"module\"</span>&gt;</span><span class=\"javascript\">\n  <span>import</span> Vue <span>from</span> <span>'https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.esm.browser.js'</span>\n</span><span>&lt;/<span>script</span>&gt;</span></code></pre>\n<p>Puede buscar el código fuente del paquete NPM en cdn.jsdelivr.net/npm/vue .</p>\n<p>Vue también está disponible en unpkg y cdnjs (cdnjs tarda algún tiempo en sincronizarse, por lo que es posible que la última versión aún no esté disponible).</p>\n<p>Asegúrese de leer sobre las diferentes versiones de Vue y use la versión de producción\nen su sitio publicado, reemplazando vue.jscon vue.min.js. Esta es una compilación más pequeña optimizada para la velocidad en lugar de la experiencia de desarrollo.</p>\n\n<h2>NPM</h2>\n<p>NPM es el método de instalación recomendado al crear aplicaciones a gran escala con Vue. Se combina muy bien con paquetes de módulos como Webpack o Browserify . Vue también proporciona herramientas complementarias para la creación de componentes de un solo archivo .</p>\n<pre><code><span># latest stable</span>\n$ npm install vue</code></pre>\n\n<h2>CLI</h2>\n<p>Vue proporciona una CLI oficial para implementar rápidamente aplicaciones ambiciosas de una sola página. Proporciona configuraciones de compilación con baterías para un flujo de trabajo frontend moderno. Solo se necesitan unos minutos para poner en funcionamiento las compilaciones listas para producción, recarga en caliente y almacenamiento de pelusa. Consulte los documentos de la CLI de Vue para obtener más detalles.</p>\n<p>La CLI asume un conocimiento previo de Node.js y las herramientas de compilación asociadas. Si es nuevo en Vue o en las herramientas de compilación de front-end, le recomendamos encarecidamente que lea la guía sin ninguna herramienta de compilación antes de usar la CLI.</p>"
  },
  {
    "title": "Introducción",
    "contenido":  "<h1>Introducción</h1>\n<h2>¿Qué es Vue.js?</h2>\n<p>Vue es un <b>marco progresivo</b> para construir interfaces de usuario. A diferencia de otros marcos monolíticos, Vue está diseñado desde cero para ser adoptable de forma incremental. La biblioteca principal se centra solo en la capa de vista y es fácil de recoger e integrar con otras bibliotecas o proyectos existentes. Por otro lado, Vue también es perfectamente capaz de impulsar aplicaciones sofisticadas de una sola página cuando se usa en combinación con <b>herramientas modernas y bibliotecas de soporte</b> .</p>\n\n<h2>Empezando</h2>\n<p><b>Instalación</b></p>\n<blockquote>La guía oficial asume un conocimiento de nivel intermedio de HTML, CSS y JavaScript. Si es totalmente nuevo en el desarrollo de frontend, puede que no sea la mejor idea saltar directamente a un marco como primer paso: ¡aprenda los conceptos básicos y luego regrese! La experiencia previa con otros marcos ayuda, pero no es necesaria.</blockquote>\n<p>La forma más fácil de probar Vue.js es usando el <b>ejemplo de Hello World</b> . Siéntase libre de abrirlo en otra pestaña y seguirlo mientras revisamos algunos ejemplos básicos. O <b>puede crear un index.htmlarchivo</b> e incluir Vue con:</p>\n<pre><code><span>&lt;!-- development version, includes helpful console warnings --&gt;</span>\n<span>&lt;<span>script</span> <span>src</span>=<span>\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"</span>&gt;</span><span>&lt;/<span>script</span>&gt;</span></code></pre>\n<p>o:</p>\n<pre><code><span>&lt;!-- production version, optimized for size and speed --&gt;</span>\n<span>&lt;<span>script</span> <span>src</span>=<span>\"https://cdn.jsdelivr.net/npm/vue@2\"</span>&gt;</span><span>&lt;/<span>script</span>&gt;</span></code></pre>\n<p>La página de <b>instalación</b> proporciona más opciones para instalar Vue. Nota: Nosotros no recomendamos que los principiantes comienzan con <code>vue-cli</code>, especialmente si usted todavía no está familiarizado con las herramientas de construcción basadas en Node.js.</p>\n<p>En el núcleo de Vue.js hay un sistema que nos permite renderizar datos de forma declarativa al DOM utilizando una sintaxis de plantilla sencilla:</p>\n\n<pre><code><span>&lt;<span>div</span> <span>id</span>=<span>\"app\"</span>&gt;</span><font></font>\n  {{ message }}<font></font>\n<span>&lt;/<span>div</span>&gt;</span></code></pre>\n<br><br>\n<pre><code><span>var</span> app = <span>new</span> Vue({\n  <span>el</span>: <span>'#app'</span>,\n  <span>data</span>: {\n    <span>message</span>: <span>'Hello Vue!'</span><font></font>\n  }<font></font>\n})</code></pre>\n\n<p>¡Ya hemos creado nuestra primera aplicación Vue! Esto se parece bastante a renderizar una plantilla de cadena, pero Vue ha hecho mucho trabajo bajo el capó. Los datos y el DOM ahora están vinculados y ahora todo es <b>reactivo</b> . ¿Como sabemos? Abra la consola JavaScript de su navegador (ahora mismo, en esta página) y establezca <code>app.messageun</code> valor diferente. Debería ver el ejemplo renderizado anterior actualizado en consecuencia.</p>\n<p>Tenga en cuenta que ya no tenemos que interactuar con el HTML directamente. Una aplicación Vue se adjunta a un solo elemento DOM ( <code>#app</code> en nuestro caso) y luego lo controla por completo. El HTML es nuestro punto de entrada, pero todo lo demás sucede dentro de la instancia de Vue recién creada.</p>\n<p>Además de la interpolación de texto, también podemos vincular atributos de elementos como este:</p>\n<pre><code><span>&lt;<span>div</span> <span>id</span>=<span>\"app-2\"</span>&gt;</span>\n  <span>&lt;<span>span</span> <span>v-bind:title</span>=<span>\"message\"</span>&gt;</span><font></font>\n    Hover your mouse over me for a few seconds<font></font>\n    to see my dynamically bound title!<font></font>\n  <span>&lt;/<span>span</span>&gt;</span>\n<span>&lt;/<span>div</span>&gt;</span></code></pre>\n<br>\n<pre><code><span>var</span> app2 = <span>new</span> Vue({\n  <span>el</span>: <span>'#app-2'</span>,\n  <span>data</span>: {\n    <span>message</span>: <span>'You loaded this page on '</span> + <span>new</span> <span>Date</span>().toLocaleString()<font></font>\n  }<font></font>\n})</code></pre>\n\n<p>Aquí nos encontramos con algo nuevo. El <code>v-bin</code> datributo que está viendo se llama <b>directiva</b> . Las directivas tienen el prefijo <code>v-</code> para indicar que son atributos especiales proporcionados por Vue y, como puede haber adivinado, aplican un comportamiento reactivo especial al DOM renderizado. Aquí, básicamente está diciendo \"mantenga el <b>title</b> atributo de este elemento actualizado con la <b>message</b> propiedad en la instancia de Vue\".</p>\n<p>Si vuelve a abrir su consola JavaScript e ingresa <code>app2.message = 'some new message'</code>, verá una vez más que el HTML enlazado, en este caso el <b>title</b> atributo, se ha actualizado.</p>\n<p>También es fácil alternar la presencia de un elemento:</p>\n<pre><code><span>&lt;<span>div</span> <span>id</span>=<span>\"app-3\"</span>&gt;</span>\n  <span>&lt;<span>span</span> <span>v-if</span>=<span>\"seen\"</span>&gt;</span>Now you see me<span>&lt;/<span>span</span>&gt;</span>\n<span>&lt;/<span>div</span>&gt;</span></code></pre>\n<br>\n<pre><code><span>var</span> app3 = <span>new</span> Vue({\n  <span>el</span>: <span>'#app-3'</span>,\n  <span>data</span>: {\n    <span>seen</span>: <span class=\"hljs-literal\">true</span><font></font>\n  }<font></font>\n})</code></pre>\n<br>\n<p>Adelante, entra <code>app3.seen = false</code> en la consola. Debería ver desaparecer el mensaje.</p>\n<p>Este ejemplo demuestra que podemos vincular datos no solo a texto y atributos, sino también a la <b>estructura</b> del DOM. Además, Vue también proporciona un potente sistema de <b>efectos de transición</b> que puede aplicar automáticamente efectos de transición cuando Vue inserta / actualiza / elimina elementos.</p>\n<p>Hay bastantes otras directivas, cada una con su propia funcionalidad especial. Por ejemplo, la <code>v-for</code> directiva se puede utilizar para mostrar una lista de elementos utilizando los datos de una matriz:</p>\n<pre><code><span>&lt;<span>div</span> <span>id</span>=<span>\"app-4\"</span>&gt;</span>\n  <span>&lt;<span>ol</span>&gt;</span>\n    <span>&lt;<span>li</span> <span>v-for</span>=<span>\"todo in todos\"</span>&gt;</span><font></font>\n      {{ todo.text }}<font></font>\n    <span>&lt;/<span>li</span>&gt;</span>\n  <span>&lt;/<span>ol</span>&gt;</span>\n<span>&lt;/<span>div</span>&gt;</span></code></pre>\n<br>\n<pre><code><span>var</span> app4 = <span>new</span> Vue({\n  <span>el</span>: <span>'#app-4'</span>,\n  <span>data</span>: {\n    <span>todos</span>: [<font></font>\n      { <span>text</span>: <span>'Learn JavaScript'</span> },<font></font>\n      { <span>text</span>: <span>'Learn Vue'</span> },<font></font>\n      { <span>text</span>: <span>'Build something awesome'</span> }<font></font>\n    ]<font></font>\n  }<font></font>\n})</code></pre>\n<p>En la consola, ingrese <code>app4.todos.push({ text: 'New item' })</code>. Debería ver un nuevo elemento adjunto a la lista.</p>\n\n<h2>Manejo de la entrada del usuario</h2>\n<p>Para permitir que los usuarios interactúen con su aplicación, podemos usar la <code>v-on</code> directiva para adjuntar detectores de eventos que invocan métodos en nuestras instancias de Vue:</p>\n<pre><code><span>&lt;<span>div</span> <span>id</span>=<span>\"app-5\"</span>&gt;</span>\n  <span>&lt;<span>p</span>&gt;</span>{{ message }}<span>&lt;/<span>p</span>&gt;</span>\n  <span>&lt;<span>button</span> <span>v-on:click</span>=<span>\"reverseMessage\"</span>&gt;</span>Reverse Message<span>&lt;/<span>button</span>&gt;</span>\n<span>&lt;/<span>div</span>&gt;</span></code></pre>\n<br>\n<pre><code><span>var</span> app5 = <span>new</span> Vue({\n  <span>el</span>: <span>'#app-5'</span>,\n  <span>data</span>: {\n    <span>message</span>: <span>'Hello Vue.js!'</span><font></font>\n  },<font></font>\n  <span>methods</span>: {\n    <span>reverseMessage</span>: <span class=\"hljs-function\"><span>function</span> (<span class=\"hljs-params\"></span>) </span>{\n      <span>this</span>.message = <span>this</span>.message.split(<span>''</span>).reverse().join(<span>''</span>)<font></font>\n    }<font></font>\n  }<font></font>\n})</code></pre>\n<p>Tenga en cuenta que en este método actualizamos el estado de nuestra aplicación sin tocar el DOM: todas las manipulaciones del DOM son manejadas por Vue y el código que escribe se centra en la lógica subyacente.</p>\n<p>Vue también proporciona la v-modeldirectiva que hace que el enlace bidireccional entre la entrada del formulario y el estado de la aplicación sea muy sencillo:</p>\n<pre><code><span>&lt;<span>div</span> <span>id</span>=<span>\"app-6\"</span>&gt;</span>\n  <span>&lt;<span>p</span>&gt;</span>{{ message }}<span>&lt;/<span>p</span>&gt;</span>\n  <span>&lt;<span>input</span> <span>v-model</span>=<span>\"message\"</span>&gt;</span>\n<span>&lt;/<span>div</span>&gt;</span></code></pre>\n<br>\n<pre><code><span>var</span> app6 = <span>new</span> Vue({\n  <span>el</span>: <span>'#app-6'</span>,\n  <span>data</span>: {\n    <span>message</span>: <span>'Hello Vue!'</span><font></font>\n  }<font></font>\n})</code></pre>\n\n<h2>Componer con componentes</h2>\n<p>El sistema de componentes es otro concepto importante en Vue, porque es una abstracción que nos permite construir aplicaciones a gran escala compuestas por componentes pequeños, autónomos y, a menudo, reutilizables. Si lo pensamos bien, casi cualquier tipo de interfaz de aplicación se puede abstraer en un árbol de componentes:</p>\n<p>En Vue, un componente es esencialmente una instancia de Vue con opciones predefinidas. Registrar un componente en Vue es sencillo:</p>\n<pre><code><span>// Define a new component called todo-item</span>\nVue.component(<span>'todo-item'</span>, {\n  <span>template</span>: <span>'&lt;li&gt;This is a todo&lt;/li&gt;'</span><font></font>\n})<font></font>\n<font></font>\n<span>var</span> app = <span>new</span> Vue(...)</code></pre>\n<p>Ahora puede componerlo en la plantilla de otro componente:</p>\n<p><pre><code><span>&lt;<span>ol</span>&gt;</span>\n  <span>&lt;!-- Create an instance of the todo-item component --&gt;</span>\n  <span>&lt;<span>todo-item</span>&gt;</span><span>&lt;/<span>todo-item</span>&gt;</span>\n<span>&lt;/<span>ol</span>&gt;</span></code></pre></p>\n<p>Pero esto generaría el mismo texto para cada tarea, lo cual no es muy interesante. Deberíamos poder pasar datos del ámbito principal a los componentes secundarios. Modifiquemos la definición del componente para que acepte un <b>accesorio</b> :</p>\n<pre><code>Vue.component(<span>'todo-item'</span>, {\n  <span>// The todo-item component now accepts a</span>\n  <span>// \"prop\", which is like a custom attribute.</span>\n  <span>// This prop is called todo.</span>\n  <span>props</span>: [<span>'todo'</span>],\n  <span>template</span>: <span>'&lt;li&gt;{{ todo.text }}&lt;/li&gt;'</span>\n})</code></pre>\n<p>Ahora podemos pasar la tarea a cada componente repetido usando <code>v-bind</code>:</p>\n<pre><code><span>&lt;<span>div</span> <span>id</span>=<span>\"app-7\"</span>&gt;</span>\n  <span>&lt;<span>ol</span>&gt;</span>\n    <span>&lt;!--\n      Now we provide each todo-item with the todo object\n      it's representing, so that its content can be dynamic.\n      We also need to provide each component with a \"key\",\n      which will be explained later.\n    --&gt;</span>\n    <span>&lt;<span>todo-item</span>\n      <span>v-for</span>=<span>\"item in groceryList\"</span>\n      <span>v-bind:todo</span>=<span>\"item\"</span>\n      <span>v-bind:key</span>=<span>\"item.id\"</span>\n    &gt;</span><span>&lt;/<span>todo-item</span>&gt;</span>\n  <span>&lt;/<span>ol</span>&gt;</span>\n<span>&lt;/<span>div</span>&gt;</span></code></pre>\n<br>\n<pre><code>Vue.component(<span>'todo-item'</span>, {\n  <span>props</span>: [<span>'todo'</span>],\n  <span>template</span>: <span>'&lt;li&gt;{{ todo.text }}&lt;/li&gt;'</span><font></font>\n})<font></font>\n<font></font>\n<span>var</span> app7 = <span>new</span> Vue({\n  <span>el</span>: <span>'#app-7'</span>,\n  <span>data</span>: {\n    <span>groceryList</span>: [<font></font>\n      { <span>id</span>: <span class=\"hljs-number\">0</span>, <span>text</span>: <span>'Vegetables'</span> },<font></font>\n      { <span>id</span>: <span class=\"hljs-number\">1</span>, <span>text</span>: <span>'Cheese'</span> },<font></font>\n      { <span>id</span>: <span class=\"hljs-number\">2</span>, <span>text</span>: <span>'Whatever else humans are supposed to eat'</span> }<font></font>\n    ]<font></font>\n  }<font></font>\n})</code></pre>\n<p>Este es un ejemplo artificial, pero hemos logrado separar nuestra aplicación en dos unidades más pequeñas, y el hijo está razonablemente bien desacoplado del padre a través de la interfaz de accesorios. Ahora podemos mejorar aún más nuestro <code>todo-item</code> componente con una plantilla y una lógica más complejas sin afectar la aplicación principal.</p>\n<p>En una aplicación grande, es necesario dividir toda la aplicación en componentes para que el desarrollo sea manejable. Hablaremos mucho más sobre los componentes más adelante en la guía , pero aquí hay un ejemplo (imaginario) de cómo se vería la plantilla de una aplicación con componentes:</p>\n<pre><code><span>&lt;<span>div</span> <span>id</span>=<span>\"app\"</span>&gt;</span>\n  <span>&lt;<span>app-nav</span>&gt;</span><span>&lt;/<span>app-nav</span>&gt;</span>\n  <span>&lt;<span>app-view</span>&gt;</span>\n    <span>&lt;<span>app-sidebar</span>&gt;</span><span>&lt;/<span>app-sidebar</span>&gt;</span>\n    <span>&lt;<span>app-content</span>&gt;</span><span>&lt;/<span>app-content</span>&gt;</span>\n  <span>&lt;/<span>app-view</span>&gt;</span>\n<span>&lt;/<span>div</span>&gt;</span></code></pre>\n<h3>Relación con elementos personalizados</h3>\n<p>Es posible que haya notado que los componentes de Vue son muy similares a los <b>elementos personalizados</b> , que forman parte de la <b>especificación de componentes web</b> . Esto se debe a que la sintaxis del componente de Vue se modela libremente según la especificación. Por ejemplo, los componentes de Vue implementan la <b>API Slot</b> y el <code>is</code> atributo especial. Sin embargo, existen algunas diferencias clave:</p>\n<ul>\n  <li>La especificación de componentes web se ha finalizado, pero no se implementa de forma nativa en todos los navegadores. Safari 10.1+, Chrome 54+ y Firefox 63+ admiten componentes web de forma nativa. En comparación, los componentes de Vue no requieren polyfills y funcionan de manera consistente en todos los navegadores compatibles (IE9 y superior). Cuando sea necesario, los componentes de Vue también se pueden envolver dentro de un elemento personalizado nativo.</li>\n  <li>Los componentes de Vue brindan características importantes que no están disponibles en elementos personalizados simples, en particular el flujo de datos de componentes cruzados, la comunicación de eventos personalizados e integraciones de herramientas de construcción.</li>\n</ul>\n<p>Aunque Vue no usa elementos personalizados internamente, tiene una <b>gran interoperabilidad</b> cuando se trata de consumir o distribuir como elementos personalizados. Vue CLI también admite la creación de componentes de Vue que se registran como elementos personalizados nativos.</p>"
  },
  {
    "title": "La instancia Vue",
    "contenido":  "<h1>La instancia Vue</h1>\n<h2>Creando una instancia de Vue</h2>\n<p>Cada aplicación de Vue se comienza creando una nueva <strong>Instancia de Vue</strong> con la\n    función <code>Vue</code>:</p>\n<pre><code><span>var</span> vm = <span>new</span> Vue({\n  <span>// options</span>\n})</code></pre>\n\n<p>Aunque no estrictamente asociado con el patrón MVVM, el diseño de Vue fue en parte inspirado por\n    él.<br>Como\n    una convención, solemos usar la variable <code>vm</code> (abreviación de ViewModel) para\n    hacer referencia a nuestra instancia de Vue.</p>\n<p>Cuando usted crea una instancia de Vue, le pasa un <strong>objeto options</strong>. La mayor\n    parte de esta guía describe cómo usted puede usar estas opciones para crear el\n    comportamiento deseado.<br>Como referencia, usted puede visitar también la lista completa de\n    opciones en la documentación de la API.</p>\n<p>Una aplicación Vue está conformada por una <strong>instancia Vue raíz</strong> creada con\n    <code>new Vue</code>, opcionalmente organizada dentro de un árbol de componentes reusables\n    anidados. Por ejemplo, el árbol de una aplicación TO-DO podría verse así:</p>\n<pre><code>Root Instance\n└─ TodoList\n   ├─ TodoItem\n   │  ├─ TodoButtonDelete\n   │  └─ TodoButtonEdit\n   └─ TodoListFooter\n      ├─ TodosButtonClear\n      └─ TodoListStatistics</code></pre>\n\n<p>Hablaremos sobre el sistema de componentes en detalle después.\n    Por ahora, solo es necesario saber que todos los componentes de Vue son también instancias\n    de Vue, por lo tanto aceptan el mismo objeto options (excepto para unas pocas específicas\n    opciones de raíz).</p>\n<h2>Datos y Métodos</h2>\n<p>Cuando una instancia Vue es creada, agrega todas las propiedades encontradas en su objeto\n    <code>data</code> al <strong>sistema de reactividad</strong> de Vue. Cuando los valores de\n    estas propiedades cambian, la vista “reaccionará”, actualizándose para coincidir con los\n    nuevos valores.</p>\n<pre><code><span>// Our data object</span>\n<span>var</span> data = { <span>a</span>: <span>1</span> }\n\n<span>// The object is added to a Vue instance</span>\n<span>var</span> vm = <span>new</span> Vue({\n  <span>data</span>: data\n})\n\n<span>// Getting the property on the instance</span>\n<span>// returns the one from the original data</span>\nvm.a == data.a <span>// =&gt; true</span>\n\n<span>// Setting the property on the instance</span>\n<span>// also affects the original data</span>\nvm.a = <span>2</span>\ndata.a <span>// =&gt; 2</span>\n\n<span>// ... and vice-versa</span>\ndata.a = <span>3</span>\nvm.a <span>// =&gt; 3</span></code></pre>\n\n<p>Cuando estos datos cambian, la vista volverá a renderizarse. Es preciso señalar que las\n    propiedades en <code>data</code> solo son <strong>reactivas</strong> si ya existían cuando\n    se creó la instancia. Eso significa que si usted agrega una nueva propiedad, como:</p>\n<pre><code>vm.b = <span>'hi'</span></code></pre>\n<p>Entonces los cambios de <code>b</code> no producirán ninguna actualización en la vista. Si\n    sabe que necesitará una propiedad más adelante, pero comienza vacía o inexistente,\n    necesitará setear un valor inicial. Por ejemplo:</p>\n<pre><code>data: {\n  <span>newTodoText</span>: <span>''</span>,\n  <span>visitCount</span>: <span>0</span>,\n  <span>hideCompletedTodos</span>: <span>false</span>,\n  <span>todos</span>: [],\n  <span>error</span>: <span>null</span>\n}</code></pre>\n<p>La unica excepción a esto es el uso de <code>Object.freeze()</code>, lo que evita que se\n    modifiquen las propiedades existentes, lo que también significa que el sistema de\n    reactividad no puede rastrear cambios.</p>\n<pre><code><span>var</span> obj = {\n  <span>foo</span>: <span>'bar'</span>\n}\n\n<span>Object</span>.freeze(obj)\n\n<span>new</span> Vue({\n  <span>el</span>: <span>'#app'</span>,\n  <span>data</span>: obj\n})</code></pre>\n<br>\n<pre><code><span>&lt;<span>div</span> <span>id</span>=<span>\"app\"</span>&gt;</span>\n  <span>&lt;<span>p</span>&gt;</span>{{ foo }}<span>&lt;/<span>p</span>&gt;</span>\n  <span>&lt;!-- this will no longer update `foo`! --&gt;</span>\n  <span>&lt;<span>button</span> <span>v-on:click</span>=<span>\"foo = 'baz'\"</span>&gt;</span>Change it<span>&lt;/<span>button</span>&gt;</span>\n<span>&lt;/<span>div</span>&gt;</span></code></pre>\n\n<p>Además de las propiedades de datos, las instancias de Vue exponen una serie de métodos y\n    propiedades de instancia útiles. Estos tienen el prefijo <code>$</code> para diferenciarlos\n    de las propiedades definidas por el usuario. Por ejemplo:</p>\n<pre><code><span>var</span> data = { <span>a</span>: <span>1</span> }\n<span>var</span> vm = <span>new</span> Vue({\n  <span>el</span>: <span>'#example'</span>,\n  <span>data</span>: data\n})\n\nvm.$data === data <span>// =&gt; true</span>\nvm.$el === <span>document</span>.getElementById(<span>'example'</span>) <span>// =&gt; true</span>\n\n<span>// $watch is an instance method</span>\nvm.$watch(<span>'a'</span>, <span><span>function</span> (<span>newValue, oldValue</span>) </span>{\n  <span>// This callback will be called when `vm.a` changes</span>\n})</code></pre>\n<p>En el futuro, puede consultar la documentación de la\n    API para una lista completa de propiedades y métodos de instancia.</p>\n<h2>Hooks del Ciclo de vida\n    de la Instancia</h2>\n<p>Cada instancia de Vue pasa a través de una serie de pasos de inicialización cuando es creada\n    - por ejemplo, se necesita configurar la observación de datos, compilar la plantilla, montar\n    la instancia en el DOM y actualizar el DOM cuando cambian los datos. En el camino, también\n    se ejecutan funciones llamadas <strong>hooks del ciclo de vida</strong>, lo que brinda a los\n    usuarios la oportunidad de agregar su propio código en etapas específicas.</p>\n<p>Por ejemplo, el hook <code>created</code> puede ser utilizado\n    para ejecutar código después que una instancia es creada:</p>\n<pre><code><span>new</span> Vue({\n  <span>data</span>: {\n    <span>a</span>: <span>1</span>\n  },\n  <span>created</span>: <span><span>function</span> (<span></span>) </span>{\n    <span>// `this` points to the vm instance</span>\n    <span>console</span>.log(<span>'a is: '</span> + <span>this</span>.a)\n  }\n})\n<span>// =&gt; \"a is: 1\"</span></code></pre>\n<p>También hay otros hooks que se llamarán en diferentes etapas del ciclo de vida de la\n    instancia, como <code>mounted</code>, <code>updated</code>, y <code>destroyed</code>. Todos los\n    hooks del ciclo de\n    vida se llaman en el contexto <code>this</code> apuntando a la instancia de Vue que lo\n    invoca.</p>\n<p>No usar arrow functions en una propiedad de opciones o\n    respuesta, como <code>created: () =&gt; console.log(this.a)</code> or <code>vm.$watch('a',\n        newValue =&gt; this.myMethod())</code>. Dado que las arrow functions están vinculadas al\n    contexto padre, <code>this</code> no será la instancia de Vue como lo esperaría, lo que\n    suele producir errores, como ‘Uncaught TypeError: Cannot read property of\n    undefined<code>o</code>Uncaught TypeError: this.myMethod is not a function`.</p>\n\n<h2>Diagrama\n    del Ciclo de vida</h2>\n<p>La imagen de abajo es un diagrama para el ciclo de vida de una instancia. No es necesario que\n    entienda como funciona todo en este momento, pero a medida que aprenda y construya más, será\n    una referencia útil.</p>\n<img src=\"asset:assets/img/lifecycle.png\" alt=\"\">"
  },
  {
    "title": "Sintaxis de Template",
    "contenido":  "<div style=\"font-size: 100%\"><h1>Sintaxis de Template</h1>\n\n<p>Vue.js utiliza una sintaxis de template basada en HTML que le permite vincular de forma declarativa el DOM renderizado a los datos de la instancia de Vue subyacente. Todas las templates de Vue.js son HTML válidas que pueden analizarse mediante navegadores compatibles con especificaciones y analizadores de HTML.</p>\n<p>Bajo el capó, Vue compila las templates en funciones de renderizado del DOM virtual. Combinado con el sistema de reactividad, Vue puede averiguar de manera inteligente el número mínimo de componentes para volver a renderizar y aplicar la cantidad mínima de manipulacion del DOM cuando el estado de la aplicacion cambia.</p>\n<p>Si está familiarizado con los conceptos de DOM virtual y prefiere la potencia bruta de JavaScript, también puede <span class=\"link\">escribir directamente funciones de procesamiento</span> en lugar de plantillas, con soporte opcional de JSX.</p>\n<h2>Interpolaciones</h2><h3>Texto</h3><p>La forma más básica de enlace de datos es la interpolación de texto usando la sintaxis de <em>mustaches</em> (llaves doble):</p>\n<pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Message: {{ msg }}<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br></pre>\n<p>La etiqueta del <em>mustache</em> se reemplazará con el valor de la propiedad <code class=\"naranja\">msg</code> en el objeto de datos correspondiente. También se actualizará cada vez que cambie la propiedad <code class=\"naranja\">msg</code> del objeto de datos.</p>\n<p>También puede realizar interpolaciones únicas que no se actualizan en el cambio de datos usando la <span class=\"link\">directiva v-once</span>, pero tenga en cuenta que esto también afectará a cualquier otro enlace en el mismo nodo:</p>\n<pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-once</span>&gt;</span>Esto nunca cambiara: {{ msg }}<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br></pre>\n<h3>HTML Puro</h3><p>Los <em>mustaches</em> (llaves doble) interpretan los datos como texto plano, no HTML. Para generar HTML real, deberá utilizar la directiva <code class=\"naranja\">v-html</code>:</p>\n<pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Using mustaches: {{ rawHtml }}<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Using v-html directive: <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-html</span>=<span class=\"string\">\"rawHtml\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre>\n\n<p>El contenido del <code class=\"naranja\">span</code> se reemplazará con el valor de la propiedad <code class=\"naranja\">rawHtml</code>, interpretado como HTML simple: se ignoran los enlaces de datos. Tenga en cuenta que no puede utilizar <code class=\"naranja\">v-html</code> para componer plantillas parciales, porque Vue no es un motor de plantillas basado en cadenas. En cambio, se prefieren los componentes como la unidad fundamental para la reutilización y la composición de la interfaz de usuario.</p>\n<p class=\"tip\">La ejecución dinámica de HTML arbitrario en su sitio web puede ser muy peligrosa porque puede conducir fácilmente a <span class=\"link\">vulnerabilidades de XSS</span>. Utilice solo la interpolación HTML en contenido de confianza y <strong>nunca</strong> en contenido proporcionado por usuario.</p>\n\n<h3>Atributos</h3><p>Los <em>mustaches</em> (llaves doble) no se pueden utilizar dentro de los atributos HTML. En su lugar, use una <span class=\"link\">directiva v-bind</span>:</p>\n<pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:id</span>=<span class=\"string\">\"dynamicId\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre>\n<p>En el caso de los atributos booleanos, donde su mera existencia implica <code class=\"naranja\">true</code>, <code class=\"naranja\">v-bind</code> funciona de manera un poco diferente. En este ejemplo:</p>\n<pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-bind:disabled</span>=<span class=\"string\">\"isButtonDisabled\"</span>&gt;</span>Button<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre>\n<p>Si <code class=\"naranja\">isButtonDisabled</code> tiene el valor de <code class=\"naranja\">null</code>, <code class=\"naranja\">undefined</code> o <code class=\"naranja\">false</code>, el atributo <code class=\"naranja\">disabled</code> ni siquiera se incluirá en el elemento <code class=\"naranja\">&lt;button&gt;</code> representado.</p>\n<h3>Usando Expresiones JavaScript</h3><p>Hasta ahora solo hemos estado vinculando a simples claves de propiedad en nuestras template. Pero Vue.js realmente admite el poder completo de las expresiones de JavaScript dentro de todos los enlaces de datos:</p>\n<pre><span class=\"line\">{{ number + 1 }}</span><br><span class=\"line\"></span><br><span class=\"line\">{{ ok ? 'YES' : 'NO' }}</span><br><span class=\"line\"></span><br><span class=\"line\">{{ message.split('').reverse().join('') }}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:id</span>=<span class=\"string\">\"'list-' + id\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre>\n<p>Estas expresiones se evaluarán como JavaScript en el ámbito de datos de la instancia de Vue del propietario. Una restricción es que cada enlace solo puede contener <strong>una expresión</strong>, por lo que lo siguiente <strong>NO</strong> funcionará:</p>\n<pre><span class=\"line\"><span class=\"comment\">&lt;!-- esto es una declaración, no una expresión --&gt;</span></span><br><span class=\"line\">{{ var a = 1 }}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- El control de flujo tampoco funcionará, use expresiones ternarias --&gt;</span></span><br><span class=\"line\">{{ if (ok) { return message } }}</span><br></pre>\n<p class=\"tip\">Las expresiones de template están en un espacio aislado y solo tienen acceso a una lista blanca de elementos globales como <code class=\"naranja\">Matemáticas</code> y <code class=\"naranja\">Fecha</code>. No debe intentar acceder a globales definidos por el usuario en expresiones de template.</p>\n\n<h2>Directivas</h2><p>Las directivas son atributos especiales con el prefijo <code class=\"naranja\">v-</code>. Se espera que los valores de atributo de la directiva sean <strong>una única expresión de JavaScript</strong> (con la excepción de <code class=\"naranja\">v-for</code>, que se tratará más adelante). El trabajo de una directiva es aplicar reactivamente efectos secundarios al DOM cuando cambia el valor de su expresión. Repasemos el ejemplo que vimos en la introducción:</p>\n<pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"seen\"</span>&gt;</span>Now you see me<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre>\n<p>Aquí, la directiva <code class=\"naranja\">v-if</code> insertaría/eliminaría el elemento </p><p> basándose en la veracidad del valor de la expresión <code class=\"naranja\">seen</code>.</p>\n<h3>Argumentos</h3><p>Algunas directivas pueden tomar un “argumento”, denotado por dos puntos después del nombre de la directiva. Por ejemplo, la directiva <code class=\"naranja\">v-bind</code> se usa para actualizar de forma reactiva un atributo HTML:</p>\n<pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-bind:href</span>=<span class=\"string\">\"url\"</span>&gt;</span> ... <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre>\n<p>Aquí href es el argumento, que le dice a la directiva <code class=\"naranja\">v-bind</code> que vincule el atributo <code class=\"naranja\">href</code> del elemento al valor de la expresión <code class=\"naranja\">url</code>.</p>\n<p>Otro ejemplo es la directiva <code class=\"naranja\">v-on</code>, que escucha los eventos DOM:</p>\n<pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"doSomething\"</span>&gt;</span> ... <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre>\n<p>Aquí el argumento es el nombre del evento a escuchar. Hablaremos sobre el manejo de eventos con más detalle también.</p>\n<h3>Modificadores</h3><p>Los modificadores son sufijos especiales indicados por un punto, que indican que una directiva debe estar vinculada de alguna manera especial. Por ejemplo, el modificador <code class=\"naranja\">.prevent</code> le dice a la directiva <code class=\"naranja\">v-on</code> que llame a <code class=\"naranja\">event.preventDefault()</code> en el evento activado:</p>\n<pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">v-on:submit.prevent</span>=<span class=\"string\">\"onSubmit\"</span>&gt;</span> ... <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre>\n<p>Más adelante veremos otros ejemplos de modificadores, <span class=\"link\">para <code class=\"naranja\">v-on</code></span> y <span class=\"link\">para <code class=\"naranja\">v-model</code></span>, cuando exploremos esas características.</p>\n<h2>Modo abreviado</h2><p>El prefijo <code class=\"naranja\">v-</code> sirve como una señal visual para identificar atributos específicos de Vue en sus templates. Esto es útil cuando está utilizando Vue.js para aplicar un comportamiento dinámico a algún marcado existente, pero puede sentirse detallado para algunas directivas de uso frecuente. Al mismo tiempo, la necesidad del prefijo <code class=\"naranja\">v-</code> es menos importante cuando se está construyendo un <span class=\"link\">SPA</span> donde Vue.js administra cada template. Por lo tanto, Vue.js proporciona abreviaturas especiales para dos de las directivas más utilizadas, <code class=\"naranja\">v-bind</code> y <code class=\"naranja\">v-on</code>:</p>\n<h3><code class=\"naranja\">v-bind</code> Abreviado</h3><pre><span class=\"line\"><span class=\"comment\">&lt;!-- full syntax --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-bind:href</span>=<span class=\"string\">\"url\"</span>&gt;</span> ... <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- abreviado --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">:href</span>=<span class=\"string\">\"url\"</span>&gt;</span> ... <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre>\n<h3><code class=\"naranja\">v-on</code> Abreviado</h3><pre><span class=\"line\"><span class=\"comment\">&lt;!-- full syntax --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"doSomething\"</span>&gt;</span> ... <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- abreviado --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"doSomething\"</span>&gt;</span> ... <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre>\n<p>Pueden parecer un poco diferentes del HTML normal, pero <code class=\"naranja\">:</code> y <code class=\"naranja\">@</code> son caracteres válidos para los nombres de atributos y todos los navegadores compatibles con Vue.js pueden analizarlo correctamente. Además, no aparecen en el marcado final renderizado. La sintaxis abreviada es totalmente opcional, pero es probable que la aprecie cuando sepa más sobre su uso más adelante.</p>\n</div>"
  },
  {
    "title": "Propiedades Computadas y Observadores",
    "contenido":  "<h1>Propiedades Computadas y Observadores</h1>\n\n<h2><span class=\"link\">Propiedades Computadas</span></h2>\n<p>Las expresiones en el <em>template</em> son muy convenientes, pero están diseñadas para operaciones simples. Poner demasiada lógica en sus <em>templates</em> puede hacerlos grandes, complejos y difíciles de mantener. Por ejemplo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example\"</span>&gt;</span>\n  {{ message.split('').reverse().join('') }}\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>En este punto, el <em>template</em> ya no es simple y declarativo. Debe mirarlo por un segundo antes de darse cuenta de que muestra <code>message</code> al revés. El problema se agrava cuando desea incluir el mensaje invertido en su <em>template</em> más de una vez.</p>\n<p>Es por eso que para cualquier lógica compleja, deberia usar una <strong>propiedad computada</strong>.</p>\n<h3><span class=\"link\">Ejemplo Básico</span></h3>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Mensaje original: \"{{ message }}\"<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Mensaje invertido computado: \"{{ reversedMessage }}\"<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#example'</span>,\n  data: {\n    message: <span class=\"string\">'Hola'</span>\n  },\n  computed: {\n    <span class=\"comment\">// un getter computado</span>\n    reversedMessage: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n      <span class=\"comment\">// `this` apunta a la instancia vm</span>\n      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.message.split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)\n    }\n  }\n})</span></pre>\n\n\n<p>Aquí hemos declarado una propiedad computada <code>reversedMessage</code>. La función que\nproporcionemos se utilizará como la función getter para la propiedad <code>vm.reversedMessage</code>:</p>\n<pre><span class=\"built_in\">console</span>.log(vm.reversedMessage) <span class=\"comment\">// =&gt; 'aloH'</span>\nvm.message = <span class=\"string\">'Adios'</span>\n<span class=\"built_in\">console</span>.log(vm.reversedMessage) <span class=\"comment\">// =&gt; 'soidA'</span></span></pre>\n<p>Puede abrir la consola y jugar con el ejemplo vm usted mismo. El valor de <code>vm.reversedMessage</code> siempre depende del valor de <code>vm.message</code>.</p>\n<p>Puede enlazar datos a propiedades computadas en el <em>template</em> al igual que una propiedad normal. Vue es consciente de que <code>vm.reversedMessage</code> depende de <code>vm.message</code>, por lo cual actualizará todos los enlaces que dependan de <code>vm.reversedMessage</code> cuando <code>vm.message</code> cambie. Y lo mejor de todo es que hemos creado esta relación de dependencia de manera declarativa: la función computada getter no tiene efectos secundarios, lo que facilita la prueba y la comprensión.</p>\n<h3><span class=\"link\">Caching computado vs Métodos</span></h3>\n<p>Es posible que haya notado que podemos lograr el mismo resultado al invocar un método en la expresión:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Mensaje Invertido: \"{{ reverseMessage() }}\"<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></pre>\n<pre><span class=\"comment\">// en componente</span>\nmethods: {\n  reverseMessage: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.message.split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)\n  }\n}</span></pre>\n<p>En lugar de una propiedad computada, podemos definir la misma función como un método en su lugar. Para el resultado final, los dos enfoques son exactamente los mismos. Sin embargo, la diferencia es que las <strong>propiedades computadas se almacenan en caché según sus dependencias.</strong> Una propiedad computada solo se volverá a evaluar cuando alguna de sus dependencias haya cambiado. Esto significa que mientras <code>message</code> no haya cambiado, el acceso múltiple a la propiedad computada de <code>reverseMessage</code> regresará inmediatamente el resultado previamente calculado sin tener que ejecutar la función de nuevo.</p>\n<p>Esto también significa que la siguiente propiedad computada nunca se actualizará, porque <code>Date.now()</code> no es una dependencia reactiva:</p>\n<pre>computed: {\n  now: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n    <span class=\"keyword\">return</span> <span class=\"built_in\">Date</span>.now()\n  }\n}</span></pre>\n<p>En comparación, una invocación de método <strong>siempre</strong> ejecutará la función cada vez que ocurre una re-renderizacion.</p>\n<p>¿Por qué necesitamos caché? Imagina que tenemos una costosa propiedad computada <strong>A</strong>, que requiere hacer un bucle a través de una gran matriz y hace muchos cálculos. Entonces podemos tener otras propiedades computadas que a su vez dependen de <strong>A</strong>. Sin caché, estaríamos ejecutando el captador de <strong>A</strong> muchas veces más de lo necesario. En los casos en que no desee el almacenamiento en caché, utilice un método en su lugar.</p>\n<h3><span class=\"link\">Propiedad Computada vs Watched</span></h3>\n<p>Vue proporciona una forma más genérica de observar y reaccionar a los cambios de datos en una instancia de Vue: <strong>propiedad watch</strong>. Cuando tiene algunos datos que necesitan cambiarse en función de otros datos, es tentador utilizar <code>watch</code> en exceso, especialmente si proviene de tener experiencia en AngularJS. Sin embargo, a menudo es una mejor idea usar una propiedad computada en lugar de una imperativa llamada a <code>watch</code> . Considera este ejemplo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"demo\"</span>&gt;</span>{{ fullName }}<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#demo'</span>,\n  data: {\n    firstName: <span class=\"string\">'Foo'</span>,\n    lastName: <span class=\"string\">'Bar'</span>,\n    fullName: <span class=\"string\">'Foo Bar'</span>\n  },\n  watch: {\n    firstName: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">val</span>) </span>{\n      <span class=\"keyword\">this</span>.fullName = val + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.lastName\n    },\n    lastName: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">val</span>) </span>{\n      <span class=\"keyword\">this</span>.fullName = <span class=\"keyword\">this</span>.firstName + <span class=\"string\">' '</span> + val\n    }\n  }\n})</span></pre>\n<p>El código anterior es imperativo y repetitivo. Compáralo con una versión de propiedad computada:</p>\n<pre><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#demo'</span>,\n  data: {\n    firstName: <span class=\"string\">'Foo'</span>,\n    lastName: <span class=\"string\">'Bar'</span>\n  },\n  computed: {\n    fullName: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstName + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.lastName\n    }\n  }\n})</span></pre>\n<p>Mucho mejor, ¿no?</p>\n<h3><span class=\"link\">Setter Computado</span></h3>\n<p>Las propiedades computadas son, de forma predeterminada solo get, pero también puede proporcionar un set cuando lo necesite:</p>\n<pre><span class=\"comment\">// ...</span>\ncomputed: {\n  fullName: {\n    <span class=\"comment\">// getter</span>\n    get: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstName + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.lastName\n    },\n    <span class=\"comment\">// setter</span>\n    set: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">newValue</span>) </span>{\n      <span class=\"keyword\">var</span> names = newValue.split(<span class=\"string\">' '</span>)\n      <span class=\"keyword\">this</span>.firstName = names[<span class=\"number\">0</span>]\n      <span class=\"keyword\">this</span>.lastName = names[names.length - <span class=\"number\">1</span>]\n    }\n  }\n}\n<span class=\"comment\">// ...</span></span></pre>\n<p>Ahora, cuando ejecute <code>vm.fullName = 'John Doe'</code>, se invocará el definidor y <code>vm.firstName</code> y <code>vm.lastName</code> se actualizarán en consecuencia.</p>\n<h2><span class=\"link\">Watchers</span></h2>\n<p>Si bien las propiedades computadas son más apropiadas en la mayoría de los casos, hay ocasiones en que es necesario un observador personalizado. Es por eso que Vue proporciona una forma más genérica de reaccionar a los cambios de datos a través de la opción <code>watch</code>. Esto es más útil cuando desea realizar operaciones asíncronas o costosas en respuesta al cambio de datos.</p>\n<p>por ejemplo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"watch-example\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>\n    Haz una pregunta de sí/no:\n    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"question\"</span>&gt;</span>\n  <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>{{ answer }}<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre>\nvar watchExampleVM = new Vue({\n  el: '#watch-example',\n  data: {\n    question: '',\n    answer: 'No puedo darte una respuesta hasta que hagas una pregunta!!'\n  },\n  watch: {\n    question: function (newQuestion, oldQuestion) {\n      this.answer = 'Esperando que deje de escribir......'\n      this.debouncedGetAnswer()\n    }\n  },\n  created: function () {\n    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)\n  },\n  methods: {\n    getAnswer:  function () {\n      if (this.question.indexOf('?') === -1) {\n        this.answer = 'Las preguntas suelen contener un signo de interrogación. ;-)'\n        return\n      }\n      this.answer = 'Pensando...'\n      var vm = this\n      axios.get('https://yesno.wtf/api')\n        .then(function (response) {\n          vm.answer = _.capitalize(response.data.answer)\n        })\n        .catch(function (error) {\n          vm.answer = '¡Error! No se pudo alcanzar la API. ' + error\n        })\n    }\n  }\n})\n</pre>\n  \n<p>En este caso, el uso de la opción <code>watch</code> nos permite realizar una operación asíncrona (acceder a una API), limita la frecuencia con la que realizamos esa operación y establece estados intermedios hasta que obtengamos una respuesta final. Nada de eso sería posible con una propiedad computada.</p>\n<p>Además de la opción <code>watch</code>, también puede usar el imperativo <span class=\"link\">vm.$Watch API</span>.</p>"
  },
  {
    "title": "Enlace Clases y Estilos",
    "contenido":  "<h1>Enlace Clases y Estilos</h1>\n<p>Una necesidad común de data binding es manipular la lista de clases de un elemento y sus estilos en línea. Como ambos son atributos, podemos usar <code>v-bind</code> para manejarlos: solo necesitamos crear una cadena de texto con nuestras expresiones. Sin embargo, concatenar cadenas de texto puede llegar a ser incómodo y propenso a errores. Por esta razón, Vue proporciona mejoras cuando se utiliza <code>v-bind</code> con<code>class</code> y <code>style</code>. Además de las cadenas de texto, las expresiones también pueden evaluar objetos o matrices.</p>\n<h2>Enlace de clases HTML</h2><h3>Sintaxis de Objeto</h3><p>Podemos pasar un objeto a <code>v-bind:class</code> para la asignación dinámica de clases:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"{ active: isActive }\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>La sintaxis de arriba tiene como resultado la clase <code>active</code> según el valor booleano(<span class=\"link\">https://developer.mozilla.org/en-US/docs/Glossary/Truthy</span>) de la propiedad <code>isActive</code>.</p>\n<p>Puede hacer multiple asignación de clases al tener más campos en el objeto. Además, la directiva <code>v-bind:class</code> también puede ser utilizada con el atributo <code>class</code>. De modo que con la siguiente plantilla:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"static\"</span></span>\n<span class=\"tag\">     <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"{ active: isActive, 'text-danger': hasError }\"</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Y el siguiente objeto <code>data</code>:</p>\n<pre>data: {\n  isActive: <span class=\"literal\">true</span>,\n  hasError: <span class=\"literal\">false</span>\n}</span></pre>\n<p>Se renderizará:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"static active\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Cuando <code>isActive</code> o <code>hasError</code> cambien, la lista de clases se actualizará consecuentemente. Por ejemplo, si <code>hasError</code> se convierte en <code>true</code>, la lista de clases se convertirá en <code>\"static active text-danger\"</code>.</p>\n<p>El objeto no tiene por qué estar en la misma línea:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"classObject\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre>data: {\n  classObject: {\n    active: <span class=\"literal\">true</span>,\n    <span class=\"string\">'text-danger'</span>: <span class=\"literal\">false</span>\n  }\n}</span></pre>\n<p>Esto renderizará el mismo resultado. También podemos enlazar una <span class=\"link\">propiedad computada</span> que retorna un objeto. Esto es un patrón común y poderoso:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"classObject\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre>data: {\n  isActive: <span class=\"literal\">true</span>,\n  error: <span class=\"literal\">null</span>\n},\ncomputed: {\n  classObject: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n    <span class=\"keyword\">return</span> {\n      active: <span class=\"keyword\">this</span>.isActive &amp;&amp; !<span class=\"keyword\">this</span>.error,\n      <span class=\"string\">'text-danger'</span>: <span class=\"keyword\">this</span>.error &amp;&amp; <span class=\"keyword\">this</span>.error.type === <span class=\"string\">'fatal'</span>\n    }\n  }\n}</span></pre>\n<h3>Sintaxis de Array</h3><p>Pasamos un array a <code>v-bind:class</code> para aplicar una lista de clases:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"[activeClass, errorClass]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre>data: {\n  activeClass: <span class=\"string\">'active'</span>,\n  errorClass: <span class=\"string\">'text-danger'</span>\n}</span></pre>\n<p>Que renderizará:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"active text-danger\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Si le gustaría activar una clase en la lista de manera condicional, usted puede hacerlo con una expresión ternaria:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"[isActive ? activeClass : '', errorClass]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Esto siempre aplicará <code>errorClass</code>, pero solo aplicará <code>activeClass</code> cuando <code>isActive</code> sea verdadero.</p>\n<p>Sin embargo, esto puede ser un poco verborrágico si usted tiene multiple clases condicionales. Por eso también es posible utilizar la sintaxis de objeto dentro de la sintaxis de colección:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"[{ active: isActive }, errorClass]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<h3>Con Componentes</h3><blockquote>\n<p>Esta sección asume que usted tiene conocimientos sobre <span class=\"link\">Componentes de Vue</span>. Siéntase libre de saltársela y volver más tarde.</p>\n</blockquote>\n<p>Cuando usa el atributo <code>class</code> en un componente personalizado, estas clases se agregarán al elemento raíz del componente. Las clases existentes en este elemento no serán sobreescritas.</p>\n<p>Por ejemplo, si declara este componente:</p>\n<pre>Vue.component(<span class=\"string\">'my-component'</span>, {\n  template: <span class=\"string\">'&lt;p class=\"foo bar\"&gt;Hi&lt;/p&gt;'</span>\n})</span></pre>\n<p>Y agrega algunas clases al usarlo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">class</span>=<span class=\"string\">\"baz boo\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span></pre>\n<p>El HTML renderizado será:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"foo bar baz boo\"</span>&gt;</span>Hi<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></pre>\n<p>Lo mismo aplica para el enlace de clases:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"{ active: isActive }\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span></pre>\n<p>Cuando <code>isActive</code> es verdadero, el HTML renderizado será:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"foo bar active\"</span>&gt;</span>Hi<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></pre>\n<h2>Enlace de estilos en línea</h2><h3>Sintaxis de Objeto</h3><p>La sintaxis de objeto para <code>v-bind:style</code> es muy sencilla - es similar a CSS, excepto que es un objeto JavaScript. Puede usar tanto camelCase como kebab-case (use comillas con kebab-case) para los nombres de propiedades CSS:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:style</span>=<span class=\"string\">\"{ color: activeColor, fontSize: fontSize + 'px' }\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre>data: {\n  activeColor: <span class=\"string\">'red'</span>,\n  fontSize: <span class=\"number\">30</span>\n}</span></pre>\n<p>A menudo es una buena idea enlazar directamente un objeto de estilo para que la plantilla sea más limpia:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:style</span>=<span class=\"string\">\"styleObject\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre>data: {\n  styleObject: {\n    color: <span class=\"string\">'red'</span>,\n    fontSize: <span class=\"string\">'13px'</span>\n  }\n}</span></pre>\n<p>Nuevamente, la sintaxis de objeto es a menudo usada en conjunción con propiedades computadas que retornan objetos.</p>\n<h3>Sintaxis de Array</h3><p>La sintaxis de array <code>v-bind:style</code> permite aplicar múltiples objetos de estilo al mismo elemento:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:style</span>=<span class=\"string\">\"[baseStyles, overridingStyles]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<h3>Auto-prefijado</h3><p>Cuando utilice una propiedad CSS que requiera <span class=\"link\">prefijos de proveedores</span> en <code>v-bind:style</code>, como por ejemplo <code>transform</code>, Vue detectará automaticamente y agregará los prefijos correspondientes a los estilos aplicados.</p>\n<h3>Valores múltiples</h3><blockquote>\n<p>2.3.0+</p>\n</blockquote>\n<p>Desde la versión 2.3.0+ usted puede proveer un array de valores múltiples (de prefijos) a una propiedad de estilo, por ejemplo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:style</span>=<span class=\"string\">\"{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Esto solo renderizará el ultimo valor en el array que el navegador soporte. En este ejemplo, se renderizará <code>display: flex</code> para los navegadores que soportan la versión sin prefijo de flexbox.</p>"
  },
  {
    "title": "Renderización Condicional",
    "contenido":  ""
  },
  {
    "title": "Renderizado de lista",
    "contenido":  ""
  },
  {
    "title": "Manejo de eventos",
    "contenido":  ""
  },
  {
    "title": "Binding en Formularios",
    "contenido":  ""
  },
  {
    "title": "Conceptos Básicos de Componentes",
    "contenido":  ""
  }
]