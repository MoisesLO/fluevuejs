[
  {
    "title": "instalacion",
    "contenido":  "<h1>Instalación</h1>\n<h3>Nota de compatibilidad</h3><p>Vue <strong>no</strong> es compatible con IE8 y versiones anteriores, ya que utiliza las características de ECMAScript 5 que son incompatibles en IE8. Sin embargo, admite todos los <span class=\"link\">navegadores compatibles con ECMAScript 5</span>.</p>\n<h3>Notas de lanzamiento</h3><p>Última versión estable: 2.5.16</p>\n<p>Las notas de lanzamiento detalladas para cada versión están disponibles en <span class=\"link\">GitHub</span>.</p>\n<h2>Vue Devtools</h2><p>Cuando use Vue, le recomendamos que también instale <span class=\"link\">Vue Devtools</span> en su navegador, lo que le permite inspeccionar y depurar sus aplicaciones de Vue de una manera más amigable.</p>\n<h2>Inclusión Directa con <code>&lt;script&gt;</code></h2><p>Simplemente descargue e incluya la etiqueta <em>script</em> con la ruta correcta. <code>Vue</code> será registrado como una variable global.</p>\n<p class=\"tip\">No utilice la versión minificada (de producción) durante el desarrollo. Usted perderá todas las advertencias interesantes para los errores más comunes!</p>\n<span class=\"link\">Versión de Desarrollo</span><span class=\"light info\">Mensajes de error completos y modo de depuración</span>\n<span class=\"link\">Versión de Producción</span><span class=\"light info\">Sin mensajes de error, 30.90KB min+gzip</span>\n<h3>CDN</h3><p>Es recomendable vincular a un número específico de versión que pueda actualizar manualmente:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></pre>\n<p>Puede examinar el código fuente del paquete NPM en <span class=\"link\">cdn.jsdelivr.net/npm/vue</span>.</p>\n<p>Vue también está disponible en <span class=\"link\">unpkg</span> y <span class=\"link\">cdnjs</span> (cdnjs tarda un poco en sincronizarse, por lo que es posible que la última versión aún no esté disponible).</p>\n<p>Asegúrese de leer acerca de <span class=\"link\">las diferentes compilaciones de Vue</span> y use la <strong>versión de producción</strong> en su sitio publicado, reemplazando <code>vue.js</code> con <code>vue.min.js</code>. Esta es una versión más pequeña optimizada para la velocidad en lugar de la experiencia de desarrollo.</p>\n<h2>NPM</h2><p>NPM es el método de instalación recomendado para construir aplicaciones a gran escala con Vue. Este combina perfectamente con empaquetadores de módulos, tales como <span class=\"link\">Webpack</span> o <span class=\"link\">Browserify</span>. Vue también ofrece herramientas para la creación de componentes de un solo archivo (en inglés <span class=\"link\">Single-File Components</span>).</p>\n<pre><span class=\"comment\"># latest stable</span>\n$ npm install vue</pre>\n<h2>CLI</h2><p>Vue proporciona un <span class=\"link\">CLI oficial</span> para rapidamente construir ambiciosas <em>Single Page Applications</em>. Proporciona configuraciones de <em>build</em> prontas para un proceso de trabajo de <em>front-end</em> moderno. Sólo tarda unos minutos para estar listo y ejecutándose con <em>hot-reload</em>, <em>lint</em> al guardar cambios y empaquetado listo para la distribución en producción. Consulte <span class=\"link\">los documentos de Vue CLI</span> para obtener más detalles.</p>\n<p class=\"tip\">Este tema presupone conocimiento previo en Node.js y herramientas de <em>build</em> asociadas. Si usted es nuevo en Vue o en este tipo de herramienta, le recomendamos encarecidamente que pase por toda <span class=\"link\">la guía</span> antes de intentar utilizar el CLI.</p>\n<h2>Explicación de las Diferentes Compilaciones</h2><p>En el <span class=\"link\">directorio <code>dist/</code> del paquete NPM</span> usted encontrará muchas compilaciones o distribuciones diferentes de Vue.js. Una descripción de la diferencia entre ellas:</p>\n<table>\n  <thead>\n  <tr>\n    <th></th>\n    <th>UMD</th>\n    <th>CommonJS</th>\n    <th>ES Module</th>\n  </tr>\n  </thead>\n  <tbody>\n  <tr>\n    <td><strong>Completa</strong></td>\n    <td>vue.js</td>\n    <td>vue.common.js</td>\n    <td>vue.esm.js</td>\n  </tr>\n  <tr>\n    <td><strong>Runtime</strong></td>\n    <td>vue.runtime.js</td>\n    <td>vue.runtime.common.js</td>\n    <td>vue.runtime.esm.js</td>\n  </tr>\n  <tr>\n    <td><strong>Completa (producción)</strong></td>\n    <td>vue.min.js</td>\n    <td>-</td>\n    <td>-</td>\n  </tr>\n  <tr>\n    <td><strong>Runtime (producción)</strong></td>\n    <td>vue.runtime.min.js</td>\n    <td>-</td>\n    <td>-</td>\n  </tr>\n  </tbody>\n</table>\n<h3>Términos</h3><ul>\n  <li><p><strong>Completa</strong>: compilaciones que contienen tanto el compilador como el motor de tiempo de ejecución (en inglés, <em>runtime</em>).</p>\n  </li>\n  <li><p><strong>Compilador</strong>: código que es responsable de compilar <em>template strings</em> en las funciones de <em>render</em> de JavaScript.</p>\n  </li>\n  <li><p><strong>Runtime</strong>: código que es responsable de crear instancias de Vue, renderizado y actualización del DOM virtual, etc. Básicamente todo menos el compilador.</p>\n  </li>\n  <li><p><strong><span class=\"link\">UMD</span></strong>: las compilaciones UMD se pueden utilizar directamente en el navegador a través de un tag <code>&lt;script&gt;</code>. El archivo predeterminado de jsDelivr CDN en <span class=\"link\">https://cdn.jsdelivr.net/npm/vue</span> es la distribución Compilador + Runtime en formato UMD (<code>vue.js</code>).</p>\n  </li>\n  <li><p><strong><span class=\"link\">CommonJS</span></strong>: formato destinado a empaquetadores antiguos como <span class=\"link\">browserify</span> or <span class=\"link\">webpack 1</span>. El archivo predeterminado para estos empaquetadores (<code>pkg.main</code>) es la distribución Runtime en formato CommonJS (<code>vue.runtime.common.js</code>).</p>\n  </li>\n  <li><p><strong><span class=\"link\">ES Module</span></strong>: formato de módulos ECMAScript destinado a empaquetadores modernos como <span class=\"link\">webpack 2</span> o <span class=\"link\">rollup</span>. El archivo predeterminado para estos empaquetadores (<code>pkg.module</code>) es la distribución Runtime en formato ES Module (<code>vue.runtime.esm.js</code>).</p>\n  </li>\n</ul>\n<h3>Runtime + Compilador vs. Runtime</h3><p>Si necesita compilar <em>templates</em> en tiempo real en el cliente (por ejemplo: pasando un <em>String</em> en la opción <code>template</code>, o usando elementos preexistentes en el DOM a través del HTML como <em>template</em>), necesitará el compilador y por lo tanto la distribución completa:</p>\n<pre><span class=\"comment\">// esto requiere el compilador</span>\n<span class=\"keyword\">new</span> Vue({\n  template: <span class=\"string\">'&lt;div&gt;{{ hi }}&lt;/div&gt;'</span>\n})\n\n<span class=\"comment\">// esto no</span>\n<span class=\"keyword\">new</span> Vue({\n  render (h) {\n    <span class=\"keyword\">return</span> h(<span class=\"string\">'div'</span>, <span class=\"keyword\">this</span>.hi)\n  }\n})</pre>\n<p>Cuando se usa <code>vue-loader</code> o <code>vueify</code>, los <em>templates</em> dentro de los archivos <code>*.vue</code> se compilan previamente en JavaScript en el momento de la compilación. Realmente no necesita el compilador en el paquete final y, por lo tanto, puede usar la distribución Runtime.</p>\n<p>Dado que las distribuciones solo con el código de Runtime son aproximadamente un 30% más ligeras que las distribuciones completas, debe usarlas siempre que pueda. Si aún desea utilizar la distribución completa, debe configurar un alias en su empaquetador:</p>\n<h4 id=\"Webpack\"><span class=\"link\"></span>Webpack</h4><pre><span class=\"built_in\">module</span>.exports = {\n  <span class=\"comment\">// ...</span>\n  resolve: {\n    alias: {\n      <span class=\"string\">'vue$'</span>: <span class=\"string\">'vue/dist/vue.esm.js'</span> <span class=\"comment\">// 'vue/dist/vue.common.js' para webpack 1</span>\n    }\n  }\n}</pre>\n<h4 id=\"Rollup\"><span class=\"link\"></span>Rollup</h4><pre><span class=\"keyword\">const</span> alias = <span class=\"built_in\">require</span>(<span class=\"string\">'rollup-plugin-alias'</span>)\n\nrollup({\n  <span class=\"comment\">// ...</span>\n  plugins: [\n    alias({\n      <span class=\"string\">'vue'</span>: <span class=\"string\">'vue/dist/vue.esm.js'</span>\n    })\n  ]\n})</pre>\n<h4 id=\"Browserify\"><span class=\"link\"></span>Browserify</h4><p>Agregue a su proyecto <code>package.json</code>:</p>\n<pre>{\n  <span class=\"comment\">// ...</span>\n  <span class=\"string\">\"browser\"</span>: {\n    <span class=\"string\">\"vue\"</span>: <span class=\"string\">\"vue/dist/vue.common.js\"</span>\n  }\n}</pre>\n<h4 id=\"Parcel\"><span class=\"link\"></span>Parcel</h4><p>Agregue a su proyecto  <code>package.json</code>:</p>\n<pre>{\n  <span class=\"comment\">// ...</span>\n  <span class=\"string\">\"alias\"</span>: {\n    <span class=\"string\">\"vue\"</span> : <span class=\"string\">\"./node_modules/vue/dist/vue.common.js\"</span>\n  }\n}</pre>\n<h3>Desarrollo vs. Producción</h3><p>Los modos de desarrollo/producción están codificados para las compilaciones de UMD: los archivos no minimizados son para desarrollo y los archivos minificados para producción.</p>\n<p>Las distribuciones de módulos de CommonJS y ES están destinadas a empaquetadores, por lo tanto, no proporcionamos versiones mínimas para ellos. Usted será responsable de minimizar el paquete final usted mismo.</p>\n<p>Estas distribuciones también preservan chequeos a la variable <code>process.env.NODE_ENV</code> para determinar el modo en que deben ejecutarse. Debe configurar apropiadamente su empaquetador para cambiar estas variables de entorno correctamente para controlar el modo en que Vue se ejecutará. Cambiar <code>process.env.NODE_ENV</code> usando <em>Strings</em> literales también permite que minificadores como UglifyJS eliminen completamente los bloques de código de desarrollo, reduciendo el tamaño del archivo final.</p>\n<h4 id=\"Webpack-1\"><span class=\"link\"></span>Webpack</h4><p>En Webpack 4+, puede usar la opción <code>mode</code>:</p>\n<pre><span class=\"built_in\">module</span>.exports = {\n  mode: <span class=\"string\">'production'</span>\n}</pre>\n<p>Pero en Webpack 3 y anteriores, es necesario usar <span class=\"link\">DefinePlugin</span>:</p>\n<pre><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)\n\n<span class=\"built_in\">module</span>.exports = {\n  <span class=\"comment\">// ...</span>\n  plugins: [\n    <span class=\"comment\">// ...</span>\n    <span class=\"keyword\">new</span> webpack.DefinePlugin({\n      <span class=\"string\">'process.env'</span>: {\n        NODE_ENV: <span class=\"built_in\">JSON</span>.stringify(<span class=\"string\">'production'</span>)\n      }\n    })\n  ]\n}</pre>\n<h4 id=\"Rollup-1\"><span class=\"link\"></span>Rollup</h4><p>Utilice el <span class=\"link\">rollup-plugin-replace</span>:</p>\n<pre><span class=\"keyword\">const</span> replace = <span class=\"built_in\">require</span>(<span class=\"string\">'rollup-plugin-replace'</span>)\n\nrollup({\n  <span class=\"comment\">// ...</span>\n  plugins: [\n    replace({\n      <span class=\"string\">'process.env.NODE_ENV'</span>: <span class=\"built_in\">JSON</span>.stringify(<span class=\"string\">'production'</span>)\n    })\n  ]\n}).then(...)</pre>\n<h4 id=\"Browserify-1\"><span class=\"link\"></span>Browserify</h4><p>Aplique una transformación <span class=\"link\">envify</span> global en su paquete.</p>\n<pre>NODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m &gt; build.js</pre>\n<p>Vea también <span class=\"link\">Consejos de Publicación para Producción</span>.</p>\n<h3>Ambientes CSP</h3><p>Algunos entornos, como Google Chrome Apps, aplican la Política de seguridad de contenido (CSP), que prohíbe el uso de <code>new Function()</code> para evaluar expresiones. La distribución completa depende de esta característica para compilar <em>templates</em>, por lo que no se puede utilizar en estos entornos.</p>\n<p>Por otro lado, la distribución Runtime es totalmente compatible con CSP. Cuando se utiliza la distribución Runtime con <span class=\"link\">Webpack + vue-loader</span> o <span class=\"link\">Browserify + vueify</span>, sus <em>templates</em> serán precompilados en funciones <code>render</code> que funcionan perfectamente en entornos CSP.</p>\n<h2>Compilación de Desarrollo</h2><p><strong>Importante</strong>: los archivos compilados en la carpeta <code>/dist</code> de GitHub solo se crean durante los lanzamientos de nuevas versiones. Para usar Vue desde el último código fuente de GitHub, ¡tendrás que crearlo tú mismo!</p>\n<pre>git <span class=\"built_in\">clone</span> https://github.com/vuejs/vue.git node_modules/vue\n<span class=\"built_in\">cd</span> node_modules/vue\nnpm install\nnpm run build</pre>\n<h2>Bower</h2><p>Solo las compilaciones UMD están disponibles en Bower.</p>\n<pre><span class=\"comment\"># última versión estable</span>\n$ bower install vue</pre>\n<h2>Cargadores de Módulos AMD</h2><p>Todas las compilaciones UMD se pueden utilizar directamente como un módulo AMD.</p>"
  },
  {
    "title": "Introducción",
    "contenido":  "<h1>Introducción</h1>\n<h2>¿Qué es Vue.js?</h2><p>Vue (pronunciado /vjuː/, como <strong>view</strong>) es un <strong>framework progresivo</strong> para construir interfaces de usuario. A diferencia de otros <em>frameworks</em> monolíticos, Vue está diseñado desde cero para ser utilizado incrementalmente. La librería central está enfocada solo en la capa de visualización, y es fácil de utilizar e integrar con otras librerías o proyectos existentes. Por otro lado, Vue también es perfectamente capaz de impulsar sofisticadas <em>Single-Page Applications</em> cuando se utiliza en combinación con <span class=\"link\">herramientas modernas</span> y <span class=\"link\">librerías de apoyo</span>.</p>\n<p>Si desea obtener más información sobre Vue antes de profundizar, <span class=\"link\">creamos un video</span> paseando a través de los principios básicos, con un proyecto de ejemplo.</p>\n<p>Si usted es un desarrollador frontend experimentado y desea saber cómo Vue se compara con otras librerías/frameworks, consulte la <span class=\"link\">Comparación con Otros Frameworks</span>.</p>\n<h2>Empezando</h2><p class=\"tip\">La guía oficial asume conocimientos de nivel intermedio de HTML, CSS y JavaScript. Si usted es totalmente nuevo en el desarrollo frontend, puede que no sea la mejor idea saltar directamente a un <em>framework</em> como su primer paso - ¡capte lo básico y luego vuelva! La experiencia previa con otros <em>frameworks</em> ayuda, pero no es necesaria.</p>\n<p>La forma más fácil de probar Vue.js es usando <span class=\"link\">el ejemplo Hola Mundo en JSFiddle</span>. Siéntase libre de abrirlo en otra pestaña y seguirlo mientras analizamos algunos ejemplos básicos. O puede <span class=\"link\">crear un archivo <code>index.html</code></span> e incluir Vue con:</p>\n<pre><span class=\"comment\">&lt;!-- versión de desarrollo, incluye advertencias de ayuda en la consola --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></pre>\n<p>o con:</p>\n<pre><span class=\"comment\">&lt;!-- versión de producción, optimizada para tamaño y velocidad --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdn.jsdelivr.net/npm/vue\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></pre>\n<p>La <span class=\"link\">página de instalación</span> proporciona más opciones de instalación de Vue. Nota: <strong>No</strong> recomendamos que los principiantes comiencen con <code>vue-cli</code>, especialmente si aún no están familiarizados con las herramientas de <em>build</em> basadas en Node.js.</p>\n<p>Si prefiere algo más interactivo, también puede ver <span class=\"link\">esta serie de tutoriales en Scrimba</span>, que le ofrece una combinación de <em>screencast</em> y <em>playground</em> de código con los que puede pausar y jugar en cualquier momento.</p>\n<h2>Renderización Declarativa</h2><div class=\"scrimba\"><span class=\"link\">Pruebe esta lección en Scrimba</span></div>\n<p>En el núcleo de Vue.js se encuentra un sistema que nos permite procesar datos de forma declarativa al DOM mediante una sintaxis de plantilla sencilla:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span>\n  {{ message }}\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></pre>\n<pre><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#app'</span>,\n  data: {\n    message: <span class=\"string\">'Hola Vue!'</span>\n  }\n})</pre>\n<p>¡Ya hemos creado nuestra primera aplicación Vue! Esto parece bastante similar a la representación de un <em>template string</em>, pero Vue ha hecho mucho trabajo por debajo. Los datos y el DOM ahora están vinculados, y todo ahora es <strong>reactivo</strong>. ¿Cómo sabemos? Abra la consola de JavaScript de su navegador (ahora mismo, en esta página) y cambie el valor de <code>app.message</code> a un valor diferente. Debería ver que el ejemplo se ha renderizado con el nuevo valor que acaba de ingresar.</p>\n<p>Además de la interpolación de texto, también podemos enlazar atributos de elementos como este:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app-2\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-bind:title</span>=<span class=\"string\">\"message\"</span>&gt;</span>\n    Mueva el mouse sobre mí durante unos segundos\n    para ver mi título enlazado dinámicamente.\n  <span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></pre>\n<pre><span class=\"keyword\">var</span> app2 = <span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#app-2'</span>,\n  data: {\n    message: <span class=\"string\">'Usted cargó esta página el '</span> + <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().toLocaleString()\n  }\n})</pre>\n<p>Aquí nos encontramos con algo nuevo. El atributo <code>v-bind</code> que está viendo se llama <strong>directiva</strong>. Las directivas tienen el prefijo <code>v-</code> para indicar que son atributos especiales proporcionados por Vue, y como puede haber adivinado, aplican un comportamiento reactivo especial al DOM representado. Aquí, básicamente se dice “mantener el atributo <code>title</code> de este elemento actualizado con la propiedad <code>message</code> en la instancia de Vue”.</p>\n<p>Si vuelve a abrir la consola de JavaScript e ingresa <code>app2.message = 'some new message'</code>, verá una vez más que el HTML enlazado, en este caso el atributo <code>title</code>, se ha actualizado.</p>\n<h2>Condicionales y Bucles</h2><div class=\"scrimba\"><span class=\"link\">Pruebe esta lección en Scrimba</span></div>\n<p>También es fácil alternar la presencia de un elemento:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app-3\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"seen\"</span>&gt;</span>Ahora me ves<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></pre>\n<pre><span class=\"keyword\">var</span> app3 = <span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#app-3'</span>,\n  data: {\n    seen: <span class=\"literal\">true</span>\n  }\n})</pre>\n<p>Continúa y escribe <code>app3.seen = false</code> en la consola. Deberías ver el mensaje desaparecer.</p>\n<p>Este ejemplo demuestra que podemos vincular datos no solo con el texto y los atributos, sino también con la <strong>estructura</strong> del DOM. Además, Vue también proporciona un potente sistema de efectos de transición que puede aplicar automáticamente <span class=\"link\">efectos de transición</span> cuando los elementos son insertados, actualizados o eliminados por Vue.</p>\n<p>Hay bastantes otras directivas, cada una con su propia funcionalidad especial. Por ejemplo, la directiva <code>v-for</code> se puede usar para mostrar una lista de elementos utilizando los datos de un Array:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app-4\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"todo in todos\"</span>&gt;</span>\n      {{ todo.text }}\n    <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>\n  <span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></pre>\n<pre><span class=\"keyword\">var</span> app4 = <span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#app-4'</span>,\n  data: {\n    todos: [\n      { <span class=\"attr\">text</span>: <span class=\"string\">'Aprender JavaScript'</span> },\n      { <span class=\"attr\">text</span>: <span class=\"string\">'Aprender Vue'</span> },\n      { <span class=\"attr\">text</span>: <span class=\"string\">'Construir algo increíble'</span> }\n    ]\n  }\n})</pre>\n<p>En la consola, ingrese <code>app4.todos.push ({text: 'Nuevo elemento'})</code>. Debería ver un nuevo elemento agregado a la lista.</p>\n<h2>Manejando Interacciones del Usuario</h2><div class=\"scrimba\"><span class=\"link\">Pruebe esta lección en Scrimba</span></div>\n<p>Para permitir que los usuarios interactúen con su aplicación, podemos usar la directiva <code>v-on</code> para adjuntar escuchas de eventos que invocan métodos en nuestras instancias de Vue:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app-5\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>{{ message }}<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"reverseMessage\"</span>&gt;</span>Mensaje invertido<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></pre>\n<pre><span class=\"keyword\">var</span> app5 = <span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#app-5'</span>,\n  data: {\n    message: <span class=\"string\">'Hola Vue.js!'</span>\n  },\n  methods: {\n    reverseMessage: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n      <span class=\"keyword\">this</span>.message = <span class=\"keyword\">this</span>.message.split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)\n    }\n  }\n})</pre>\n<p>Tenga en cuenta que en este método, actualizamos el estado de nuestra aplicación sin tocar el DOM: Vue maneja todas las manipulaciones del DOM y el código que usted escribe se enfoca en la lógica subyacente.</p>\n<p>Vue también proporciona la directiva <code>v-model</code> que hace que el enlace bidireccional entre los controles de los formularios y el estado de la aplicación sea muy sencilla:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app-6\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>{{ message }}<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"message\"</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></pre>\n<pre><span class=\"keyword\">var</span> app6 = <span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#app-6'</span>,\n  data: {\n    message: <span class=\"string\">'Hola Vue!'</span>\n  }\n})</pre>\n<h2>Composición con Componentes</h2><div class=\"scrimba\"><span class=\"link\">Pruebe esta lección en Scrimba</span></div>\n<p>El sistema de componentes es otro concepto importante en Vue, porque es una abstracción que nos permite crear aplicaciones a gran escala compuestas de componentes pequeños, independientes y, a menudo, reutilizables. Si lo pensamos, casi cualquier tipo de interfaz de aplicación se puede abstraer en un árbol de componentes:</p>\n<p><img src=\"/images/components.png\" alt=\"Árbol de componentes\"></p>\n<p>En Vue, un componente es esencialmente una instancia de Vue con opciones predefinidas. Registrar un componente en Vue es sencillo:</p>\n<pre><span class=\"comment\">// Define un nuevo componente llamado todo-item</span>\nVue.component(<span class=\"string\">'todo-item'</span>, {\n  template: <span class=\"string\">'&lt;li&gt;Esta es una tarea.&lt;/li&gt;'</span>\n})</pre>\n<p>Ahora puedes incluirlo en el <em>template</em> de otro componente:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span>\n  <span class=\"comment\">&lt;!-- Crea una instancia del componente todo-item --&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">todo-item</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">todo-item</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></pre>\n<p>Pero esto supondría tener el mismo texto para cada tarea, que no es muy interesante. Es posible que se pueda pasar datos de un <em>scope</em> o contexto padre a uno secundario en los componentes hijos. Modifique la configuración del componente para que acepte una <span class=\"link\">propiedad</span>:</p>\n<pre>Vue.component(<span class=\"string\">'todo-item'</span>, {\n  <span class=\"comment\">// El componente todo-item ahora acepta una</span>\n  <span class=\"comment\">// \"propiedad\", que es como un atributo personalizado.</span>\n  <span class=\"comment\">// Esta propiedad es llamada todo.</span>\n  props: [<span class=\"string\">'todo'</span>],\n  template: <span class=\"string\">'&lt;li&gt;{{ todo.text }}&lt;/li&gt;'</span>\n})</pre>\n<p>Ahora podemos pasar la tarea a cada componente repetido usando <code>v-bind</code>:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app-7\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span>\n    <span class=\"comment\">&lt;!--</span>\n<span class=\"comment\">      Ahora proporcionamos a cada todo-item con el objeto todo</span>\n<span class=\"comment\">      que representa, para que su contenido pueda ser dinámico.</span>\n<span class=\"comment\">      También necesitamos proporcionar a cada componente con una \"clave\",</span>\n<span class=\"comment\">      que vamos a explicar más adelante.</span>\n<span class=\"comment\">    --&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">todo-item</span></span>\n<span class=\"tag\">      <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in groceryList\"</span></span>\n<span class=\"tag\">      <span class=\"attr\">v-bind:todo</span>=<span class=\"string\">\"item\"</span></span>\n<span class=\"tag\">      <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"item.id\"</span>&gt;</span>\n    <span class=\"tag\">&lt;/<span class=\"name\">todo-item</span>&gt;</span>\n  <span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></pre>\n<pre>Vue.component(<span class=\"string\">'todo-item'</span>, {\n  props: [<span class=\"string\">'todo'</span>],\n  template: <span class=\"string\">'&lt;li&gt;{{ todo.text }}&lt;/li&gt;'</span>\n})\n\n<span class=\"keyword\">var</span> app7 = <span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#app-7'</span>,\n  data: {\n    groceryList: [\n      { <span class=\"attr\">id</span>: <span class=\"number\">0</span>, <span class=\"attr\">text</span>: <span class=\"string\">'Vegetales'</span> },\n      { <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">text</span>: <span class=\"string\">'Queso'</span> },\n      { <span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">text</span>: <span class=\"string\">'Cualquier otra cosa que se supone que los humanos coman'</span> }\n    ]\n  }\n})</pre>\n<p>Este es un ejemplo ficticio, pero hemos logrado separar nuestra aplicación en dos unidades más pequeñas, y el componente hijo está razonablemente bien desacoplado del componente padre a través de la interfaz de propiedades. Ahora podemos mejorar aún más nuestro componente <code>&lt;todo-item&gt;</code> con un <em>template</em> y lógica más complejas sin afectar la aplicación principal.</p>\n<p>En una aplicación grande, es necesario dividir toda la aplicación en componentes para que el desarrollo sea manejable. Hablaremos mucho más sobre los componentes <span class=\"link\">más adelante en la guía</span>, pero aquí hay un ejemplo (imaginario) de cómo se vería el <em>template</em> de una aplicación con componentes:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">app-nav</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-nav</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">app-view</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">app-sidebar</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-sidebar</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">app-content</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-content</span>&gt;</span>\n  <span class=\"tag\">&lt;/<span class=\"name\">app-view</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></pre>\n<h3>Relación con Elementos Personalizados</h3><p>Es posible que haya notado que los componentes de Vue son muy similares a <strong>Elementos personalizados</strong>, que forman parte de las <span class=\"link\">Especificaciones de Componentes Web</span>. Esto se debe a que la sintaxis de los componentes de Vue está modelada de forma flexible según la especificación. Por ejemplo, los componentes de Vue implementan la <span class=\"link\">API de Slot</span> y el atributo especial <code>is</code>. Sin embargo, hay algunas diferencias clave:</p>\n<ol>\n<li><p>La especificación de componentes web se ha finalizado, pero no se implementa de forma nativa en todos los navegadores. Safari 10.1+, Chrome 54+ y Firefox 63+ soportan de forma nativa los componentes web. En comparación, los componentes de Vue no requieren polyfills y funcionan de manera consistente en todos los navegadores compatibles (IE9 y superiores). Cuando sea necesario, los componentes de Vue también se pueden envolver dentro de un elemento personalizado nativo.</p>\n</li>\n<li><p>Los componentes de Vue proporcionan características importantes que no están disponibles en elementos personalizados sencillos, especialmente el flujo de datos de componentes cruzados, la comunicación de eventos personalizados y las integraciones de herramientas de construcción.</p>\n</li>\n</ol>\n<h2>¿Listo para más?</h2><p>Hemos presentado brevemente las funciones más básicas del núcleo de Vue.js. El resto de esta guía tratará estas y otras funciones avanzadas con detalles mucho más precisos, ¡así que asegúrese de leer todo esto!</p>\n<div id=\"video-modal\" class=\"modal\"><div class=\"video-space\" style=\"padding: 56.25% 0 0 0; position: relative;\"><iframe src=\"https://player.vimeo.com/video/247494684\" style=\"height: 100%; left: 0; position: absolute; top: 0; width: 100%; margin: 0\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\" data-vimeo-tracked=\"true\" data-ready=\"true\"></iframe></div><script src=\"https://player.vimeo.com/api/player.js\"></script></div>"
  },
  {
    "title": "La instancia Vue",
    "contenido":  "<h1>La instancia Vue</h1>\n<h2>Creando una instancia de Vue</h2><p>Cada aplicación de Vue se comienza creando una nueva <strong>Instancia de Vue</strong> con la función <code>Vue</code>:</p>\n<pre><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue({\n  <span class=\"comment\">// opciones</span>\n})</pre>\n<p>Aunque no estrictamente asociado con el <span class=\"link\">patrón MVVM</span>, el diseño de Vue fue en parte inspirado por él.\nComo una convención, solemos usar la variable <code>vm</code> (abreviación de ViewModel) para hacer referencia a nuestra instancia de Vue.</p>\n<p>Cuando usted crea una instancia de Vue, le pasa un <strong>objeto options</strong>. La mayor parte de esta guía describe cómo usted puede usar estas opciones para crear el comportamiento deseado.\nComo referencia, usted puede visitar también la lista completa de opciones en la <span class=\"link\">documentación de la API</span>.</p>\n<p>Una aplicación Vue está conformada por una <strong>instancia Vue raíz</strong> creada con <code>new Vue</code>, opcionalmente organizada dentro de un árbol de componentes reusables anidados. Por ejemplo, el árbol de una aplicación TO-DO podría verse así:</p>\n<pre>Root Instance\n└─ TodoList\n   ├─ TodoItem\n   │  ├─ DeleteTodoButton\n   │  └─ EditTodoButton\n   └─ TodoListFooter\n      ├─ ClearTodosButton\n      └─ TodoListStatistics</pre>\n<p>Hablaremos sobre <span class=\"link\">el sistema de componentes</span> en detalle después. Por ahora, solo es necesario saber que todos los componentes de Vue son también instancias de Vue, por lo tanto aceptan el mismo objeto options (excepto para unas pocas específicas opciones de raíz).</p>\n<h2>Datos y Métodos</h2><p>Cuando una instancia Vue es creada, agrega todas las propiedades encontradas en su objeto <code>data</code> al <strong>sistema de reactividad</strong> de Vue. Cuando los valores de estas propiedades cambian, la vista “reaccionará”, actualizándose para coincidir con los nuevos valores.</p>\n<pre><span class=\"comment\">// Nuestro objeto data</span>\n<span class=\"keyword\">var</span> data = { <span class=\"attr\">a</span>: <span class=\"number\">1</span> }\n\n<span class=\"comment\">// El objeto se agrega a una instancia de Vue</span>\n<span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue({\n  data: data\n})\n\n<span class=\"comment\">// Obteniendo la propiedad de la instancia</span>\n<span class=\"comment\">// retorna lo mismo que el objeto data original</span>\nvm.a == data.a <span class=\"comment\">// =&gt; true</span>\n\n<span class=\"comment\">// Asignando la propiedad en la instancia</span>\n<span class=\"comment\">// también afecta la original</span>\nvm.a = <span class=\"number\">2</span>\ndata.a <span class=\"comment\">// =&gt; 2</span>\n\n<span class=\"comment\">// ... y también a la inversa</span>\ndata.a = <span class=\"number\">3</span>\nvm.a <span class=\"comment\">// =&gt; 3</span></pre>\n<p>Cuando estos datos cambian, la vista volverá a renderizarse. Es preciso señalar que las propiedades en <code>data</code> solo son <strong>reactivas</strong> si ya existían cuando se creó la instancia. Eso significa que si usted agrega una nueva propiedad, como:</p>\n<pre>vm.b = <span class=\"string\">'hola'</span></pre>\n<p>Entonces los cambios de <code>b</code> no producirán ninguna actualización en la vista. Si sabe que necesitará una propiedad más adelante, pero comienza vacía o inexistente, necesitará setear un valor inicial. Por ejemplo:</p>\n<pre>data: {\n  newTodoText: <span class=\"string\">''</span>,\n  visitCount: <span class=\"number\">0</span>,\n  hideCompletedTodos: <span class=\"literal\">false</span>,\n  todos: [],\n  error: <span class=\"literal\">null</span>\n}</pre>\n<p>La unica excepción a esto es el uso de <code>Object.freeze()</code>, lo que evita que se modifiquen las propiedades existentes, lo que también significa que el sistema de reactividad no puede rastrear cambios.</p>\n<pre><span class=\"keyword\">var</span> obj = {\n  foo: <span class=\"string\">'bar'</span>\n}\n\n<span class=\"built_in\">Object</span>.freeze(obj)\n\n<span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#app'</span>,\n  data: obj\n})</pre>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>{{ foo }}<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n  <span class=\"comment\">&lt;!-- esto ya no actualizará `foo`! --&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"foo = 'baz'\"</span>&gt;</span>Cámbialo<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></pre>\n<p>Además de las propiedades de datos, las instancias de Vue exponen una serie de métodos y propiedades de instancia útiles. Estos tienen el prefijo <code>$</code> para diferenciarlos de las propiedades definidas por el usuario. Por ejemplo:</p>\n<pre><span class=\"keyword\">var</span> data = { <span class=\"attr\">a</span>: <span class=\"number\">1</span> }\n<span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#example'</span>,\n  data: data\n})\n\nvm.$data === data <span class=\"comment\">// =&gt; true</span>\nvm.$el === <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'example'</span>) <span class=\"comment\">// =&gt; true</span>\n\n<span class=\"comment\">// $watch es un método de instancia</span>\nvm.$watch(<span class=\"string\">'a'</span>, <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">newValue, oldValue</span>) </span>{\n  <span class=\"comment\">// Esta función será ejecutada cuando `vm.a` cambie</span>\n})</pre>\n<p>En el futuro, puede consultar la <span class=\"link\">documentación de la API</span> para una lista completa de propiedades y métodos de instancia.</p>\n<h2>Hooks del Ciclo de vida de la Instancia</h2><p>Cada instancia de Vue pasa a través de una serie de pasos de inicialización cuando es creada - por ejemplo, se necesita configurar la observación de datos, compilar la plantilla, montar la instancia en el DOM y actualizar el DOM cuando cambian los datos. En el camino, también se ejecutan funciones llamadas <strong>hooks del ciclo de vida</strong>, lo que brinda a los usuarios la oportunidad de agregar su propio código en etapas específicas.</p>\n<p>Por ejemplo, el hook <span class=\"link\"><code>created</code></span> puede ser utilizado para ejecutar código después que una instancia es creada:</p>\n<pre><span class=\"keyword\">new</span> Vue({\n  data: {\n    a: <span class=\"number\">1</span>\n  },\n  created: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n    <span class=\"comment\">// `this` hace referencia a la instancia vm</span>\n    <span class=\"built_in\">console</span>.log(<span class=\"string\">'a es: '</span> + <span class=\"keyword\">this</span>.a)\n  }\n})\n<span class=\"comment\">// =&gt; \"a es: 1\"</span></pre>\n<p>También hay otros hooks que se llamarán en diferentes etapas del ciclo de vida de la instancia, como <span class=\"link\"><code>mounted</code></span>, <span class=\"link\"><code>updated</code></span>, y <span class=\"link\"><code>destroyed</code></span>. Todos los hooks del ciclo de vida se llaman en el contexto <code>this</code> apuntando a la instancia de Vue que lo invoca.</p>\n<p class=\"tip\">No usar <span class=\"link\">arrow functions</span> en una propiedad de opciones o respuesta, como <code>created: () =&gt; console.log(this.a)</code> or <code>vm.$watch('a', newValue =&gt; this.myMethod())</code>. Dado que las arrow functions están vinculadas al contexto padre, <code>this</code> no será la instancia de Vue como lo esperaría, lo que suele producir errores, como ‘Uncaught TypeError: Cannot read property of undefined<code>o</code>Uncaught TypeError: this.myMethod is not a function`.</p>\n<h2>Diagrama del Ciclo de vida</h2><p>La imagen de abajo es un diagrama para el ciclo de vida de una instancia. No es necesario que entienda como funciona todo en este momento, pero a medida que aprenda y construya más, será una referencia útil.</p>\n<p><img src=\"asset:assets/img/lifecycle.png\" alt=\"Ciclo de vida de una Instancia de Vue\"></p>"
  },
  {
    "title": "Sintaxis de Template",
    "contenido":  "<h1>Sintaxis de Template</h1>\n<p>Vue.js utiliza una sintaxis de template basada en HTML que le permite vincular de forma declarativa el DOM renderizado a los datos de la instancia de Vue subyacente. Todas las templates de Vue.js son HTML válidas que pueden analizarse mediante navegadores compatibles con especificaciones y analizadores de HTML.</p>\n<p>Bajo el capó, Vue compila las templates en funciones de renderizado del DOM virtual. Combinado con el sistema de reactividad, Vue puede averiguar de manera inteligente el número mínimo de componentes para volver a renderizar y aplicar la cantidad mínima de manipulacion del DOM cuando el estado de la aplicacion cambia.</p>\n<p>Si está familiarizado con los conceptos de DOM virtual y prefiere la potencia bruta de JavaScript, también puede <span class=\"link\">escribir directamente funciones de procesamiento</span> en lugar de plantillas, con soporte opcional de JSX.</p>\n<h2>Interpolaciones</h2><h3>Texto</h3><p>La forma más básica de enlace de datos es la interpolación de texto usando la sintaxis de <em>mustaches</em> (llaves doble):</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Message: {{ msg }}<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></pre>\n<p>La etiqueta del <em>mustache</em> se reemplazará con el valor de la propiedad <code>msg</code> en el objeto de datos correspondiente. También se actualizará cada vez que cambie la propiedad <code>msg</code> del objeto de datos.</p>\n<p>También puede realizar interpolaciones únicas que no se actualizan en el cambio de datos usando la <span class=\"link\">directiva v-once</span>, pero tenga en cuenta que esto también afectará a cualquier otro enlace en el mismo nodo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-once</span>&gt;</span>Esto nunca cambiara: {{ msg }}<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></pre>\n<h3>HTML Puro</h3><p>Los <em>mustaches</em> (llaves doble) interpretan los datos como texto plano, no HTML. Para generar HTML real, deberá utilizar la directiva <code>v-html</code>:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Using mustaches: {{ rawHtml }}<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Using v-html directive: <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-html</span>=<span class=\"string\">\"rawHtml\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></pre>\n<p>El contenido del <code>span</code> se reemplazará con el valor de la propiedad <code>rawHtml</code>, interpretado como HTML simple: se ignoran los enlaces de datos. Tenga en cuenta que no puede utilizar <code>v-html</code> para componer plantillas parciales, porque Vue no es un motor de plantillas basado en cadenas. En cambio, se prefieren los componentes como la unidad fundamental para la reutilización y la composición de la interfaz de usuario.</p>\n<p class=\"tip\">La ejecución dinámica de HTML arbitrario en su sitio web puede ser muy peligrosa porque puede conducir fácilmente a <span class=\"link\">vulnerabilidades de XSS</span>. Utilice solo la interpolación HTML en contenido de confianza y <strong>nunca</strong> en contenido proporcionado por usuario.</p>\n<h3>Atributos</h3><p>Los <em>mustaches</em> (llaves doble) no se pueden utilizar dentro de los atributos HTML. En su lugar, use una <span class=\"link\">directiva v-bind</span>:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:id</span>=<span class=\"string\">\"dynamicId\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></pre>\n<p>En el caso de los atributos booleanos, donde su mera existencia implica <code>true</code>, <code>v-bind</code> funciona de manera un poco diferente. En este ejemplo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-bind:disabled</span>=<span class=\"string\">\"isButtonDisabled\"</span>&gt;</span>Button<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></pre>\n<p>Si <code>isButtonDisabled</code> tiene el valor de <code>null</code>, <code>undefined</code> o <code>false</code>, el atributo <code>disabled</code> ni siquiera se incluirá en el elemento <code>&lt;button&gt;</code> representado.</p>\n<h3>Usando Expresiones JavaScript</h3><p>Hasta ahora solo hemos estado vinculando a simples claves de propiedad en nuestras template. Pero Vue.js realmente admite el poder completo de las expresiones de JavaScript dentro de todos los enlaces de datos:</p>\n<pre>{{ number + 1 }}\n\n{{ ok ? 'YES' : 'NO' }}\n\n{{ message.split('').reverse().join('') }}\n\n<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:id</span>=<span class=\"string\">\"'list-' + id\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></pre>\n<p>Estas expresiones se evaluarán como JavaScript en el ámbito de datos de la instancia de Vue del propietario. Una restricción es que cada enlace solo puede contener <strong>una expresión</strong>, por lo que lo siguiente <strong>NO</strong> funcionará:</p>\n<pre><span class=\"comment\">&lt;!-- esto es una declaración, no una expresión --&gt;</span>\n{{ var a = 1 }}\n\n<span class=\"comment\">&lt;!-- El control de flujo tampoco funcionará, use expresiones ternarias --&gt;</span>\n{{ if (ok) { return message } }}</pre>\n<p class=\"tip\">Las expresiones de template están en un espacio aislado y solo tienen acceso a una lista blanca de elementos globales como <code>Matemáticas</code> y <code>Fecha</code>. No debe intentar acceder a globales definidos por el usuario en expresiones de template.</p>\n<h2>Directivas</h2><p>Las directivas son atributos especiales con el prefijo <code>v-</code>. Se espera que los valores de atributo de la directiva sean <strong>una única expresión de JavaScript</strong> (con la excepción de <code>v-for</code>, que se tratará más adelante). El trabajo de una directiva es aplicar reactivamente efectos secundarios al DOM cuando cambia el valor de su expresión. Repasemos el ejemplo que vimos en la introducción:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"seen\"</span>&gt;</span>Now you see me<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></pre>\n<p>Aquí, la directiva <code>v-if</code> insertaría/eliminaría el elemento </p><p> basándose en la veracidad del valor de la expresión <code>seen</code>.</p>\n<h3>Argumentos</h3><p>Algunas directivas pueden tomar un “argumento”, denotado por dos puntos después del nombre de la directiva. Por ejemplo, la directiva <code>v-bind</code> se usa para actualizar de forma reactiva un atributo HTML:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-bind:href</span>=<span class=\"string\">\"url\"</span>&gt;</span> ... <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></pre>\n<p>Aquí href es el argumento, que le dice a la directiva <code>v-bind</code> que vincule el atributo <code>href</code> del elemento al valor de la expresión <code>url</code>.</p>\n<p>Otro ejemplo es la directiva <code>v-on</code>, que escucha los eventos DOM:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"doSomething\"</span>&gt;</span> ... <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></pre>\n<p>Aquí el argumento es el nombre del evento a escuchar. Hablaremos sobre el manejo de eventos con más detalle también.</p>\n<h3>Modificadores</h3><p>Los modificadores son sufijos especiales indicados por un punto, que indican que una directiva debe estar vinculada de alguna manera especial. Por ejemplo, el modificador <code>.prevent</code> le dice a la directiva <code>v-on</code> que llame a <code>event.preventDefault()</code> en el evento activado:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">v-on:submit.prevent</span>=<span class=\"string\">\"onSubmit\"</span>&gt;</span> ... <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></pre>\n<p>Más adelante veremos otros ejemplos de modificadores, <span class=\"link\">para <code>v-on</code></span> y <span class=\"link\">para <code>v-model</code></span>, cuando exploremos esas características.</p>\n<h2>Modo abreviado</h2><p>El prefijo <code>v-</code> sirve como una señal visual para identificar atributos específicos de Vue en sus templates. Esto es útil cuando está utilizando Vue.js para aplicar un comportamiento dinámico a algún marcado existente, pero puede sentirse detallado para algunas directivas de uso frecuente. Al mismo tiempo, la necesidad del prefijo <code>v-</code> es menos importante cuando se está construyendo un <span class=\"link\">SPA</span> donde Vue.js administra cada template. Por lo tanto, Vue.js proporciona abreviaturas especiales para dos de las directivas más utilizadas, <code>v-bind</code> y <code>v-on</code>:</p>\n<h3><code>v-bind</code> Abreviado</h3><pre><span class=\"comment\">&lt;!-- full syntax --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-bind:href</span>=<span class=\"string\">\"url\"</span>&gt;</span> ... <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- abreviado --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">:href</span>=<span class=\"string\">\"url\"</span>&gt;</span> ... <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></pre>\n<h3><code>v-on</code> Abreviado</h3><pre><span class=\"comment\">&lt;!-- full syntax --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"doSomething\"</span>&gt;</span> ... <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- abreviado --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">a</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"doSomething\"</span>&gt;</span> ... <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></pre>\n<p>Pueden parecer un poco diferentes del HTML normal, pero <code>:</code> y <code>@</code> son caracteres válidos para los nombres de atributos y todos los navegadores compatibles con Vue.js pueden analizarlo correctamente. Además, no aparecen en el marcado final renderizado. La sintaxis abreviada es totalmente opcional, pero es probable que la aprecie cuando sepa más sobre su uso más adelante.</p>"
  },
  {
    "title": "Propiedades Computadas y Observadores",
    "contenido":  "<h1>Propiedades Computadas y Observadores</h1>\n<h2>Propiedades Computadas</h2><p>Las expresiones en el <em>template</em> son muy convenientes, pero están diseñadas para operaciones simples. Poner demasiada lógica en sus <em>templates</em> puede hacerlos grandes, complejos y difíciles de mantener. Por ejemplo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example\"</span>&gt;</span>\n  {{ message.split('').reverse().join('') }}\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></pre>\n<p>En este punto, el <em>template</em> ya no es simple y declarativo. Debe mirarlo por un segundo antes de darse cuenta de que muestra <code>message</code> al revés. El problema se agrava cuando desea incluir el mensaje invertido en su <em>template</em> más de una vez.</p>\n<p>Es por eso que para cualquier lógica compleja, deberia usar una <strong>propiedad computada</strong>.</p>\n<h3>Ejemplo Básico</h3><pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Mensaje original: \"{{ message }}\"<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Mensaje invertido computado: \"{{ reversedMessage }}\"<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></pre>\n<pre><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#example'</span>,\n  data: {\n    message: <span class=\"string\">'Hola'</span>\n  },\n  computed: {\n    <span class=\"comment\">// un getter computado</span>\n    reversedMessage: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n      <span class=\"comment\">// `this` apunta a la instancia vm</span>\n      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.message.split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)\n    }\n  }\n})</pre>\n<p>Aquí hemos declarado una propiedad computada <code>reversedMessage</code>. La función que\nproporcionemos se utilizará como la función getter para la propiedad <code>vm.reversedMessage</code>:</p>\n<pre><span class=\"built_in\">console</span>.log(vm.reversedMessage) <span class=\"comment\">// =&gt; 'aloH'</span>\nvm.message = <span class=\"string\">'Adios'</span>\n<span class=\"built_in\">console</span>.log(vm.reversedMessage) <span class=\"comment\">// =&gt; 'soidA'</span></pre>\n<p>Puede abrir la consola y jugar con el ejemplo vm usted mismo. El valor de <code>vm.reversedMessage</code> siempre depende del valor de <code>vm.message</code>.</p>\n<p>Puede enlazar datos a propiedades computadas en el <em>template</em> al igual que una propiedad normal. Vue es consciente de que <code>vm.reversedMessage</code> depende de <code>vm.message</code>, por lo cual actualizará todos los enlaces que dependan de <code>vm.reversedMessage</code> cuando <code>vm.message</code> cambie. Y lo mejor de todo es que hemos creado esta relación de dependencia de manera declarativa: la función computada getter no tiene efectos secundarios, lo que facilita la prueba y la comprensión.</p>\n<h3>Caching computado vs Métodos</h3><p>Es posible que haya notado que podemos lograr el mismo resultado al invocar un método en la expresión:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Mensaje Invertido: \"{{ reverseMessage() }}\"<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></pre>\n<pre><span class=\"comment\">// en componente</span>\nmethods: {\n  reverseMessage: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.message.split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)\n  }\n}</pre>\n<p>En lugar de una propiedad computada, podemos definir la misma función como un método en su lugar. Para el resultado final, los dos enfoques son exactamente los mismos. Sin embargo, la diferencia es que las <strong>propiedades computadas se almacenan en caché según sus dependencias.</strong> Una propiedad computada solo se volverá a evaluar cuando alguna de sus dependencias haya cambiado. Esto significa que mientras <code>message</code> no haya cambiado, el acceso múltiple a la propiedad computada de <code>reverseMessage</code> regresará inmediatamente el resultado previamente calculado sin tener que ejecutar la función de nuevo.</p>\n<p>Esto también significa que la siguiente propiedad computada nunca se actualizará, porque <code>Date.now()</code> no es una dependencia reactiva:</p>\n<pre>computed: {\n  now: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n    <span class=\"keyword\">return</span> <span class=\"built_in\">Date</span>.now()\n  }\n}</pre>\n<p>En comparación, una invocación de método <strong>siempre</strong> ejecutará la función cada vez que ocurre una re-renderizacion.</p>\n<p>¿Por qué necesitamos caché? Imagina que tenemos una costosa propiedad computada <strong>A</strong>, que requiere hacer un bucle a través de una gran matriz y hace muchos cálculos. Entonces podemos tener otras propiedades computadas que a su vez dependen de <strong>A</strong>. Sin caché, estaríamos ejecutando el captador de <strong>A</strong> muchas veces más de lo necesario. En los casos en que no desee el almacenamiento en caché, utilice un método en su lugar.</p>\n<h3>Propiedad Computada vs Watched</h3><p>Vue proporciona una forma más genérica de observar y reaccionar a los cambios de datos en una instancia de Vue: <strong>propiedad watch</strong>. Cuando tiene algunos datos que necesitan cambiarse en función de otros datos, es tentador utilizar <code>watch</code> en exceso, especialmente si proviene de tener experiencia en AngularJS. Sin embargo, a menudo es una mejor idea usar una propiedad computada en lugar de una imperativa llamada a <code>watch</code> . Considera este ejemplo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"demo\"</span>&gt;</span>{{ fullName }}<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></pre>\n<pre><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#demo'</span>,\n  data: {\n    firstName: <span class=\"string\">'Foo'</span>,\n    lastName: <span class=\"string\">'Bar'</span>,\n    fullName: <span class=\"string\">'Foo Bar'</span>\n  },\n  watch: {\n    firstName: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">val</span>) </span>{\n      <span class=\"keyword\">this</span>.fullName = val + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.lastName\n    },\n    lastName: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">val</span>) </span>{\n      <span class=\"keyword\">this</span>.fullName = <span class=\"keyword\">this</span>.firstName + <span class=\"string\">' '</span> + val\n    }\n  }\n})</pre>\n<p>El código anterior es imperativo y repetitivo. Compáralo con una versión de propiedad computada:</p>\n<pre><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#demo'</span>,\n  data: {\n    firstName: <span class=\"string\">'Foo'</span>,\n    lastName: <span class=\"string\">'Bar'</span>\n  },\n  computed: {\n    fullName: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstName + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.lastName\n    }\n  }\n})</pre>\n<p>Mucho mejor, ¿no?</p>\n<h3>Setter Computado</h3><p>Las propiedades computadas son, de forma predeterminada solo get, pero también puede proporcionar un set cuando lo necesite:</p>\n<pre><span class=\"comment\">// ...</span>\ncomputed: {\n  fullName: {\n    <span class=\"comment\">// getter</span>\n    get: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstName + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.lastName\n    },\n    <span class=\"comment\">// setter</span>\n    set: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">newValue</span>) </span>{\n      <span class=\"keyword\">var</span> names = newValue.split(<span class=\"string\">' '</span>)\n      <span class=\"keyword\">this</span>.firstName = names[<span class=\"number\">0</span>]\n      <span class=\"keyword\">this</span>.lastName = names[names.length - <span class=\"number\">1</span>]\n    }\n  }\n}\n<span class=\"comment\">// ...</span></pre>\n<p>Ahora, cuando ejecute <code>vm.fullName = 'John Doe'</code>, se invocará el definidor y <code>vm.firstName</code> y <code>vm.lastName</code> se actualizarán en consecuencia.</p>\n<h2>Watchers</h2><p>Si bien las propiedades computadas son más apropiadas en la mayoría de los casos, hay ocasiones en que es necesario un observador personalizado. Es por eso que Vue proporciona una forma más genérica de reaccionar a los cambios de datos a través de la opción <code>watch</code>. Esto es más útil cuando desea realizar operaciones asíncronas o costosas en respuesta al cambio de datos.</p>\n<p>por ejemplo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"watch-example\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>\n    Haz una pregunta de sí/no:\n    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"question\"</span>&gt;</span>\n  <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>{{ answer }}<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></pre>\n<pre>\nvar watchExampleVM = new Vue({\n  el: '#watch-example',\n  data: {\n    question: '',\n    answer: 'No puedo darte una respuesta hasta que hagas una pregunta!!'\n  },\n  watch: {\n    question: function (newQuestion, oldQuestion) {\n      this.answer = 'Esperando que deje de escribir......'\n      this.debouncedGetAnswer()\n    }\n  },\n  created: function () {\n    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)\n  },\n  methods: {\n    getAnswer:  function () {\n      if (this.question.indexOf('?') === -1) {\n        this.answer = 'Las preguntas suelen contener un signo de interrogación. ;-)'\n        return\n      }\n      this.answer = 'Pensando...'\n      var vm = this\n      axios.get('https://yesno.wtf/api')\n        .then(function (response) {\n          vm.answer = _.capitalize(response.data.answer)\n        })\n        .catch(function (error) {\n          vm.answer = '¡Error! No se pudo alcanzar la API. ' + error\n        })\n    }\n  }\n})\n</pre>\n<p>En este caso, el uso de la opción <code>watch</code> nos permite realizar una operación asíncrona (acceder a una API), limita la frecuencia con la que realizamos esa operación y establece estados intermedios hasta que obtengamos una respuesta final. Nada de eso sería posible con una propiedad computada.</p>\n<p>Además de la opción <code>watch</code>, también puede usar el imperativo <span class=\"link\">vm.$Watch API</span>.</p>"
  },
  {
    "title": "Enlace Clases y Estilos",
    "contenido":  "<h1>Enlace Clases y Estilos</h1>\n<p>Una necesidad común de data binding es manipular la lista de clases de un elemento y sus estilos en línea. Como ambos son atributos, podemos usar <code>v-bind</code> para manejarlos: solo necesitamos crear una cadena de texto con nuestras expresiones. Sin embargo, concatenar cadenas de texto puede llegar a ser incómodo y propenso a errores. Por esta razón, Vue proporciona mejoras cuando se utiliza <code>v-bind</code> con<code>class</code> y <code>style</code>. Además de las cadenas de texto, las expresiones también pueden evaluar objetos o matrices.</p>\n<h2>Enlace de clases HTML</h2><h3>Sintaxis de Objeto</h3><p>Podemos pasar un objeto a <code>v-bind:class</code> para la asignación dinámica de clases:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"{ active: isActive }\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>La sintaxis de arriba tiene como resultado la clase <code>active</code> según el valor booleano(<span class=\"link\">https://developer.mozilla.org/en-US/docs/Glossary/Truthy</span>) de la propiedad <code>isActive</code>.</p>\n<p>Puede hacer multiple asignación de clases al tener más campos en el objeto. Además, la directiva <code>v-bind:class</code> también puede ser utilizada con el atributo <code>class</code>. De modo que con la siguiente plantilla:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"static\"</span></span>\n<span class=\"tag\">     <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"{ active: isActive, 'text-danger': hasError }\"</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Y el siguiente objeto <code>data</code>:</p>\n<pre>data: {\n  isActive: <span class=\"literal\">true</span>,\n  hasError: <span class=\"literal\">false</span>\n}</span></pre>\n<p>Se renderizará:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"static active\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Cuando <code>isActive</code> o <code>hasError</code> cambien, la lista de clases se actualizará consecuentemente. Por ejemplo, si <code>hasError</code> se convierte en <code>true</code>, la lista de clases se convertirá en <code>\"static active text-danger\"</code>.</p>\n<p>El objeto no tiene por qué estar en la misma línea:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"classObject\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre>data: {\n  classObject: {\n    active: <span class=\"literal\">true</span>,\n    <span class=\"string\">'text-danger'</span>: <span class=\"literal\">false</span>\n  }\n}</span></pre>\n<p>Esto renderizará el mismo resultado. También podemos enlazar una <span class=\"link\">propiedad computada</span> que retorna un objeto. Esto es un patrón común y poderoso:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"classObject\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre>data: {\n  isActive: <span class=\"literal\">true</span>,\n  error: <span class=\"literal\">null</span>\n},\ncomputed: {\n  classObject: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n    <span class=\"keyword\">return</span> {\n      active: <span class=\"keyword\">this</span>.isActive &amp;&amp; !<span class=\"keyword\">this</span>.error,\n      <span class=\"string\">'text-danger'</span>: <span class=\"keyword\">this</span>.error &amp;&amp; <span class=\"keyword\">this</span>.error.type === <span class=\"string\">'fatal'</span>\n    }\n  }\n}</span></pre>\n<h3>Sintaxis de Array</h3><p>Pasamos un array a <code>v-bind:class</code> para aplicar una lista de clases:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"[activeClass, errorClass]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre>data: {\n  activeClass: <span class=\"string\">'active'</span>,\n  errorClass: <span class=\"string\">'text-danger'</span>\n}</span></pre>\n<p>Que renderizará:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"active text-danger\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Si le gustaría activar una clase en la lista de manera condicional, usted puede hacerlo con una expresión ternaria:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"[isActive ? activeClass : '', errorClass]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Esto siempre aplicará <code>errorClass</code>, pero solo aplicará <code>activeClass</code> cuando <code>isActive</code> sea verdadero.</p>\n<p>Sin embargo, esto puede ser un poco verborrágico si usted tiene multiple clases condicionales. Por eso también es posible utilizar la sintaxis de objeto dentro de la sintaxis de colección:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"[{ active: isActive }, errorClass]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<h3>Con Componentes</h3><blockquote>\n<p>Esta sección asume que usted tiene conocimientos sobre <span class=\"link\">Componentes de Vue</span>. Siéntase libre de saltársela y volver más tarde.</p>\n</blockquote>\n<p>Cuando usa el atributo <code>class</code> en un componente personalizado, estas clases se agregarán al elemento raíz del componente. Las clases existentes en este elemento no serán sobreescritas.</p>\n<p>Por ejemplo, si declara este componente:</p>\n<pre>Vue.component(<span class=\"string\">'my-component'</span>, {\n  template: <span class=\"string\">'&lt;p class=\"foo bar\"&gt;Hi&lt;/p&gt;'</span>\n})</span></pre>\n<p>Y agrega algunas clases al usarlo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">class</span>=<span class=\"string\">\"baz boo\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span></pre>\n<p>El HTML renderizado será:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"foo bar baz boo\"</span>&gt;</span>Hi<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></pre>\n<p>Lo mismo aplica para el enlace de clases:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">\"{ active: isActive }\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span></pre>\n<p>Cuando <code>isActive</code> es verdadero, el HTML renderizado será:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"foo bar active\"</span>&gt;</span>Hi<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></pre>\n<h2>Enlace de estilos en línea</h2><h3>Sintaxis de Objeto</h3><p>La sintaxis de objeto para <code>v-bind:style</code> es muy sencilla - es similar a CSS, excepto que es un objeto JavaScript. Puede usar tanto camelCase como kebab-case (use comillas con kebab-case) para los nombres de propiedades CSS:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:style</span>=<span class=\"string\">\"{ color: activeColor, fontSize: fontSize + 'px' }\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre>data: {\n  activeColor: <span class=\"string\">'red'</span>,\n  fontSize: <span class=\"number\">30</span>\n}</span></pre>\n<p>A menudo es una buena idea enlazar directamente un objeto de estilo para que la plantilla sea más limpia:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:style</span>=<span class=\"string\">\"styleObject\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre>data: {\n  styleObject: {\n    color: <span class=\"string\">'red'</span>,\n    fontSize: <span class=\"string\">'13px'</span>\n  }\n}</span></pre>\n<p>Nuevamente, la sintaxis de objeto es a menudo usada en conjunción con propiedades computadas que retornan objetos.</p>\n<h3>Sintaxis de Array</h3><p>La sintaxis de array <code>v-bind:style</code> permite aplicar múltiples objetos de estilo al mismo elemento:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:style</span>=<span class=\"string\">\"[baseStyles, overridingStyles]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<h3>Auto-prefijado</h3><p>Cuando utilice una propiedad CSS que requiera <span class=\"link\">prefijos de proveedores</span> en <code>v-bind:style</code>, como por ejemplo <code>transform</code>, Vue detectará automaticamente y agregará los prefijos correspondientes a los estilos aplicados.</p>\n<h3>Valores múltiples</h3><blockquote>\n<p>2.3.0+</p>\n</blockquote>\n<p>Desde la versión 2.3.0+ usted puede proveer un array de valores múltiples (de prefijos) a una propiedad de estilo, por ejemplo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:style</span>=<span class=\"string\">\"{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Esto solo renderizará el ultimo valor en el array que el navegador soporte. En este ejemplo, se renderizará <code>display: flex</code> para los navegadores que soportan la versión sin prefijo de flexbox.</p>"
  },
  {
    "title": "Renderización Condicional",
    "contenido":  "<h1>Renderización Condicional</h1>\n<h2><code>v-if</code></h2><p>En los <em>string templates</em>, como por ejemplo, Handlebars, escribiríamos un bloque condicional como este:</p>\n<pre><span class=\"comment\">&lt;!-- template de Handlebars --&gt;</span>\n{{#if ok}}\n  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Sí<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span>\n{{/if}}</span></pre>\n<p>En Vue, usamos la directiva <code>v-if</code> para lograr lo mismo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"ok\"</span>&gt;</span>Sí<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></pre>\n<p>También es posible agregar un “bloque <em>else</em>“ con <code>v-else</code>:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"ok\"</span>&gt;</span>Sí<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">v-else</span>&gt;</span>No<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></pre>\n<h3>\" data-scroll=\"\">Grupos Condicionales con <code>v-if</code> en <code>&lt;template&gt;</code></h3><p>Debido a que <code>v-if</code> es una directiva, debe adjuntarse a un solo elemento. Pero, ¿y si queremos cambiar más de un elemento? En este caso, podemos usar <code>v-if</code> en un elemento<code>&lt;template&gt;</code>, que sirve como un envoltorio invisible. El resultado final procesado no incluirá el elemento <code>&lt;template&gt;</code>.</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"ok\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Título<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Párrafo 1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Párrafo 2<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span></pre>\n<h3><code>v-else</code></h3><p>Puede usar la directiva <code>v-else</code> para indicar un “bloque <em>else</em>“ para <code>v-if</code>:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"Math.random() &gt; 0.5\"</span>&gt;</span>\n  Ahora me ves\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else</span>&gt;</span>\n  Ahora no\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Un elemento <code>v-else</code> debe seguir inmediatamente a un elemento <code>v-if</code> o <code>v-else-if</code>, de lo contrario, no será reconocido.</p>\n<h3><code>v-else-if</code></h3><blockquote>\n<p>Nuevo en 2.1.0+</p>\n</blockquote>\n<p>El <code>v-else-if</code>, como su nombre lo indica, sirve como “bloque <em>else if</em>“ para <code>v-if</code>. También puede ser encadenado varias veces:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"type === 'A'\"</span>&gt;</span>\n  A\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else-if</span>=<span class=\"string\">\"type === 'B'\"</span>&gt;</span>\n  B\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else-if</span>=<span class=\"string\">\"type === 'C'\"</span>&gt;</span>\n  C\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else</span>&gt;</span>\n  Si no es A, B o C\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Similar a <code>v-else</code>, un elemento<code>v-else-if</code> debe seguir inmediatamente a un elemento <code>v-if</code> o <code>v-else-if</code>.</p>\n<h3>Controlando Elementos Reutilizables con <code>key</code></h3><p>Vue intenta representar los elementos de la manera más eficiente posible, a menudo reutilizándolos en lugar de renderizarlos desde cero. Más allá de ayudar a hacer Vue muy rápido, esto puede tener algunas ventajas útiles. Por ejemplo, si permite a los usuarios alternar entre varios tipos de inicio de sesión:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"loginType === 'username'\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>Nombre de Usuario<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Ingrese su nombre de usuario\"</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-else</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>Email<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Ingrese su email\"</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span></pre>\n<p>Luego, cambiando el <code>loginType</code> en el código anterior no borrará lo que el usuario ya ha ingresado. Dado que ambos <em>templates</em> utilizan los mismos elementos, el <code>&lt;input&gt;</code> no se reemplaza, solo su <code>placeholder</code>.</p>\n<p>Sin embargo, esto no siempre es deseable, por lo que Vue le ofrece una manera de decir: “Estos dos elementos están completamente separados, no los reutilice”. Agregue un atributo <code>key</code> con valores únicos:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"loginType === 'username'\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>Nombre de Usuario<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Ingrese su nombre de usuario\"</span> <span class=\"attr\">key</span>=<span class=\"string\">\"username-input\"</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-else</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>Email<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Ingrese su nombre de usuario\"</span> <span class=\"attr\">key</span>=<span class=\"string\">\"email-input\"</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span></pre>\n<p>Ahora estas entradas se procesarán desde cero cada vez que presione alternar. Ver por ti mismo:</p>\n<p>Observe que los elementos <code>&lt;label&gt;</code> son todavía reutilizables, porque no tienen atributos <code>key</code>.</p>\n<h2><code>v-show</code></h2><p>Otra opción para mostrar un elemento condicionalmente es la directiva <code>v-show</code>. La utlización es basicamente la mismo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">v-show</span>=<span class=\"string\">\"ok\"</span>&gt;</span>Hola!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></pre>\n<p>La diferencia es que un elemento con <code>v-show</code> siempre se renderizará y permanecerá en el DOM; <code>v-show</code> simplemente alterna la propiedad CSS <code>display</code> del elemento.</p>\n<p class=\"tip\">Observe que el uso de <code>v-show</code> no es compatible con elementos <code>&lt;template&gt;</code>, ni tampoco funciona con <code>v-else</code>.</p>\n<h2><code>v-if</code> vs <code>v-show</code></h2><p><code>v-if</code> es una renderización condicional “real” ya que garantiza que los eventos y componentes secundarios dentro del bloque condicional sean debidamente destruidos y recreados durante la alternancia.</p>\n<p><code>v-if</code> también es <strong>lazy</strong>: si la condición es falsa en la representación inicial, no se hará nada. El bloque condicional no se procesará hasta que la condición se convierta en true por primera vez.</p>\n<p>En comparación, <code>v-show</code> es mucho más simple: el elemento siempre se representa independientemente de la condición inicial, con alternancia basada en CSS.</p>\n<p>En general, <code>v-if</code> tiene costos de alternancia más altos, mientras que<code>v-show</code> tiene costos de renderización iniciales más altos. Por lo tanto, prefiera <code>v-show</code> si necesita cambiar algo muy a menudo, y prefiera<code>v-if</code> si es poco probable que la condición cambie en el tiempo de ejecución.</p>\n<h2><code>v-if</code> con <code>v-for</code></h2><p class=\"tip\">Usando <code>v-if</code> y <code>v-for</code> juntos <strong>no es recomendado</strong>. Vea la <span class=\"link\">guía de estilo</span> para mayor información.</p>\n<p>Cuando es utilizado junto con <code>v-for</code>, este tiene una prioridad más alta que <code>v-if</code>. Consulte la <span class=\"link\"> guía de renderización de listas </span> para obtener más información.</p>"
  },
  {
    "title": "Renderizado de lista",
    "contenido":  "<h1>Renderizado de lista</h1>\n<h2>Mapeando  una matriz a elementos con <code>v-for</code></h2><p>Podemos usar la directiva <code>v-for</code> para representar una lista de elementos basada en una matriz. La directiva <code>v-for</code> requiere una sintaxis especial en forma de <code>item in items</code>, donde los <code>items</code> son la matriz de datos de origen y el <code>item</code> es un <strong>alias</strong> para el elemento de matriz que se está iterando:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-1\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span>&gt;</span>\n    {{ item.mensaje }}\n  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></pre>\n<pre><span class=\"keyword\">var</span> example1 = <span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#example-1'</span>,\n  data: {\n    items: [\n      { <span class=\"attr\">mensaje</span>: <span class=\"string\">'Foo'</span> },\n      { <span class=\"attr\">mensaje</span>: <span class=\"string\">'Bar'</span> }\n    ]\n  }\n})</span></pre>\n<p>Dentro de los bloques <code>v-for</code> tenemos acceso completo a las propiedades del ámbito principal. <code>v-for</code> también admite un segundo argumento opcional para el índice del elemento actual.</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-2\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(item, index) in items\"</span>&gt;</span>\n    {{ MensajePadre }} - {{ index }} - {{ item.mensaje }}\n  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></pre>\n<pre><span class=\"keyword\">var</span> example2 = <span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#example-2'</span>,\n  data: {\n    mensajePadre: <span class=\"string\">'Padre'</span>,\n    items: [\n      { <span class=\"attr\">mensaje</span>: <span class=\"string\">'Foo'</span> },\n      { <span class=\"attr\">mensaje</span>: <span class=\"string\">'Bar'</span> }\n    ]\n  }\n})</span></pre>\n<p>También puede usar <code>of</code> como delimitador en lugar de <code>in</code>, de modo que esté más cerca de la sintaxis de JavaScript para los iteradores:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item of items\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<h2><code>v-for</code> con un Objeto</h2><p>También puede usar <code>v-for</code> para iterar a través de las propiedades de un objeto.</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">\"v-for-object\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"demo\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"value in object\"</span>&gt;</span>\n    {{ value }}\n  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></pre>\n<pre><span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#v-for-object'</span>,\n  data: {\n    object: {\n      primerNombre: <span class=\"string\">'John'</span>,\n      apellido: <span class=\"string\">'Doe'</span>,\n      edad: <span class=\"number\">30</span>\n    }\n  }\n})</span></pre>\n<p>También puede proporcionar un segundo argumento para la clave:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(value, key) in object\"</span>&gt;</span>\n  {{ key }}: {{ value }}\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Y otro para el índice:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(value, key, index) in object\"</span>&gt;</span>\n  {{ index }}. {{ key }}: {{ value }}\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p class=\"tip\">Al iterar sobre un objeto, el orden se basa en el orden de enumeración de claves de <code>Object.keys()</code>, que no se garantiza que sea consistente en todas las implementaciones del motor de JavaScript.</p>\n<h2><code>key</code></h2><p>Cuando Vue está actualizando una lista de elementos representados con <code>v-for</code>, por defecto utiliza una estrategia de “parche in situ”. Si el orden de los elementos de datos ha cambiado, en lugar de mover los elementos DOM para que coincidan con el orden de los elementos, Vue aplicará parches a cada elemento en el lugar y se asegurará de que refleje lo que se debe representar en ese índice en particular. Esto es similar al comportamiento de <code>track-by=\"$index\"</code> en Vue 1.x.</p>\n<p>Este modo predeterminado es eficiente, pero solo es adecuado <strong>cuando la salida de renderizado de su lista no se basa en el estado del componente secundario o el estado temporal de DOM (por ejemplo, valores de entrada de formulario)</strong>.</p>\n<p>Para proporcionar a Vue una sugerencia para que pueda rastrear la identidad de cada nodo y, por lo tanto, reutilizar y reordenar los elementos existentes, debe proporcionar un atributo <code>key</code> único para cada elemento. Un valor ideal para <code>key</code> sería el ID único de cada elemento. Este atributo especial es un equivalente aproximado a <code>track-by</code> en 1.x, pero funciona como un atributo, por lo que necesita usar <code>v-bind</code> para enlazarlo con valores dinámicos (usando el modo abreviado aquí):</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">:key</span>=<span class=\"string\">\"item.id\"</span>&gt;</span>\n  <span class=\"comment\">&lt;!-- content --&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Se recomienda proporcionar una <code>key</code> con <code>v-for</code> siempre que sea posible, a menos que el contenido DOM iterado sea simple, o esté confiando intencionalmente en el comportamiento predeterminado para obtener ganancias en el rendimiento.</p>\n<p>Como Vue es un mecanismo genérico para identificar nodos, la <code>key</code> también tiene otros usos que no están específicamente vinculados a <code>v-for</code>, como veremos más adelante en la guía.</p>\n<h2>Detección de cambios en el Array</h2><h3>Métodos de Mutación</h3><p>Vue envuelve los métodos de mutación de una matriz observada para que también activen las actualizaciones de vista. Los métodos envueltos son:</p>\n<ul>\n  <li><code>push()</code></li>\n  <li><code>pop()</code></li>\n  <li><code>shift()</code></li>\n  <li><code>unshift()</code></li>\n  <li><code>splice()</code></li>\n  <li><code>sort()</code></li>\n  <li><code>reverse()</code></li>\n</ul>\n<p>Puede abrir la consola y probar con la matriz de <code>items</code> de los ejemplos anteriores llamando a sus métodos de mutación. Por ejemplo: <code>example1.items.push ({mensaje: 'Baz'})</code>.</p>\n<h3>Mutando un Array</h3><p>Los métodos de mutación, como sugiere su nombre, mutan la matriz original a la que se llama. En comparación, también hay métodos no mutantes, p. Ej. <code>filter()</code>, <code>concat()</code> y <code>slice()</code>, que no mutan la matriz original pero <strong>siempre devuelven una nueva matriz</strong>. Cuando trabaje con métodos no mutantes, puede reemplazar la matriz anterior por la nueva:</p>\n<pre>example1.items = example1.items.filter(<span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">item</span>) </span>{\n  <span class=\"keyword\">return</span> item.mensaje.match(<span class=\"regexp\">/Foo/</span>)\n})</span></pre>\n<p>Podría pensar que esto hará que Vue elimine el DOM existente y vuelva a renderizar la lista completa; afortunadamente, ese no es el caso. Vue implementa algunas heurísticas inteligentes para maximizar la reutilización de elementos DOM, por lo tanto, reemplazar una matriz con otra matriz que contenga objetos superpuestos es una operación muy eficiente.</p>\n<h3>Advertencias</h3><p>Debido a las limitaciones en JavaScript, Vue <strong>no puede</strong> detectar los siguientes cambios en una matriz:</p>\n<ol>\n  <li><p>Cuando configura directamente un elemento con el índice, por ejemplo, <code>vm.items[indexOfItem] = newValue</code></p>\n  </li>\n  <li><p>Cuando modifica la longitud de la matriz, por ejemplo, <code>vm.items.length = newLength</code></p>\n  </li>\n</ol>\n<p>Por ejemplo:</p>\n<pre><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue({\n  data: {\n    items: [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]\n  }\n})\nvm.items[<span class=\"number\">1</span>] = <span class=\"string\">'x'</span> <span class=\"comment\">// NO es reactivo</span>\nvm.items.length = <span class=\"number\">2</span> <span class=\"comment\">//  NO es reactivo</span></span></pre>\n<p>Para superar la advertencia 1, ambos de los siguientes lograrán lo mismo que <code>vm.items[indexOfItem] = newValue</code>, pero también activarán actualizaciones de estado en el sistema de reactividad:</p>\n<pre><span class=\"comment\">// Vue.set</span>\nVue.set(vm.items, indexOfItem, newValue)</span></pre>\n<pre><span class=\"comment\">// Array.prototype.splice</span>\nvm.items.splice(indexOfItem, <span class=\"number\">1</span>, newValue)</span></pre>\n<p>También puede usar el método de instancia <span class=\"link\"><code>vm.$Set</code></span>, que es un alias para el <code>Vue.set</code> global:</p>\n<pre>vm.$set(vm.items, indexOfItem, newValue)</span></pre>\n<p>Para tratar con la advertencia 2, puede usar <code>splice</code>:</p>\n<pre>vm.items.splice(newLength)</span></pre>\n<h2>Advertencias con la Detección de Cambios en Objetos</h2><p>Una vez más, debido a las limitaciones del JavaScript moderno, <strong>Vue no puede detectar la adición o eliminación de propiedades</strong>. Por ejemplo:</p>\n<pre><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue({\n  data: {\n    a: <span class=\"number\">1</span>\n  }\n})\n<span class=\"comment\">// `vm.a` ahora es reactivo</span>\n\nvm.b = <span class=\"number\">2</span>\n<span class=\"comment\">// `vm.b` NO es reactivo</span>\n/</span></pre>\n<p>Vue no permite agregar dinámicamente nuevas propiedades reactivas a nivel de raíz a una instancia ya creada. Sin embargo, es posible agregar propiedades reactivas a un objeto anidado usando el método <code>Vue.set (objeto, clave, valor)</code>. Por ejemplo, dado:</p>\n<pre><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue({\n  data: {\n    userProfile: {\n      name: <span class=\"string\">'Anika'</span>\n    }\n  }\n})</span></pre>\n<p>Podría agregar una nueva propiedad de <code>edad</code> al objeto de <code>userProfile</code> anidado con:</p>\n<pre>Vue.set(vm.userProfile, <span class=\"string\">'edad'</span>, <span class=\"number\">27</span>)</span></pre>\n<p>También puede usar el método de instancia vm. <code>$Set</code>, que es un alias para el <code>Vue.set</code> global:</p>\n<pre>vm.$set(vm.userProfile, <span class=\"string\">'edad'</span>, <span class=\"number\">27</span>)</span></pre>\n<p>En ocasiones, es posible que desee asignar varias propiedades nuevas a un objeto existente, por ejemplo, utilizando <code>Object.assign()</code> o <code>_.extend()</code>. En tales casos, debe crear un objeto nuevo con propiedades de ambos objetos. Así que en lugar de:</p>\n<pre><span class=\"built_in\">Object</span>.assign(vm.userProfile, {\n  edad: <span class=\"number\">27</span>,\n  favoriteColor: <span class=\"string\">'Vue Green'</span>\n})</span></pre>\n<p>Puedria agregar nuevas propiedades reactivas con:</p>\n<pre>vm.userProfile = <span class=\"built_in\">Object</span>.assign({}, vm.userProfile, {\n  edad: <span class=\"number\">27</span>,\n  favoriteColor: <span class=\"string\">'Vue Green'</span>\n})</span></pre>\n<h2>Mostrando Resultados Filtrados/Ordenados</h2><p>A veces, queremos mostrar una versión filtrada u ordenada de una matriz sin mutar o restablecer los datos originales. En este caso, puede crear una propiedad computada que devuelva la matriz filtrada u ordenada.</p>\n<p>Por ejemplo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"n in numerosImpares\"</span>&gt;</span>{{ n }}<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></pre>\n<pre>data: {\n  numeros: [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> ]\n},\ncomputed: {\n  numerosImpares: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.numeros.filter(<span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">numero</span>) </span>{\n      <span class=\"keyword\">return</span> numero % <span class=\"number\">2</span> === <span class=\"number\">0</span>\n    })\n  }\n}</span></pre>\n<p>En situaciones donde las propiedades computadas no son factibles (por ejemplo, dentro de los bucles <code>v-for</code> anidados), puede usar un método:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"n in even(numeros)\"</span>&gt;</span>{{ n }}<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></pre>\n<pre>data: {\n  numeros: [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> ]\n},\nmethods: {\n  even: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">numeros</span>) </span>{\n    <span class=\"keyword\">return</span> numeros.filter(<span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">numero</span>) </span>{\n      <span class=\"keyword\">return</span> numero % <span class=\"number\">2</span> === <span class=\"number\">0</span>\n    })\n  }\n}</span></pre>\n<h2><code>v-for</code> con un Rango</h2><p><code>v-for</code> también puede tomar un entero. En este caso repetirá la plantilla muchas veces.</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"n in 10\"</span>&gt;</span>{{ n }}<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<h2>\" data-scroll=\"\"><code>v-for</code> en un <code>&lt;template&gt;</code></h2><p>De forma similar a la plantilla <code>v-if</code>, también puede usar una etiqueta <code>&lt;template&gt;</code> con <code>v-for</code> para renderizar un bloque de varios elementos. Por ejemplo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>{{ item.msg }}<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">class</span>=<span class=\"string\">\"divider\"</span> <span class=\"attr\">role</span>=<span class=\"string\">\"presentation\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>\n  <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></pre>\n<h2><code>v-for</code> con <code>v-if</code></h2><p class=\"tip\">Tenga en cuenta que <strong>no se recomienda</strong> usar <code>v-if</code> y <code>v-for</code> juntos. Consulte la <span class=\"link\">guía de estilo</span> para más detalles.</p>\n<p>Cuando existen en el mismo nodo, <code>v-for</code> tiene una prioridad más alta que <code>v-if</code>. Eso significa que el <code>v-if</code> se ejecutará en cada iteración del bucle por separado. Esto puede ser útil cuando desea representar nodos solo para <em>algunos</em> elementos, como a continuación:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"todo in todos\"</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"!todo.isComplete\"</span>&gt;</span>\n  {{ todo }}\n<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></pre>\n<p>Lo anterior hace que los todos que no estén completos, se rendericen.</p>\n<p>Si, por el contrario, su intención es omitir condicionalmente la ejecución del bucle, puede colocar el <code>v-if</code> en un elemento de envoltura (o <span class=\"link\"><code>&lt;template&gt;</code></span>). Por ejemplo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"todos.length\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"todo in todos\"</span>&gt;</span>\n    {{ todo }}\n  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-else</span>&gt;</span>No quedan todos!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></pre>\n<h2><code>v-for</code> con un Componente</h2><blockquote>\n<p>Esta sección asume el conocimiento de <span class=\"link\">Componentes</span>. Siéntase libre de saltearlo y volver más tarde.</p>\n</blockquote>\n<p>Puede usar <code>v-for</code> directamente en un componente personalizado, como cualquier elemento normal:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">:key</span>=<span class=\"string\">\"item.id\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span></pre>\n<blockquote>\n  <p>En 2.2.0+, cuando se usa <code>v-for</code> con un componente, ahora se requiere una <span class=\"link\"><code>key</code></span>.</p>\n</blockquote>\n<p>Sin embargo, esto no pasará automáticamente ningún dato al componente, porque los componentes tienen sus propios ámbitos aislados. Para pasar los datos iterados al componente, también debemos usar props:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">my-component</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-for</span>=<span class=\"string\">\"(item, index) in items\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:item</span>=<span class=\"string\">\"item\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:index</span>=<span class=\"string\">\"index\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"item.id\"</span></span>\n<span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span></pre>\n<p>La razón para no inyectar automáticamente el <code>item</code> en el componente es porque hace que el componente esté estrechamente acoplado a cómo funciona <code>v-for</code>. Ser explícito acerca de dónde provienen sus datos hace que el componente sea reutilizable en otras situaciones.</p>\n<p>Aquí hay un ejemplo completo de una lista de tareas simple:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"todo-list-example\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">v-on:submit.prevent</span>=<span class=\"string\">\"addNewTodo\"</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"new-todo\"</span>&gt;</span>Agregar tarea<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">input</span></span>\n<span class=\"tag\">      <span class=\"attr\">v-model</span>=<span class=\"string\">\"newTodoText\"</span></span>\n<span class=\"tag\">      <span class=\"attr\">id</span>=<span class=\"string\">\"new-todo\"</span></span>\n<span class=\"tag\">      <span class=\"attr\">placeholder</span>=<span class=\"string\">\"E.g. Feed the cat\"</span></span>\n<span class=\"tag\">    &gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span>Agregar<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span>\n  <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">li</span></span>\n<span class=\"tag\">      <span class=\"attr\">is</span>=<span class=\"string\">\"todo-item\"</span></span>\n<span class=\"tag\">      <span class=\"attr\">v-for</span>=<span class=\"string\">\"(todo, index) in todos\"</span></span>\n<span class=\"tag\">      <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"todo.id\"</span></span>\n<span class=\"tag\">      <span class=\"attr\">v-bind:title</span>=<span class=\"string\">\"todo.title\"</span></span>\n<span class=\"tag\">      <span class=\"attr\">v-on:remove</span>=<span class=\"string\">\"todos.splice(index, 1)\"</span></span>\n<span class=\"tag\">    &gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>\n  <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p class=\"tip\">Note el atributo <code>is = \"todo-item\"</code>. Esto es necesario en las plantillas DOM, porque solo un elemento <code>&lt;li&gt;</code> es válido dentro de un <code>&lt;ul&gt;</code>. Hace lo mismo que <code>&lt;todo-item&gt;</code>, pero funciona alrededor de un error potencial de análisis del navegador. Ver las <span class=\"link\">advertencias de análisis de plantillas DOM</span> aprender más.</p>\n<pre>.component(<span class=\"string\">'todo-item'</span>, {\n  template: <span class=\"string\">'\\</span>\n<span class=\"string\">    &lt;li&gt;\\</span>\n<span class=\"string\">      {{ title }}\\</span>\n<span class=\"string\">      &lt;button -on:click=\"$emit(\\'remove\\')\"&gt;Remove&lt;/button&gt;\\</span>\n<span class=\"string\">    &lt;/li&gt;\\</span>\n<span class=\"string\">  '</span>,\n  props: [<span class=\"string\">'title'</span>]\n})\n\n<span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#todo-list-example'</span>,\n  data: {\n    newTodoText: <span class=\"string\">''</span>,\n    todos: [\n      {\n        id: <span class=\"number\">1</span>,\n        title: <span class=\"string\">'Do the dishes'</span>\n      },\n      {\n        id: <span class=\"number\">2</span>,\n        title: <span class=\"string\">'Take out the trash'</span>\n      },\n      {\n        id: <span class=\"number\">3</span>,\n        title: <span class=\"string\">'Mow the lawn'</span>\n      }\n    ],\n    nextTodoId: <span class=\"number\">4</span>\n  },\n  methods: {\n    addNewTodo: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n      <span class=\"keyword\">this</span>.todos.push({\n        id: <span class=\"keyword\">this</span>.nextTodoId++,\n        title: <span class=\"keyword\">this</span>.newTodoText\n      })\n      <span class=\"keyword\">this</span>.newTodoText = <span class=\"string\">''</span>\n    }\n  }\n})</span></pre>"
  },
  {
    "title": "Manejo de eventos",
    "contenido":  "<h1>Manejo de eventos</h1>\n<h2>Escuchar eventos</h2><p>Podemos usar la directiva <code>v-on</code> para escuchar eventos DOM y ejecutar algunos JavaScript cuando se activan.</p>\n<p>Por ejemplo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-1\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"counter += 1\"</span>&gt;</span>Add 1<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Se ha hecho clic en el botón de arriba {{ counter }} veces.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre><span class=\"keyword\">var</span> example1 = <span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#example-1'</span>,\n  data: {\n    counter: <span class=\"number\">0</span>\n  }\n})</span></pre>\n<h2>Métodos Manejadores de eventos</h2><p>Sin embargo, la lógica para muchos controladores de eventos será más compleja, por lo que no es posible mantener su JavaScript en el valor del atributo <code>v-on</code>. Es por eso que <code>v-on</code> también puede aceptar el nombre de un método al que te gustaría llamar.</p>\n<p>Por ejemplo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-2\"</span>&gt;</span>\n  <span class=\"comment\">&lt;!-- `saludar` es el nombre de un método definido a continuación --&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"saludar\"</span>&gt;</span>Saludar<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre><span class=\"keyword\">var</span> example2 = <span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#example-2'</span>,\n  data: {\n    name: <span class=\"string\">'Vue.js'</span>\n  },\n  <span class=\"comment\">// definir métodos bajo el objeto `methods`</span>\n  methods: {\n    saludar: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">event</span>) </span>{\n      <span class=\"comment\">// `this` dentro de los métodos apunta a la instancia de Vue</span>\n      alert(<span class=\"string\">'Hola '</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">'!'</span>)\n      <span class=\"comment\">// `evento` es el evento DOM nativo</span>\n      <span class=\"keyword\">if</span> (event) {\n        alert(event.target.tagName)\n      }\n    }\n  }\n})\n\n<span class=\"comment\">// también puedes invocar métodos en JavaScript.</span>\nexample2.greet() <span class=\"comment\">// =&gt; 'Hello Vue.js!'</span></span></pre>\n<h2>Métodos Manejadores en línea</h2><p>En lugar de enlazar directamente con un nombre de método, también podemos usar métodos en una declaración de JavaScript en línea:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example-3\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"di('hola')\"</span>&gt;</span>Di hola<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"di('que')\"</span>&gt;</span>Di que<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre><span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#example-3'</span>,\n  methods: {\n    di: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">mensaje</span>) </span>{\n      alert(mensaje)\n    }\n  }\n})</span></pre>\n<p>A veces también necesitamos acceder al evento DOM original en un controlador de instrucciones en línea. Puedes pasarlo a un método usando la variable especial <code>$event</code>:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"Alertar('El Form no se puede enviar aun.', $event)\"</span>&gt;</span>\n  Enviar\n<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></pre>\n<pre><span class=\"comment\">// ...</span>\nmethods: {\n  Alertar: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">message, event</span>) </span>{\n    <span class=\"comment\">// ahora tenemos acceso al evento nativo.</span>\n    <span class=\"keyword\">if</span> (event) event.preventDefault()\n    alert(message)\n  }\n}</span></pre>\n<h2>Modificadores de eventos</h2><p>Es una necesidad muy común llamar a <code>event.preventDefault()</code> o <code>event.stopPropagation()</code> dentro de los controladores de eventos. Aunque podemos hacer esto fácilmente dentro de los métodos, sería mejor si los métodos fueran puramente sobre lógica de datos en lugar de tener que lidiar con los detalles del evento DOM.</p>\n<p>Para solucionar este problema, Vue proporciona <strong>modificadores de eventos</strong> para <code>v-on</code>. Recuerde que los modificadores son directivas postfijos marcados por un punto.</p>\n<ul>\n<li><code>.stop</code></li>\n<li><code>.prevent</code></li>\n<li><code>.capture</code></li>\n<li><code>.self</code></li>\n<li><code>.once</code></li>\n<li><code>.passive</code></li>\n</ul>\n<pre><span class=\"comment\">&lt;!-- Se detendrá la propagación del evento click. --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on:click.stop</span>=<span class=\"string\">\"hazEsto\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- El evento de enviar ya no volverá a cargar la página. --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">v-on:submit.prevent</span>=<span class=\"string\">\"onSubmit\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- Los modificadores pueden encadenarse --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on:click.stop.prevent</span>=<span class=\"string\">\"hazEsto\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- solo el modificador --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">v-on:submit.prevent</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- utilizar el modo de captura al agregar el detector de eventos --&gt;</span>\n<span class=\"comment\">&lt;!-- es decir, un evento dirigido a un elemento interno se maneja aquí antes de ser manejado por ese elemento --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-on:click.capture</span>=<span class=\"string\">\"hazEsto\"</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- solo activa el controlador si event.target es el elemento en sí --&gt;</span>\n<span class=\"comment\">&lt;!-- es decir, no de un elemento hijo --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-on:click.self</span>=<span class=\"string\">\"hazEso\"</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p class=\"tip\">El orden es importante cuando se usan modificadores porque el código relevante se genera en el mismo orden. Por lo tanto, el uso de <code>v-on: click.prevent.self</code> evitará <strong>todos los clics</strong> mientras que <code>v-on: click.self.prevent</code> solo evitará clics en el elemento en sí.</p>\n\n<blockquote>\n<p>Nuevo en 2.1.4+</p>\n</blockquote>\n<pre><span class=\"comment\">&lt;!-- El evento de clic se activará como máximo una vez. --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on:click.once</span>=<span class=\"string\">\"hazEsto\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></pre>\n<p>A diferencia de los otros modificadores, que son exclusivos de los eventos DOM nativos, el modificador <code>.once</code> también se puede usar en <span class=\"link\">eventos personalizados</span>. Si aún no ha leído sobre componentes, no se preocupe de esto por ahora.</p>\n<blockquote>\n<p>Nuevo in 2.3.0+</p>\n</blockquote>\n<p>Vue también ofrece el modificador <code>.passive</code>, correspondiente a <span class=\"link\">la opción <code>pasiva</code> de <code>addEventListener</code></span>.</p>\n<pre><span class=\"comment\">&lt;!-- El comportamiento predeterminado del evento scroll (scrolling) sucederá --&gt;</span>\n<span class=\"comment\">&lt;!-- inmediatamente, en lugar de esperar a que se complete `onScroll`  --&gt;</span>\n<span class=\"comment\">&lt;!-- en caso de que contenga `event.preventDefault ()`                --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-on:scroll.passive</span>=<span class=\"string\">\"onScroll\"</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>El modificador <code>.passive</code> es especialmente útil para mejorar el rendimiento en dispositivos móviles.</p>\n<p class=\"tip\">No use <code>.passive</code> y <code>.prevent</code> juntos, ya que <code>.prevent</code> se ignorará y su navegador probablemente le mostrará una advertencia. Recuerde, <code>.passive</code> comunica al navegador que no desea evitar el comportamiento predeterminado del evento.</p>\n\n<h2>Modificadores de Teclas</h2><p>Cuando escuchamos eventos de teclado, a menudo necesitamos verificar códigos de teclas comunes. Vue también permite agregar modificadores clave para <code>v-on</code> cuando se escuchan eventos de teclado:</p>\n<pre><span class=\"comment\">&lt;!-- solo llame a `vm.submit ()` cuando el `keyCode` es 13 --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-on:keyup.13</span>=<span class=\"string\">\"submit\"</span>&gt;</span></span></pre>\n<p>Recordar todos los <code>keyCodes</code> es un dolor de cabeza, por lo que Vue proporciona alias para las teclas más utilizadas:</p>\n<pre><span class=\"comment\">&lt;!-- lo mismo que arriba --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-on:keyup.enter</span>=<span class=\"string\">\"submit\"</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- También funciona como abreviacion. --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">input</span> @<span class=\"attr\">keyup.enter</span>=<span class=\"string\">\"submit\"</span>&gt;</span></span></pre>\n<p>Aqui esta la lista completa de alias:</p>\n<ul>\n<li><code>.enter</code></li>\n<li><code>.tab</code></li>\n<li><code>.delete</code> (captura ambas teclas “Delete” y “Backspace”)</li>\n<li><code>.esc</code></li>\n<li><code>.space</code></li>\n<li><code>.up</code></li>\n<li><code>.down</code></li>\n<li><code>.left</code></li>\n<li><code>.right</code></li>\n</ul>\n<p>También puede <span class=\"link\">definir alias modificadores de tecla personalizados</span> a través del objeto global <code>config.keyCodes</code>:</p>\n<pre><span class=\"comment\">// habilita `v-on:keyup.f1`</span>\nVue.config.keyCodes.f1 = <span class=\"number\">112</span></span></pre>\n<h3>Modificadores automáticos de teclas</h3><blockquote>\n<p>Nuevo in 2.5.0+</p>\n</blockquote>\n<p>También puede usar directamente cualquier nombre de tecla válido expuesto a través de <span class=\"link\"><code>KeyboardEvent.key</code></span> como modificadores convirtiéndolos a kebab-case:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">input</span> @<span class=\"attr\">keyup.page-down</span>=<span class=\"string\">\"onPageDown\"</span>&gt;</span></span></pre>\n<p>En el ejemplo anterior, solo se llamará al controlador si <code>$event.key === 'PageDown'</code></p>\n<p class=\"tip\">Algunas teclas (<code>.esc</code> y todas las teclas de flecha) tienen valores <code>key</code> incoherentes en IE9; se deben preferir sus alias integrados si necesita compatibilidad con IE9.</p>\n\n<h2>Modificador de Teclas del Sistema</h2><blockquote>\n<p>Nuevo en 2.1.0+</p>\n</blockquote>\n<p>Puede usar los siguientes modificadores para activar eventos listeners de raton o teclado solo cuando se presiona la tecla modificadora correspondiente:</p>\n<ul>\n<li><code>.ctrl</code></li>\n<li><code>.alt</code></li>\n<li><code>.shift</code></li>\n<li><code>.meta</code></li>\n</ul>\n<blockquote>\n<p>Nota: En los teclados de Macintosh, meta es la tecla de comando (⌘). En los teclados de Windows, meta es la tecla de Windows (). En los teclados de Sun Microsystems, el meta está marcado como un diamante sólido (◆). En ciertos teclados, específicamente los teclados y sucesores de máquinas MIT y Lisp, como el teclado Knight, el teclado space-cadet, el meta está etiquetado como “META”. En los teclados de Symbolics, el meta está etiquetado como “META” o “Meta”.</p>\n</blockquote>\n<p>Por ejemplo:</p>\n<pre><span class=\"comment\">&lt;!-- Alt + C --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">input</span> @<span class=\"attr\">keyup.alt.67</span>=<span class=\"string\">\"clear\"</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- Ctrl + Click --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">div</span> @<span class=\"attr\">click.ctrl</span>=<span class=\"string\">\"doSomething\"</span>&gt;</span>Do something<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p class=\"tip\">Tenga en cuenta que las teclas modificadoras son diferentes de las teclas normales y cuando se usan con eventos <code>keyup</code>, deben presionarse cuando se emite el evento. En otras palabras, <code>keyup.ctrl</code> solo se activará si sueltas una tecla mientras mantienes presionada la tecla <code>Ctrl</code>. No se activará si suelta la tecla <code>ctrl</code> solo. Si desea tal comportamiento, use el <code>código de tecla</code> para <code>ctrl</code> en su lugar: <code>keyup.17</code>.</p>\n\n<h3>Modificador <code>.exact</code></h3><blockquote>\n<p>Nuevo en 2.5.0+</p>\n</blockquote>\n<p>El modificador <code>.exact</code> permite el control de la combinación exacta de modificadores del sistema necesarios para desencadenar un evento.</p>\n<pre><span class=\"comment\">&lt;!-- esto se disparará incluso si se presiona Alt o Shift --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click.ctrl</span>=<span class=\"string\">\"onClick\"</span>&gt;</span>A<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- esto solo se activará cuando se presione Ctrl y no se presionen otras teclas --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click.ctrl.exact</span>=<span class=\"string\">\"onCtrlClick\"</span>&gt;</span>A<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- esto solo se activará cuando no se presionen modificadores del sistema --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click.exact</span>=<span class=\"string\">\"onClick\"</span>&gt;</span>A<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></pre>\n<h3>Modificador de Boton del Raton</h3><blockquote>\n<p>Nuevo en 2.2.0+</p>\n</blockquote>\n<ul>\n<li><code>.left</code></li>\n<li><code>.right</code></li>\n<li><code>.middle</code></li>\n</ul>\n<p>Estos modificadores restringen el controlador a eventos activados por un botón específico del raton.</p>\n<h2>¿Por qué Listeners en HTML?</h2><p>Es posible que le preocupe que todo este enfoque de escucha de eventos viole las viejas buenas reglas sobre la “separation of concerns” (“separación de preocupaciones”). Tenga la tranquilidad de que todas las funciones y expresiones del controlador de Vue están estrictamente vinculadas a ViewModel que esta manejando la vista actual, no causará ninguna dificultad de mantenimiento. De hecho, hay varios beneficios en el uso de <code>v-on</code>:</p>\n<ol>\n<li><p>Es más fácil ubicar las implementaciones de la función de controlador dentro de su código JS al ojear la plantilla HTML.</p>\n</li>\n<li><p>Una vez que no tenga que adjuntar manualmente eventos listeners en JS, su código de ViewModel puede ser de lógica pura y libre de DOM. Esto hace que sea más fácil de probar.</p>\n</li>\n<li><p>Cuando se destruye un ViewModel, todos los eventos listeners se eliminan automáticamente. No tiene que preocuparse por limpiarlo usted mismo.</p>\n</li>\n</ol>"
  },
  {
    "title": "Binding en Formularios",
    "contenido":  "<h1>Binding en Formularios</h1>\n<h2>Uso básico</h2><p>Puede usar la directiva <code>v-model</code> para crear <em>bindings</em> de datos bidireccionales (<em>two-way binding</em>) en elementos <em>input</em>, <em>textarea</em> y <em>select</em> de un formulario. La directiva busca automáticamente la manera correcta de actualizar el elemento según el tipo de entrada. Aunque un poco mágico, <code>v-model</code> es esencialmente <em>syntax sugar</em> para actualización de datos a través de eventos de entradas del usuario, además de mostrar un cuidado especial para algunos casos de borde.</p>\n<p class=\"tip\"><code>v-model</code> ignorará el <code>value</code> inicial, los atributos <code>checked</code> o <code>selected</code> que se encuentran en cualquier elemento de formulario. Siempre tratará los datos de la instancia de Vue como la fuente confiable. Debe declarar el valor inicial del lado de JavaScript, dentro de la opción <code>data</code> de su componente.</p>\n<p class=\"tip\" id=\"vmodel-ime-tip\">Para los idiomas que requieren un <span class=\"link\">IME</span> (chino, japonés, coreano, etc.), notará que el <code>v-model</code> no se actualiza durante la composición del IME. Si también desea atender estas actualizaciones, use un evento <code>input</code> en su lugar.</p>\n<h3>Input</h3><pre><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"message\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"edíteme\"</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>El mensaje es: {{ message }}<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></pre>\n<h3>Textarea</h3><pre><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>El mensaje multilínea es:<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">style</span>=<span class=\"string\">\"white-space: pre-line;\"</span>&gt;</span>{{ message }}<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"message\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"agregar múltiples líneas\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></span></pre>\n<p class=\"tip\">La interpolación en textareas no funciona (<code>&lt;textarea&gt;{{text}}&lt;/textarea&gt;</code>). En su lugar use <code>v-model</code>.</p>\n<h3>Checkbox</h3><p><em>Checkbox</em> simples con valor booleano:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"checked\"</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"checkbox\"</span>&gt;</span>{{ checked }}<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span></pre>\n<p>Múltiples checkboxes vinculados al mismo Array:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">'example-3'</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"jack\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Jack\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"checkedNames\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"jack\"</span>&gt;</span>Jack<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"john\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"John\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"checkedNames\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"john\"</span>&gt;</span>John<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mike\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Mike\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"checkedNames\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"mike\"</span>&gt;</span>Mike<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Checked names: {{ checkedNames }}<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre><span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#example-3'</span>,\n  data: {\n    checkedNames: []\n  }\n})</span></pre>\n<h3>Select</h3><p>Selección de un solo elemento:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"selected\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">disabled</span> <span class=\"attr\">value</span>=<span class=\"string\">\"\"</span>&gt;</span>Seleccione un elemento<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>A<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>B<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>C<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Seleccionado: {{ selected }}<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></pre>\n<pre><span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'...'</span>,\n  data: {\n    selected: <span class=\"string\">''</span>\n  }\n})</span></pre>\n<p>Opciones dinámicas renderizadas con <code>v-for</code>:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"selected\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"option in options\"</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"option.value\"</span>&gt;</span>\n    {{ option.text }}\n  <span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Seleccionado: {{ selected }}<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></pre>\n<pre><span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'...'</span>,\n  data: {\n    selected: <span class=\"string\">'A'</span>,\n    options: [\n      { <span class=\"attr\">text</span>: <span class=\"string\">'Uno'</span>, <span class=\"attr\">value</span>: <span class=\"string\">'A'</span> },\n      { <span class=\"attr\">text</span>: <span class=\"string\">'Dos'</span>, <span class=\"attr\">value</span>: <span class=\"string\">'B'</span> },\n      { <span class=\"attr\">text</span>: <span class=\"string\">'Tres'</span>, <span class=\"attr\">value</span>: <span class=\"string\">'C'</span> }\n    ]\n  }\n})</span></pre>\n<h2>Vinculando a Valores</h2><p>Para <em>radio</em>, <em>checkbox</em> y <em>option</em> de <em>select</em>, los valores de vinculación del <code>v-model</code> suelen ser cadenas estáticas (o booleanos para <em>checkbox</em>):</p>\n<pre><span class=\"comment\">&lt;!-- `picked` es una cadena \"a\" cuando está chequeado --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"picked\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"a\"</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- `toggle` es verdadero o falso --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"toggle\"</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- `selected` es una cadena \"abc\" cuando se selecciona la primera opción --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"selected\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"abc\"</span>&gt;</span>ABC<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span></pre>\n<p>Pero a veces es posible que queramos vincular el valor a una propiedad dinámica en la instancia de Vue. Podemos usar <code>v-bind</code> para lograr eso. Además, el uso de <code>v-bind</code> nos permite vincular el valor de entrada a valores no cadena.</p>\n<h3>Checkbox</h3><pre><span class=\"tag\">&lt;<span class=\"name\">input</span></span>\n<span class=\"tag\">  <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-model</span>=<span class=\"string\">\"toggle\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">true-value</span>=<span class=\"string\">\"yes\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">false-value</span>=<span class=\"string\">\"no\"</span></span>\n<span class=\"tag\">&gt;</span></span></pre>\n<pre><span class=\"comment\">// cuando está marcado:</span>\nvm.toggle === <span class=\"string\">'yes'</span>\n<span class=\"comment\">// cuando está desmarcado:</span>\nvm.toggle === <span class=\"string\">'no'</span></span></pre>\n<p class=\"tip\">Los atributos de <code>true-value</code> y de <code>false-value</code> no afectan la entrada del atributo <code>value</code>, ya que los navegadores no incluyen casillas sin marcar en los envíos de formularios. Para garantizar que uno de los dos valores se envie en un formulario (por ejemplo, “yes” o “no”), use entradas de radio en su lugar.\n</p>\n<h3>Radio</h3><pre><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"pick\"</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"a\"</span>&gt;</span></span></pre>\n<pre><span class=\"comment\">// cuando está marcado:</span>\nvm.pick === vm.a</span></pre>\n<h3>Select</h3><pre><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"selected\"</span>&gt;</span>\n  <span class=\"comment\">&lt;!--  objeto literal en línea --&gt;</span> --&gt;\n  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"{ number: 123 }\"</span>&gt;</span>123<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span></pre>\n<pre><span class=\"comment\">// cuando está seleccionado:</span>\n<span class=\"keyword\">typeof</span> vm.selected <span class=\"comment\">// =&gt; 'object'</span>\nvm.selected.number <span class=\"comment\">// =&gt; 123</span></span></pre>\n<h2>Modificadores</h2><h3><code>.lazy</code></h3><p>De forma predeterminada, <code>v-model</code> sincroniza el <code>input</code> con los datos después de cada evento de tipo <code>input</code> (con la excepción de la composición IME <span class=\"link\">descrito anteriormente</span>). En lugar de esto, puede agregar el modificador <code>lazy</code> para realizar la sincronización después del evento <code>change</code>:</p>\n<pre><span class=\"comment\">&lt;!-- sincronizado después de \"change\" en lugar de \"input\" --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model.lazy</span>=<span class=\"string\">\"msg\"</span> &gt;</span></span></pre>\n<h3><code>.number</code></h3><p>Si desea que las entradas del usuario se escriban automáticamente como un número, puede agregar el modificador <code>number</code> al <code>v-model</code> del elemento:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model.number</span>=<span class=\"string\">\"age\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"number\"</span>&gt;</span></span></pre>\n<p>Esto suele ser útil, porque incluso con <code>type=\"number\"</code>, el valor retornado por el elemento HTML siempre es una cadena de texto. Si el valor no se puede analizar con <code>parseFloat()</code>, se retorna el valor original.</p>\n<h3><code>.trim</code></h3><p>Si desea que las entradas del usuario se recorten automáticamente, puede agregar el modificador <code>trim</code> al <code>v-model</code> de su elemento:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model.trim</span>=<span class=\"string\">\"msg\"</span>&gt;</span></span></pre>\n<h2><code>v-model</code> con Componentes</h2><blockquote>\n<p>Si aún no está familiarizado con los componentes de Vue, puede omitir esto por ahora.</p>\n</blockquote>\n<p>Los tipos de <em>input</em> nativos de HTML no siempre satisfarán sus necesidades. Afortunadamente, los componentes de Vue le permiten crear <em>input</em> reutilizables con un comportamiento completamente personalizado. Estos componentes también funcionan con <code>v-model</code>! Para aprender más, lea acerca de <span class=\"link\">inputs personalizados</span> en la guía de componentes.</p>"
  },
  {
    "title": "Conceptos Básicos de Componentes",
    "contenido":  "<h1>Conceptos Básicos de Componentes</h1>\n<h2>Ejemplo base</h2><p>Aquí un ejemplo de un componente Vue:</p>\n<pre><span class=\"comment\">// Definir un nuevo componente llamado button-counter</span>\nVue.component(<span class=\"string\">'button-counter'</span>, {\n  data: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n    <span class=\"keyword\">return</span> {\n      count: <span class=\"number\">0</span>\n    }\n  },\n  template: <span class=\"string\">'&lt;button v-on:click=\"count++\"&gt;Me ha pulsado {{ count }} veces.&lt;/button&gt;'</span>\n})</span></pre>\n<p>Los componentes son instancias reutilizables de Vue con un nombre: en este caso, <code>&lt;button-counter&gt;</code>. Podemos usar este componente como un elemento personalizado dentro de una instancia de Vue raíz creada con <code>new Vue</code>:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"components-demo\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">button-counter</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button-counter</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<pre><span class=\"keyword\">new</span> Vue({ <span class=\"attr\">el</span>: <span class=\"string\">'#components-demo'</span> })</span></pre>\n<p>Tenga en cuenta que al hacer clic en los botones, cada uno mantiene su propio <code>count</code> por separado. Esto se debe a que cada vez que utiliza un componente, se crea una nueva <strong>instancia</strong> del mismo.</p>\n<h3><code>data</code> Debe ser una función</h3><p>Cuando definimos el componente <code>&lt;button-counter&gt;</code>, es posible que haya notado que <code>data</code> no devuelve directamente un objeto, como este:</p>\n<pre>data: {\n  count: <span class=\"number\">0</span>\n}</span></pre>\n<p>En lugar de eso, <strong>la opción <code>data</code> de un componente debe ser una función</strong>, de modo que cada instancia pueda mantener una copia independiente del objeto de datos devuelto:</p>\n<pre>data: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\"></span>) </span>{\n  <span class=\"keyword\">return</span> {\n    count: <span class=\"number\">0</span>\n  }\n}</span></pre>\n<p>Si Vue no tuviera esta regla, hacer clic en un botón afectaría los datos de <em>todas las demás instancias</em>, como a continuación:</p>\n<h2>Organización de Componentes</h2><p>Es común que una aplicación se organice en un árbol de componentes anidados:</p>\n<p><img src=\"/images/components.png\" alt=\"Component Tree\"></p>\n<p>Por ejemplo, puede tener componentes para un encabezado, una barra lateral y un área de contenido, cada uno de los cuales generalmente contiene otros componentes para enlaces de navegación, publicaciones de blog, etc.</p>\n<p>Para usar estos componentes en <em>templates</em>, deben registrarse para que Vue los conozca. Existen dos tipos de registro de componentes: <strong>global</strong> y <strong>local</strong>. Hasta ahora, solo hemos registrado componentes globalmente, usando <code>Vue.component</code>:</p>\n<pre>Vue.component(<span class=\"string\">'my-component-name'</span>, {\n  <span class=\"comment\">// ... opciones ...</span>\n})</span></pre>\n<p>Los componentes registrados globalmente se pueden usar en el <em>template</em> de cualquier instancia de Vue raíz (<code>new Vue</code>) creada posteriormente, e incluso dentro de todos los subcomponentes del árbol de componentes de esa instancia de Vue.</p>\n<p>Eso es todo lo que necesita saber sobre el registro por ahora, pero una vez que haya terminado de leer esta página y se sienta cómodo con su contenido, le recomendamos volver más tarde para leer la guía completa de <span class=\"link\">Registro de Componentes</span>.</p>\n<h2>Pasando datos a componentes secundarios con Props</h2><p>Anteriormente, mencionamos la creación de un componente para publicaciones de blog. El problema es que ese componente no será útil a menos que puedas pasarle datos, como el título y el contenido de la publicación específica que queremos mostrar. Ahí es donde entran las <strong>props</strong>.</p>\n<p>Las <strong>props</strong> son atributos personalizados que usted puede registrar en un componente. Cuando se pasa un valor a un atributo <strong>prop</strong>, se convierte en una propiedad en esa instancia de componente. Para pasar un título a nuestro componente de publicación de blog, podemos incluirlo en la lista de <strong>props</strong> que este componente acepta, usando la opción <code>props</code>:</p>\n<pre>Vue.component(<span class=\"string\">'blog-post'</span>, {\n  props: [<span class=\"string\">'title'</span>],\n  template: <span class=\"string\">'&lt;h3&gt;{{ title }}&lt;/h3&gt;'</span>\n})</span></pre>\n<p>Un componente puede tener tantas props como se desee, y se puede pasar cualquier valor a cualquier prop de forma predeterminada. En el <em>template</em> anterior, verá que podemos acceder a este valor en la instancia del componente, al igual que con <code>data</code>.</p>\n<p>Una vez que se registra un prop, puede pasarle datos como un atributo personalizado, de la siguiente manera:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">blog-post</span> <span class=\"attr\">title</span>=<span class=\"string\">\"Mi viaje con Vue\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">blog-post</span> <span class=\"attr\">title</span>=<span class=\"string\">\"Blogging con Vue\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">blog-post</span> <span class=\"attr\">title</span>=<span class=\"string\">\"Por qué Vue es tan divertido?\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span></span></pre>\n<p>En una aplicación típica, sin embargo, es probable que tenga un <em>array</em> de <em>post</em> en <code>data</code>:</p>\n<pre><span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#blog-post-demo'</span>,\n  data: {\n    posts: [\n      { <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Mi viaje con Vue'</span> },\n      { <span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Blogging con Vue'</span> },\n      { <span class=\"attr\">id</span>: <span class=\"number\">3</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Por qué Vue es tan divertido?'</span> }\n    ]\n  }\n})</span></pre>\n<p>Entonces querrá renderizar un componente para cada uno:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">blog-post</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-for</span>=<span class=\"string\">\"post in posts\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"post.id\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:title</span>=<span class=\"string\">\"post.title\"</span></span>\n<span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span></span></pre>\n<p>Arriba, verá que podemos usar <code>v-bind</code> para pasar <em>propiedades</em> dinámicamente. Esto es especialmente útil cuando no se conoce el contenido exacto que se va a renderizar con anticipación, como cuando <span class=\"link\">se obtienen posts de una API</span>.</p>\n<p>Esto es todo lo que necesita saber sobre <em>propiedades</em> por ahora, pero una vez que haya terminado de leer esta página y se sienta cómodo con su contenido, le recomendamos volver más tarde para leer la guía completa de <span class=\"link\">Propiedades</span>.</p>\n<h2>Un elemento de una sola raíz</h2><p>Al crear un componente <code>&lt;blog-post&gt;</code>, su <em>plantilla</em> eventualmente no contendrá más que solo el título:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>{{ title }}<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span></pre>\n<p>Como mínimo, querrá incluir el contenido del post:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>{{ title }}<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-html</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Sin embargo, si intenta esto en su plantilla, Vue mostrará un error, explicando que <strong>cada componente debe tener un solo elemento raíz</strong>. Puede corregir este error envolviendo la <em>plantilla</em> en un elemento principal de la siguiente manera:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"blog-post\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>{{ title }}<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-html</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>A medida que nuestro componente crezca, es probable que no solo necesitemos el título y el contenido de una publicación, sino también la fecha de publicación, los comentarios y más. Definir una <em>propiedad</em> para cada pieza de información relacionada podría volverse muy molesto:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">blog-post</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-for</span>=<span class=\"string\">\"post in posts\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"post.id\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:title</span>=<span class=\"string\">\"post.title\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:content</span>=<span class=\"string\">\"post.content\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:publishedAt</span>=<span class=\"string\">\"post.publishedAt\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:comments</span>=<span class=\"string\">\"post.comments\"</span></span>\n<span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span></span></pre>\n<p>Por lo tanto, este podría ser un buen momento para refactorizar el componente <code>&lt;blog-post&gt;</code> para que acepte una única <code>propiedad</code> post:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">blog-post</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-for</span>=<span class=\"string\">\"post in posts\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"post.id\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:post</span>=<span class=\"string\">\"post\"</span></span>\n<span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span></span></pre>\n<pre>Vue.component(<span class=\"string\">'blog-post'</span>, {\n  props: [<span class=\"string\">'post'</span>],\n  template: <span class=\"string\">`</span>\n<span class=\"string\">    &lt;div class=\"blog-post\"&gt;</span>\n<span class=\"string\">      &lt;h3&gt;{{ post.title }}&lt;/h3&gt;</span>\n<span class=\"string\">      &lt;div v-html=\"post.content\"&gt;&lt;/div&gt;</span>\n<span class=\"string\">    &lt;/div&gt;</span>\n<span class=\"string\">  `</span>\n})</span></pre>\n<p></p><p class=\"tip\">El ejemplo anterior y algunos que veremos más adelante, utilizan <span class=\"link\"><em>Plantillas de cadena de texto</em></span> de JavaScript para hacer que las <em>plantillas</em> multilínea sean más legibles. Internet Explorer (IE) no las admite, por lo tanto, si debe ser compatible con IE y no está transpilando (por ejemplo, con Babel o TypeScript), usa <span class=\"link\">escapes de nueva línea</span> en su lugar</p>.<p></p>\n<p>Ahora, cada vez que se agreguen nuevas propiedadaes al objeto <code>post</code>, estarán automáticamente disponible dentro de <code>&lt;blog-post&gt;</code>.</p>\n<h2>Enviando mensajes a componentes padre con eventos</h2><p>A medida que desarrollamos nuestro componente <code>&lt;blog-post&gt;</code>, es posible que algunas funciones requieran la comunicación hacia el componente padre. Por ejemplo, podemos decidir incluir una función de accesibilidad para ampliar el texto de las publicaciones del blog, dejando el resto de la página en su tamaño por defecto:</p>\n<p>En el padre, podemos admitir esta función agregando una propiedad <code>postFontSize</code> en <code>data</code>:</p>\n<pre><span class=\"keyword\">new</span> Vue({\n  el: <span class=\"string\">'#blog-posts-events-demo'</span>,\n  data: {\n    posts: [<span class=\"comment\">/* ... */</span>],\n    postFontSize: <span class=\"number\">1</span>\n  }\n})</span></pre>\n<p>Esta propiedad puede ser usada en la <em>plantilla</em> para controlar el tamaño de la fuente de todas las publicaciones del blog:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"blog-posts-events-demo\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">:style</span>=<span class=\"string\">\"{ fontSize: postFontSize + 'em' }\"</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">blog-post</span></span>\n<span class=\"tag\">      <span class=\"attr\">v-for</span>=<span class=\"string\">\"post in posts\"</span></span>\n<span class=\"tag\">      <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"post.id\"</span></span>\n<span class=\"tag\">      <span class=\"attr\">v-bind:post</span>=<span class=\"string\">\"post\"</span></span>\n<span class=\"tag\">    &gt;</span><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span>\n  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></pre>\n<p>Ahora agreguemos un botón para ampliar el texto justo antes del contenido de cada publicación:</p>\n<pre>Vue.component(<span class=\"string\">'blog-post'</span>, {\n  props: [<span class=\"string\">'post'</span>],\n  template: <span class=\"string\">`</span>\n<span class=\"string\">    &lt;div class=\"blog-post\"&gt;</span>\n<span class=\"string\">      &lt;h3&gt;{{ post.title }}&lt;/h3&gt;</span>\n<span class=\"string\">      &lt;button&gt;</span>\n<span class=\"string\">        Agrandar texto</span>\n<span class=\"string\">      &lt;/button&gt;</span>\n<span class=\"string\">      &lt;div v-html=\"post.content\"&gt;&lt;/div&gt;</span>\n<span class=\"string\">    &lt;/div&gt;</span>\n<span class=\"string\">  `</span>\n})</span></pre>\n<p>El problema es que este botón no hace nada:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span>\n  Agrandar texto\n<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></pre>\n<p>Cuando hacemos clic en el botón, debemos comunicar al componente padre que debe agrandar el texto de todas las publicaciones. Afortunadamente, las instancias de Vue proporcionan un sistema de eventos personalizados para resolver este problema. Para emitir un evento a los padres, podemos llamar al método <span class=\"link\"><strong><code>$emit</code></strong></span>, pasando el nombre del evento:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"$emit('enlarge-text')\"</span>&gt;</span>\n  Agrandar texto\n<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></pre>\n<p>Luego, en nuestro blog post, podemos escuchar este evento con <code>v-on</code>, tal como lo haríamos con un evento DOM nativo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">blog-post</span></span>\n<span class=\"tag\">  <span class=\"attr\">...</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-on:enlarge-text</span>=<span class=\"string\">\"postFontSize += 0.1\"</span></span>\n<span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span></span></pre>\n<h3>Emitiendo un valor con un Evento</h3><p>A veces es útil emitir un valor específico con un evento. Por ejemplo, podemos querer que el componente <code>&lt;blog-post&gt;</code> se encargue de cuánto agrandar el texto. En esos casos, podemos usar el segundo parámetro de <code>$emit</code> para proporcionar este valor:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"$emit('enlarge-text', 0.1)\"</span>&gt;</span>\n  Agrandar texto\n<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></pre>\n<p>Luego, cuando escuchamos el evento en el componente padre, podemos acceder al valor del evento emitido con <code>$event</code>:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">blog-post</span></span>\n<span class=\"tag\">  <span class=\"attr\">...</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-on:enlarge-text</span>=<span class=\"string\">\"postFontSize += $event\"</span></span>\n<span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span></span></pre>\n<p>O, si el controlador de eventos es un método:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">blog-post</span></span>\n<span class=\"tag\">  <span class=\"attr\">...</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-on:enlarge-text</span>=<span class=\"string\">\"onEnlargeText\"</span></span>\n<span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span></span></pre>\n<p>Entonces el valor se pasará como el primer parámetro de ese método:</p>\n<pre>methods: {\n  onEnlargeText: <span class=\"function\"><span class=\"fkeyword\">function</span> (<span class=\"params\">enlargeAmount</span>) </span>{\n    <span class=\"keyword\">this</span>.postFontSize += enlargeAmount\n  }\n}</span></pre>\n<h3>Usando <code>v-model</code> en Componentes</h3><p>Los eventos personalizados también se pueden usar para crear <em>inputs</em> personalizados qu</h3> </h3>e funcionan con <code>v-model</code>. Recuerde que:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"searchText\"</span>&gt;</span></span></pre>\n<p>hace lo mismo que:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">input</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"searchText\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-on:input</span>=<span class=\"string\">\"searchText = $event.target.value\"</span></span>\n<span class=\"tag\">&gt;</span></span></pre>\n<p>Cuando se usa en un componente, <code>v-model</code> en su lugar hace esto:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">custom-input</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"searchText\"</span></span>\n<span class=\"tag\">  <span class=\"attr\">v-on:input</span>=<span class=\"string\">\"searchText = $event\"</span></span>\n<span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">custom-input</span>&gt;</span></span></pre>\n<p>Para que esto realmente funcione, el <code>&lt;input&gt;</code> dentro del componente debe:</p>\n<ul>\n<li>Enlazar el atributo <code>value</code> a una propiedad <code>value</code></li>\n<li>En el <code>input</code>, emitir su propio evento <code>input</code> personalizado con el nuevo valor</li>\n</ul>\n<p>Aquí está en acción:</p>\n<pre>Vue.component(<span class=\"string\">'custom-input'</span>, {\n  props: [<span class=\"string\">'value'</span>],\n  template: <span class=\"string\">`</span>\n<span class=\"string\">    &lt;input</span>\n<span class=\"string\">      v-bind:value=\"value\"</span>\n<span class=\"string\">      v-on:input=\"$emit('input', $event.target.value)\"</span>\n<span class=\"string\">    &gt;</span>\n<span class=\"string\">  `</span>\n})</span></pre>\n<p>Ahora <code>v-model</code> debería funcionar perfectamente con este componente:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">custom-input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"searchText\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">custom-input</span>&gt;</span></span></pre>\n<p>Por ahora, eso es todo lo que necesita saber sobre los eventos de componentes personalizados, pero una vez que haya terminado de leer esta página y se sienta cómodo con su contenido, le recomendamos volver más tarde para leer la guía completa sobre <span class=\"link\">Eventos Personalizados</span>.</p>\n<h2>Distribución de contenido con Slots</h2><p>Al igual que con los elementos HTML, a menudo es útil poder pasar contenido a un componente, como este:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">alert-box</span>&gt;</span>\n  Algo ha ocurrido mal.\n<span class=\"tag\">&lt;/<span class=\"name\">alert-box</span>&gt;</span></span></pre>\n<p>Afortunadamente, esta tarea se hace muy simple con el elemento personalizado <code>&lt;slot&gt;</code> de Vue:</p>\n<pre>Vue.component(<span class=\"string\">'alert-box'</span>, {\n  template: <span class=\"string\">`</span>\n<span class=\"string\">    &lt;div class=\"demo-alert-box\"&gt;</span>\n<span class=\"string\">      &lt;strong&gt;Error!&lt;/strong&gt;</span>\n<span class=\"string\">      &lt;slot&gt;&lt;/slot&gt;</span>\n<span class=\"string\">    &lt;/div&gt;</span>\n<span class=\"string\">  `</span>\n})</span></pre>\n<p>Como verá más arriba, solo agregamos la ranura a la que queremos que el contenido vaya – y eso es todo. Hemos terminado!</p>\n<p>Eso es todo lo que necesita saber acerca de slots por ahora, pero una vez que haya terminado de leer esta página y se sienta cómodo con su contenido, le recomendamos que regrese más tarde para leer la guía completa de <span class=\"link\">Slots</span>.</p>\n<h2>Componentes dinámicos</h2><p>A veces, es útil cambiar dinámicamente entre componentes, como en una interfaz con pestañas:</p>\n<p>Lo anterior es posible gracias al elemento <code>&lt;component&gt;</code> de Vue con el atributo especial <code>is</code>:</p>\n<pre><span class=\"comment\">&lt;!-- El componente cambia cuando currentTabComponent cambia --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">v-bind:is</span>=<span class=\"string\">\"currentTabComponent\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></span></pre>\n<p>En el ejemplo anterior, <code>currentTabComponent</code> puede contener:</p>\n<ul>\n<li>el nombre de un componente registrado, o</li>\n<li>un objeto de opciones de un componente</li>\n</ul>\n<p>Vea <span class=\"link\">este fiddle</span> para experimentar con el código completo, o <span class=\"link\">esta versión</span> para un ejemplo de enlace o <em>binding</em> al objeto de opciones de un componente, en lugar de su nombre registrado.</p>\n<p>Eso es todo lo que necesita saber sobre los componentes dinámicos por ahora, pero una vez que haya terminado de leer esta página y se sienta cómodo con su contenido, le recomendamos volver más tarde para leer la guía completa sobre <span class=\"link\">Componentes Dinámicos y Asíncronos</span>.</p>\n<h2>Casos especiales de análisis de plantillas DOM.</h2><p>Algunos elementos HTML, como <code>&lt;ul&gt;</code>, <code>&lt;ol&gt;</code>, <code>&lt;table&gt;</code> y <code>&lt;select&gt;</code> tienen restricciones sobre qué elementos pueden aparecer dentro de ellos, y algunos elementos como <code>&lt;li&gt;</code>, <code>&lt;tr&gt;</code> y <code>&lt;option&gt;</code> solo pueden aparecer dentro de ciertos otros elementos.</p>\n<p>Esto conducirá a problemas cuando se utilizan componentes con elementos que tienen tales restricciones. Por ejemplo:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">blog-post-row</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">blog-post-row</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span></pre>\n<p>El componente personalizado <code>&lt;blog-post-row&gt;</code> se colocará como contenido no válido, lo que provocará errores en el resultado final. Afortunadamente, el atributo especial <code>is</code> ofrece una solución alternativa:</p>\n<pre><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"name\">tr</span> <span class=\"attr\">is</span>=<span class=\"string\">\"blog-post-row\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span></pre>\n<p>Debe tenerse en cuenta que <strong>esta limitación no se aplica si está utilizando plantillas de cadenas de texto de una de las siguientes fuentes</strong>:</p>\n<ul>\n<li><em>Plantillas de cadenas de texto</em> (ej: <code>template: '...'</code>)</li>\n<li><span class=\"link\">Componentes de un solo archivo</span> (<code>.vue</code>)</li>\n<li><span class=\"link\"><code>&lt;script type=\"text/x-template\"&gt;</code></span></li>\n</ul>\n<p>Eso es todo lo que necesita saber sobre los casos especiales de análisis de plantillas DOM por ahora, y en realidad, el final de los aspectos <em>esenciales</em> de Vue. ¡Felicidades! Todavía hay más que aprender, pero primero, recomendamos tomar un descanso para practicar con Vue usted mismo y construir algo divertido.</p>\n<p>Una vez que se sienta cómodo con el conocimiento que acaba de digerir, le recomendamos que regrese para leer la guía completa de <span class=\"link\">Componentes Dinámicos y Asíncronos</span>, así como las otras páginas en la sección <em>Componentes en Profundidad</em> de la barra lateral.</p>"
  }
]