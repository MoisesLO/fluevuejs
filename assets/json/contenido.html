<h1>La instancia Vue</h1>
<h2>Creando una instancia de Vue</h2>
<p>Cada aplicación de Vue se comienza creando una nueva <strong>Instancia de Vue</strong> con la
    función <code>Vue</code>:</p>
<pre><code><span>var</span> vm = <span>new</span> Vue({
  <span>// options</span>
})</code></pre>

<p>Aunque no estrictamente asociado con el patrón MVVM, el diseño de Vue fue en parte inspirado por
    él.<br>Como
    una convención, solemos usar la variable <code>vm</code> (abreviación de ViewModel) para
    hacer referencia a nuestra instancia de Vue.</p>
<p>Cuando usted crea una instancia de Vue, le pasa un <strong>objeto options</strong>. La mayor
    parte de esta guía describe cómo usted puede usar estas opciones para crear el
    comportamiento deseado.<br>Como referencia, usted puede visitar también la lista completa de
    opciones en la documentación de la API.</p>
<p>Una aplicación Vue está conformada por una <strong>instancia Vue raíz</strong> creada con
    <code>new Vue</code>, opcionalmente organizada dentro de un árbol de componentes reusables
    anidados. Por ejemplo, el árbol de una aplicación TO-DO podría verse así:</p>
<pre><code>Root Instance
└─ TodoList
   ├─ TodoItem
   │  ├─ TodoButtonDelete
   │  └─ TodoButtonEdit
   └─ TodoListFooter
      ├─ TodosButtonClear
      └─ TodoListStatistics</code></pre>

<p>Hablaremos sobre el sistema de componentes en detalle después.
    Por ahora, solo es necesario saber que todos los componentes de Vue son también instancias
    de Vue, por lo tanto aceptan el mismo objeto options (excepto para unas pocas específicas
    opciones de raíz).</p>
<h2>Datos y Métodos</h2>
<p>Cuando una instancia Vue es creada, agrega todas las propiedades encontradas en su objeto
    <code>data</code> al <strong>sistema de reactividad</strong> de Vue. Cuando los valores de
    estas propiedades cambian, la vista “reaccionará”, actualizándose para coincidir con los
    nuevos valores.</p>
<pre><code><span>// Our data object</span>
<span>var</span> data = { <span>a</span>: <span>1</span> }

<span>// The object is added to a Vue instance</span>
<span>var</span> vm = <span>new</span> Vue({
  <span>data</span>: data
})

<span>// Getting the property on the instance</span>
<span>// returns the one from the original data</span>
vm.a == data.a <span>// =&gt; true</span>

<span>// Setting the property on the instance</span>
<span>// also affects the original data</span>
vm.a = <span>2</span>
data.a <span>// =&gt; 2</span>

<span>// ... and vice-versa</span>
data.a = <span>3</span>
vm.a <span>// =&gt; 3</span></code></pre>

<p>Cuando estos datos cambian, la vista volverá a renderizarse. Es preciso señalar que las
    propiedades en <code>data</code> solo son <strong>reactivas</strong> si ya existían cuando
    se creó la instancia. Eso significa que si usted agrega una nueva propiedad, como:</p>
<pre><code>vm.b = <span>'hi'</span></code></pre>
<p>Entonces los cambios de <code>b</code> no producirán ninguna actualización en la vista. Si
    sabe que necesitará una propiedad más adelante, pero comienza vacía o inexistente,
    necesitará setear un valor inicial. Por ejemplo:</p>
<pre><code>data: {
  <span>newTodoText</span>: <span>''</span>,
  <span>visitCount</span>: <span>0</span>,
  <span>hideCompletedTodos</span>: <span>false</span>,
  <span>todos</span>: [],
  <span>error</span>: <span>null</span>
}</code></pre>
<p>La unica excepción a esto es el uso de <code>Object.freeze()</code>, lo que evita que se
    modifiquen las propiedades existentes, lo que también significa que el sistema de
    reactividad no puede rastrear cambios.</p>
<pre><code><span>var</span> obj = {
  <span>foo</span>: <span>'bar'</span>
}

<span>Object</span>.freeze(obj)

<span>new</span> Vue({
  <span>el</span>: <span>'#app'</span>,
  <span>data</span>: obj
})</code></pre>
<br>
<pre><code><span>&lt;<span>div</span> <span>id</span>=<span>"app"</span>&gt;</span>
  <span>&lt;<span>p</span>&gt;</span>{{ foo }}<span>&lt;/<span>p</span>&gt;</span>
  <span>&lt;!-- this will no longer update `foo`! --&gt;</span>
  <span>&lt;<span>button</span> <span>v-on:click</span>=<span>"foo = 'baz'"</span>&gt;</span>Change it<span>&lt;/<span>button</span>&gt;</span>
<span>&lt;/<span>div</span>&gt;</span></code></pre>

<p>Además de las propiedades de datos, las instancias de Vue exponen una serie de métodos y
    propiedades de instancia útiles. Estos tienen el prefijo <code>$</code> para diferenciarlos
    de las propiedades definidas por el usuario. Por ejemplo:</p>
<pre><code><span>var</span> data = { <span>a</span>: <span>1</span> }
<span>var</span> vm = <span>new</span> Vue({
  <span>el</span>: <span>'#example'</span>,
  <span>data</span>: data
})

vm.$data === data <span>// =&gt; true</span>
vm.$el === <span>document</span>.getElementById(<span>'example'</span>) <span>// =&gt; true</span>

<span>// $watch is an instance method</span>
vm.$watch(<span>'a'</span>, <span><span>function</span> (<span>newValue, oldValue</span>) </span>{
  <span>// This callback will be called when `vm.a` changes</span>
})</code></pre>
<p>En el futuro, puede consultar la documentación de la
    API para una lista completa de propiedades y métodos de instancia.</p>
<h2>Hooks del Ciclo de vida
    de la Instancia</h2>
<p>Cada instancia de Vue pasa a través de una serie de pasos de inicialización cuando es creada
    - por ejemplo, se necesita configurar la observación de datos, compilar la plantilla, montar
    la instancia en el DOM y actualizar el DOM cuando cambian los datos. En el camino, también
    se ejecutan funciones llamadas <strong>hooks del ciclo de vida</strong>, lo que brinda a los
    usuarios la oportunidad de agregar su propio código en etapas específicas.</p>
<p>Por ejemplo, el hook <code>created</code> puede ser utilizado
    para ejecutar código después que una instancia es creada:</p>
<pre><code><span>new</span> Vue({
  <span>data</span>: {
    <span>a</span>: <span>1</span>
  },
  <span>created</span>: <span><span>function</span> (<span></span>) </span>{
    <span>// `this` points to the vm instance</span>
    <span>console</span>.log(<span>'a is: '</span> + <span>this</span>.a)
  }
})
<span>// =&gt; "a is: 1"</span></code></pre>
<p>También hay otros hooks que se llamarán en diferentes etapas del ciclo de vida de la
    instancia, como <code>mounted</code>, <code>updated</code>, y <code>destroyed</code>. Todos los
    hooks del ciclo de
    vida se llaman en el contexto <code>this</code> apuntando a la instancia de Vue que lo
    invoca.</p>
<p>No usar arrow functions en una propiedad de opciones o
    respuesta, como <code>created: () =&gt; console.log(this.a)</code> or <code>vm.$watch('a',
        newValue =&gt; this.myMethod())</code>. Dado que las arrow functions están vinculadas al
    contexto padre, <code>this</code> no será la instancia de Vue como lo esperaría, lo que
    suele producir errores, como ‘Uncaught TypeError: Cannot read property of
    undefined<code>o</code>Uncaught TypeError: this.myMethod is not a function`.</p>

<h2>Diagrama
    del Ciclo de vida</h2>
<p>La imagen de abajo es un diagrama para el ciclo de vida de una instancia. No es necesario que
    entienda como funciona todo en este momento, pero a medida que aprenda y construya más, será
    una referencia útil.</p>
<img src="asset://assets/img/lifecycle.png" alt="">