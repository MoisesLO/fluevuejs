<h1>Propiedades Computadas y Observadores</h1>

<h2><span class="link">Propiedades Computadas</span></h2>
<p>Las expresiones en el <em>template</em> son muy convenientes, pero están diseñadas para operaciones simples. Poner demasiada lógica en sus <em>templates</em> puede hacerlos grandes, complejos y difíciles de mantener. Por ejemplo:</p>
<pre><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span>
  {{ message.split('').reverse().join('') }}
<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></pre>
<p>En este punto, el <em>template</em> ya no es simple y declarativo. Debe mirarlo por un segundo antes de darse cuenta de que muestra <code>message</code> al revés. El problema se agrava cuando desea incluir el mensaje invertido en su <em>template</em> más de una vez.</p>
<p>Es por eso que para cualquier lógica compleja, deberia usar una <strong>propiedad computada</strong>.</p>
<h3><span class="link">Ejemplo Básico</span></h3>
<pre><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span>
  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Mensaje original: "{{ message }}"<span class="tag">&lt;/<span class="name">p</span>&gt;</span>
  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Mensaje invertido computado: "{{ reversedMessage }}"<span class="tag">&lt;/<span class="name">p</span>&gt;</span>
<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></pre>
<pre><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue({
  el: <span class="string">'#example'</span>,
  data: {
    message: <span class="string">'Hola'</span>
  },
  computed: {
    <span class="comment">// un getter computado</span>
    reversedMessage: <span class="function"><span class="fkeyword">function</span> (<span class="params"></span>) </span>{
      <span class="comment">// `this` apunta a la instancia vm</span>
      <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)
    }
  }
})</span></pre>


<p>Aquí hemos declarado una propiedad computada <code>reversedMessage</code>. La función que
proporcionemos se utilizará como la función getter para la propiedad <code>vm.reversedMessage</code>:</p>
<pre><span class="built_in">console</span>.log(vm.reversedMessage) <span class="comment">// =&gt; 'aloH'</span>
vm.message = <span class="string">'Adios'</span>
<span class="built_in">console</span>.log(vm.reversedMessage) <span class="comment">// =&gt; 'soidA'</span></span></pre>
<p>Puede abrir la consola y jugar con el ejemplo vm usted mismo. El valor de <code>vm.reversedMessage</code> siempre depende del valor de <code>vm.message</code>.</p>
<p>Puede enlazar datos a propiedades computadas en el <em>template</em> al igual que una propiedad normal. Vue es consciente de que <code>vm.reversedMessage</code> depende de <code>vm.message</code>, por lo cual actualizará todos los enlaces que dependan de <code>vm.reversedMessage</code> cuando <code>vm.message</code> cambie. Y lo mejor de todo es que hemos creado esta relación de dependencia de manera declarativa: la función computada getter no tiene efectos secundarios, lo que facilita la prueba y la comprensión.</p>
<h3><span class="link">Caching computado vs Métodos</span></h3>
<p>Es posible que haya notado que podemos lograr el mismo resultado al invocar un método en la expresión:</p>
<pre><span class="tag">&lt;<span class="name">p</span>&gt;</span>Mensaje Invertido: "{{ reverseMessage() }}"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></pre>
<pre><span class="comment">// en componente</span>
methods: {
  reverseMessage: <span class="function"><span class="fkeyword">function</span> (<span class="params"></span>) </span>{
    <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)
  }
}</span></pre>
<p>En lugar de una propiedad computada, podemos definir la misma función como un método en su lugar. Para el resultado final, los dos enfoques son exactamente los mismos. Sin embargo, la diferencia es que las <strong>propiedades computadas se almacenan en caché según sus dependencias.</strong> Una propiedad computada solo se volverá a evaluar cuando alguna de sus dependencias haya cambiado. Esto significa que mientras <code>message</code> no haya cambiado, el acceso múltiple a la propiedad computada de <code>reverseMessage</code> regresará inmediatamente el resultado previamente calculado sin tener que ejecutar la función de nuevo.</p>
<p>Esto también significa que la siguiente propiedad computada nunca se actualizará, porque <code>Date.now()</code> no es una dependencia reactiva:</p>
<pre>computed: {
  now: <span class="function"><span class="fkeyword">function</span> (<span class="params"></span>) </span>{
    <span class="keyword">return</span> <span class="built_in">Date</span>.now()
  }
}</span></pre>
<p>En comparación, una invocación de método <strong>siempre</strong> ejecutará la función cada vez que ocurre una re-renderizacion.</p>
<p>¿Por qué necesitamos caché? Imagina que tenemos una costosa propiedad computada <strong>A</strong>, que requiere hacer un bucle a través de una gran matriz y hace muchos cálculos. Entonces podemos tener otras propiedades computadas que a su vez dependen de <strong>A</strong>. Sin caché, estaríamos ejecutando el captador de <strong>A</strong> muchas veces más de lo necesario. En los casos en que no desee el almacenamiento en caché, utilice un método en su lugar.</p>
<h3><span class="link">Propiedad Computada vs Watched</span></h3>
<p>Vue proporciona una forma más genérica de observar y reaccionar a los cambios de datos en una instancia de Vue: <strong>propiedad watch</strong>. Cuando tiene algunos datos que necesitan cambiarse en función de otros datos, es tentador utilizar <code>watch</code> en exceso, especialmente si proviene de tener experiencia en AngularJS. Sin embargo, a menudo es una mejor idea usar una propiedad computada en lugar de una imperativa llamada a <code>watch</code> . Considera este ejemplo:</p>
<pre><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>{{ fullName }}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></pre>
<pre><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue({
  el: <span class="string">'#demo'</span>,
  data: {
    firstName: <span class="string">'Foo'</span>,
    lastName: <span class="string">'Bar'</span>,
    fullName: <span class="string">'Foo Bar'</span>
  },
  watch: {
    firstName: <span class="function"><span class="fkeyword">function</span> (<span class="params">val</span>) </span>{
      <span class="keyword">this</span>.fullName = val + <span class="string">' '</span> + <span class="keyword">this</span>.lastName
    },
    lastName: <span class="function"><span class="fkeyword">function</span> (<span class="params">val</span>) </span>{
      <span class="keyword">this</span>.fullName = <span class="keyword">this</span>.firstName + <span class="string">' '</span> + val
    }
  }
})</span></pre>
<p>El código anterior es imperativo y repetitivo. Compáralo con una versión de propiedad computada:</p>
<pre><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue({
  el: <span class="string">'#demo'</span>,
  data: {
    firstName: <span class="string">'Foo'</span>,
    lastName: <span class="string">'Bar'</span>
  },
  computed: {
    fullName: <span class="function"><span class="fkeyword">function</span> (<span class="params"></span>) </span>{
      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName
    }
  }
})</span></pre>
<p>Mucho mejor, ¿no?</p>
<h3><span class="link">Setter Computado</span></h3>
<p>Las propiedades computadas son, de forma predeterminada solo get, pero también puede proporcionar un set cuando lo necesite:</p>
<pre><span class="comment">// ...</span>
computed: {
  fullName: {
    <span class="comment">// getter</span>
    get: <span class="function"><span class="fkeyword">function</span> (<span class="params"></span>) </span>{
      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName
    },
    <span class="comment">// setter</span>
    set: <span class="function"><span class="fkeyword">function</span> (<span class="params">newValue</span>) </span>{
      <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)
      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]
      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]
    }
  }
}
<span class="comment">// ...</span></span></pre>
<p>Ahora, cuando ejecute <code>vm.fullName = 'John Doe'</code>, se invocará el definidor y <code>vm.firstName</code> y <code>vm.lastName</code> se actualizarán en consecuencia.</p>
<h2><span class="link">Watchers</span></h2>
<p>Si bien las propiedades computadas son más apropiadas en la mayoría de los casos, hay ocasiones en que es necesario un observador personalizado. Es por eso que Vue proporciona una forma más genérica de reaccionar a los cambios de datos a través de la opción <code>watch</code>. Esto es más útil cuando desea realizar operaciones asíncronas o costosas en respuesta al cambio de datos.</p>
<p>por ejemplo:</p>
<pre><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"watch-example"</span>&gt;</span>
  <span class="tag">&lt;<span class="name">p</span>&gt;</span>
    Haz una pregunta de sí/no:
    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"question"</span>&gt;</span>
  <span class="tag">&lt;/<span class="name">p</span>&gt;</span>
  <span class="tag">&lt;<span class="name">p</span>&gt;</span>{{ answer }}<span class="tag">&lt;/<span class="name">p</span>&gt;</span>
<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></pre>
<pre>
var watchExampleVM = new Vue({
  el: '#watch-example',
  data: {
    question: '',
    answer: 'No puedo darte una respuesta hasta que hagas una pregunta!!'
  },
  watch: {
    question: function (newQuestion, oldQuestion) {
      this.answer = 'Esperando que deje de escribir......'
      this.debouncedGetAnswer()
    }
  },
  created: function () {
    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)
  },
  methods: {
    getAnswer:  function () {
      if (this.question.indexOf('?') === -1) {
        this.answer = 'Las preguntas suelen contener un signo de interrogación. ;-)'
        return
      }
      this.answer = 'Pensando...'
      var vm = this
      axios.get('https://yesno.wtf/api')
        .then(function (response) {
          vm.answer = _.capitalize(response.data.answer)
        })
        .catch(function (error) {
          vm.answer = '¡Error! No se pudo alcanzar la API. ' + error
        })
    }
  }
})
</pre>
  
<p>En este caso, el uso de la opción <code>watch</code> nos permite realizar una operación asíncrona (acceder a una API), limita la frecuencia con la que realizamos esa operación y establece estados intermedios hasta que obtengamos una respuesta final. Nada de eso sería posible con una propiedad computada.</p>
<p>Además de la opción <code>watch</code>, también puede usar el imperativo <span class="link">vm.$Watch API</span>.</p>